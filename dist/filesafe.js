module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this;
}() || Function("return this")());

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;(function (f) {
  if (true) {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;

    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }

    g.SF = f();
  }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return require(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }

          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }

        return n[i].exports;
      }

      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);

      return o;
    }

    return r;
  }()({
    1: [function (require, module, exports) {
      (function (global) {
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */
        var CryptoJS = CryptoJS || function (u, p) {
          var d = {},
              l = d.lib = {},
              s = function () {},
              t = l.Base = {
            extend: function (a) {
              s.prototype = this;
              var c = new s();
              a && c.mixIn(a);
              c.hasOwnProperty("init") || (c.init = function () {
                c.$super.init.apply(this, arguments);
              });
              c.init.prototype = c;
              c.$super = this;
              return c;
            },
            create: function () {
              var a = this.extend();
              a.init.apply(a, arguments);
              return a;
            },
            init: function () {},
            mixIn: function (a) {
              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);

              a.hasOwnProperty("toString") && (this.toString = a.toString);
            },
            clone: function () {
              return this.init.prototype.extend(this);
            }
          },
              r = l.WordArray = t.extend({
            init: function (a, c) {
              a = this.words = a || [];
              this.sigBytes = c != p ? c : 4 * a.length;
            },
            toString: function (a) {
              return (a || v).stringify(this);
            },
            concat: function (a) {
              var c = this.words,
                  e = a.words,
                  j = this.sigBytes;
              a = a.sigBytes;
              this.clamp();
              if (j % 4) for (var k = 0; k < a; k++) c[j + k >>> 2] |= (e[k >>> 2] >>> 24 - 8 * (k % 4) & 255) << 24 - 8 * ((j + k) % 4);else if (65535 < e.length) for (k = 0; k < a; k += 4) c[j + k >>> 2] = e[k >>> 2];else c.push.apply(c, e);
              this.sigBytes += a;
              return this;
            },
            clamp: function () {
              var a = this.words,
                  c = this.sigBytes;
              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
              a.length = u.ceil(c / 4);
            },
            clone: function () {
              var a = t.clone.call(this);
              a.words = this.words.slice(0);
              return a;
            },
            random: function (a) {
              for (var c = [], e = 0; e < a; e += 4) c.push(4294967296 * u.random() | 0);

              return new r.init(c, a);
            }
          }),
              w = d.enc = {},
              v = w.Hex = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var e = [], j = 0; j < a; j++) {
                var k = c[j >>> 2] >>> 24 - 8 * (j % 4) & 255;
                e.push((k >>> 4).toString(16));
                e.push((k & 15).toString(16));
              }

              return e.join("");
            },
            parse: function (a) {
              for (var c = a.length, e = [], j = 0; j < c; j += 2) e[j >>> 3] |= parseInt(a.substr(j, 2), 16) << 24 - 4 * (j % 8);

              return new r.init(e, c / 2);
            }
          },
              b = w.Latin1 = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var e = [], j = 0; j < a; j++) e.push(String.fromCharCode(c[j >>> 2] >>> 24 - 8 * (j % 4) & 255));

              return e.join("");
            },
            parse: function (a) {
              for (var c = a.length, e = [], j = 0; j < c; j++) e[j >>> 2] |= (a.charCodeAt(j) & 255) << 24 - 8 * (j % 4);

              return new r.init(e, c);
            }
          },
              x = w.Utf8 = {
            stringify: function (a) {
              try {
                return decodeURIComponent(escape(b.stringify(a)));
              } catch (c) {
                throw Error("Malformed UTF-8 data");
              }
            },
            parse: function (a) {
              return b.parse(unescape(encodeURIComponent(a)));
            }
          },
              q = l.BufferedBlockAlgorithm = t.extend({
            reset: function () {
              this._data = new r.init();
              this._nDataBytes = 0;
            },
            _append: function (a) {
              "string" == typeof a && (a = x.parse(a));

              this._data.concat(a);

              this._nDataBytes += a.sigBytes;
            },
            _process: function (a) {
              var c = this._data,
                  e = c.words,
                  j = c.sigBytes,
                  k = this.blockSize,
                  b = j / (4 * k),
                  b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0);
              a = b * k;
              j = u.min(4 * a, j);

              if (a) {
                for (var q = 0; q < a; q += k) this._doProcessBlock(e, q);

                q = e.splice(0, a);
                c.sigBytes -= j;
              }

              return new r.init(q, j);
            },
            clone: function () {
              var a = t.clone.call(this);
              a._data = this._data.clone();
              return a;
            },
            _minBufferSize: 0
          });

          l.Hasher = q.extend({
            cfg: t.extend(),
            init: function (a) {
              this.cfg = this.cfg.extend(a);
              this.reset();
            },
            reset: function () {
              q.reset.call(this);

              this._doReset();
            },
            update: function (a) {
              this._append(a);

              this._process();

              return this;
            },
            finalize: function (a) {
              a && this._append(a);
              return this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function (a) {
              return function (b, e) {
                return new a.init(e).finalize(b);
              };
            },
            _createHmacHelper: function (a) {
              return function (b, e) {
                return new n.HMAC.init(a, e).finalize(b);
              };
            }
          });
          var n = d.algo = {};
          return d;
        }(Math);

        (function () {
          var u = CryptoJS,
              p = u.lib.WordArray;
          u.enc.Base64 = {
            stringify: function (d) {
              var l = d.words,
                  p = d.sigBytes,
                  t = this._map;
              d.clamp();
              d = [];

              for (var r = 0; r < p; r += 3) for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && r + 0.75 * v < p; v++) d.push(t.charAt(w >>> 6 * (3 - v) & 63));

              if (l = t.charAt(64)) for (; d.length % 4;) d.push(l);
              return d.join("");
            },
            parse: function (d) {
              var l = d.length,
                  s = this._map,
                  t = s.charAt(64);
              t && (t = d.indexOf(t), -1 != t && (l = t));

              for (var t = [], r = 0, w = 0; w < l; w++) if (w % 4) {
                var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4),
                    b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4);
                t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4);
                r++;
              }

              return p.create(t, r);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
          };
        })();

        (function (u) {
          function p(b, n, a, c, e, j, k) {
            b = b + (n & a | ~n & c) + e + k;
            return (b << j | b >>> 32 - j) + n;
          }

          function d(b, n, a, c, e, j, k) {
            b = b + (n & c | a & ~c) + e + k;
            return (b << j | b >>> 32 - j) + n;
          }

          function l(b, n, a, c, e, j, k) {
            b = b + (n ^ a ^ c) + e + k;
            return (b << j | b >>> 32 - j) + n;
          }

          function s(b, n, a, c, e, j, k) {
            b = b + (a ^ (n | ~c)) + e + k;
            return (b << j | b >>> 32 - j) + n;
          }

          for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++) b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;

          r = r.MD5 = v.extend({
            _doReset: function () {
              this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878]);
            },
            _doProcessBlock: function (q, n) {
              for (var a = 0; 16 > a; a++) {
                var c = n + a,
                    e = q[c];
                q[c] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;
              }

              var a = this._hash.words,
                  c = q[n + 0],
                  e = q[n + 1],
                  j = q[n + 2],
                  k = q[n + 3],
                  z = q[n + 4],
                  r = q[n + 5],
                  t = q[n + 6],
                  w = q[n + 7],
                  v = q[n + 8],
                  A = q[n + 9],
                  B = q[n + 10],
                  C = q[n + 11],
                  u = q[n + 12],
                  D = q[n + 13],
                  E = q[n + 14],
                  x = q[n + 15],
                  f = a[0],
                  m = a[1],
                  g = a[2],
                  h = a[3],
                  f = p(f, m, g, h, c, 7, b[0]),
                  h = p(h, f, m, g, e, 12, b[1]),
                  g = p(g, h, f, m, j, 17, b[2]),
                  m = p(m, g, h, f, k, 22, b[3]),
                  f = p(f, m, g, h, z, 7, b[4]),
                  h = p(h, f, m, g, r, 12, b[5]),
                  g = p(g, h, f, m, t, 17, b[6]),
                  m = p(m, g, h, f, w, 22, b[7]),
                  f = p(f, m, g, h, v, 7, b[8]),
                  h = p(h, f, m, g, A, 12, b[9]),
                  g = p(g, h, f, m, B, 17, b[10]),
                  m = p(m, g, h, f, C, 22, b[11]),
                  f = p(f, m, g, h, u, 7, b[12]),
                  h = p(h, f, m, g, D, 12, b[13]),
                  g = p(g, h, f, m, E, 17, b[14]),
                  m = p(m, g, h, f, x, 22, b[15]),
                  f = d(f, m, g, h, e, 5, b[16]),
                  h = d(h, f, m, g, t, 9, b[17]),
                  g = d(g, h, f, m, C, 14, b[18]),
                  m = d(m, g, h, f, c, 20, b[19]),
                  f = d(f, m, g, h, r, 5, b[20]),
                  h = d(h, f, m, g, B, 9, b[21]),
                  g = d(g, h, f, m, x, 14, b[22]),
                  m = d(m, g, h, f, z, 20, b[23]),
                  f = d(f, m, g, h, A, 5, b[24]),
                  h = d(h, f, m, g, E, 9, b[25]),
                  g = d(g, h, f, m, k, 14, b[26]),
                  m = d(m, g, h, f, v, 20, b[27]),
                  f = d(f, m, g, h, D, 5, b[28]),
                  h = d(h, f, m, g, j, 9, b[29]),
                  g = d(g, h, f, m, w, 14, b[30]),
                  m = d(m, g, h, f, u, 20, b[31]),
                  f = l(f, m, g, h, r, 4, b[32]),
                  h = l(h, f, m, g, v, 11, b[33]),
                  g = l(g, h, f, m, C, 16, b[34]),
                  m = l(m, g, h, f, E, 23, b[35]),
                  f = l(f, m, g, h, e, 4, b[36]),
                  h = l(h, f, m, g, z, 11, b[37]),
                  g = l(g, h, f, m, w, 16, b[38]),
                  m = l(m, g, h, f, B, 23, b[39]),
                  f = l(f, m, g, h, D, 4, b[40]),
                  h = l(h, f, m, g, c, 11, b[41]),
                  g = l(g, h, f, m, k, 16, b[42]),
                  m = l(m, g, h, f, t, 23, b[43]),
                  f = l(f, m, g, h, A, 4, b[44]),
                  h = l(h, f, m, g, u, 11, b[45]),
                  g = l(g, h, f, m, x, 16, b[46]),
                  m = l(m, g, h, f, j, 23, b[47]),
                  f = s(f, m, g, h, c, 6, b[48]),
                  h = s(h, f, m, g, w, 10, b[49]),
                  g = s(g, h, f, m, E, 15, b[50]),
                  m = s(m, g, h, f, r, 21, b[51]),
                  f = s(f, m, g, h, u, 6, b[52]),
                  h = s(h, f, m, g, k, 10, b[53]),
                  g = s(g, h, f, m, B, 15, b[54]),
                  m = s(m, g, h, f, e, 21, b[55]),
                  f = s(f, m, g, h, v, 6, b[56]),
                  h = s(h, f, m, g, x, 10, b[57]),
                  g = s(g, h, f, m, t, 15, b[58]),
                  m = s(m, g, h, f, D, 21, b[59]),
                  f = s(f, m, g, h, z, 6, b[60]),
                  h = s(h, f, m, g, C, 10, b[61]),
                  g = s(g, h, f, m, j, 15, b[62]),
                  m = s(m, g, h, f, A, 21, b[63]);
              a[0] = a[0] + f | 0;
              a[1] = a[1] + m | 0;
              a[2] = a[2] + g | 0;
              a[3] = a[3] + h | 0;
            },
            _doFinalize: function () {
              var b = this._data,
                  n = b.words,
                  a = 8 * this._nDataBytes,
                  c = 8 * b.sigBytes;
              n[c >>> 5] |= 128 << 24 - c % 32;
              var e = u.floor(a / 4294967296);
              n[(c + 64 >>> 9 << 4) + 15] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;
              n[(c + 64 >>> 9 << 4) + 14] = (a << 8 | a >>> 24) & 16711935 | (a << 24 | a >>> 8) & 4278255360;
              b.sigBytes = 4 * (n.length + 1);

              this._process();

              b = this._hash;
              n = b.words;

              for (a = 0; 4 > a; a++) c = n[a], n[a] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;

              return b;
            },
            clone: function () {
              var b = v.clone.call(this);
              b._hash = this._hash.clone();
              return b;
            }
          });
          t.MD5 = v._createHelper(r);
          t.HmacMD5 = v._createHmacHelper(r);
        })(Math);

        (function () {
          var u = CryptoJS,
              p = u.lib,
              d = p.Base,
              l = p.WordArray,
              p = u.algo,
              s = p.EvpKDF = d.extend({
            cfg: d.extend({
              keySize: 4,
              hasher: p.MD5,
              iterations: 1
            }),
            init: function (d) {
              this.cfg = this.cfg.extend(d);
            },
            compute: function (d, r) {
              for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q;) {
                n && s.update(n);
                var n = s.update(d).finalize(r);
                s.reset();

                for (var a = 1; a < p; a++) n = s.finalize(n), s.reset();

                b.concat(n);
              }

              b.sigBytes = 4 * q;
              return b;
            }
          });

          u.EvpKDF = function (d, l, p) {
            return s.create(p).compute(d, l);
          };
        })();

        CryptoJS.lib.Cipher || function (u) {
          var p = CryptoJS,
              d = p.lib,
              l = d.Base,
              s = d.WordArray,
              t = d.BufferedBlockAlgorithm,
              r = p.enc.Base64,
              w = p.algo.EvpKDF,
              v = d.Cipher = t.extend({
            cfg: l.extend(),
            createEncryptor: function (e, a) {
              return this.create(this._ENC_XFORM_MODE, e, a);
            },
            createDecryptor: function (e, a) {
              return this.create(this._DEC_XFORM_MODE, e, a);
            },
            init: function (e, a, b) {
              this.cfg = this.cfg.extend(b);
              this._xformMode = e;
              this._key = a;
              this.reset();
            },
            reset: function () {
              t.reset.call(this);

              this._doReset();
            },
            process: function (e) {
              this._append(e);

              return this._process();
            },
            finalize: function (e) {
              e && this._append(e);
              return this._doFinalize();
            },
            keySize: 4,
            ivSize: 4,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            _createHelper: function (e) {
              return {
                encrypt: function (b, k, d) {
                  return ("string" == typeof k ? c : a).encrypt(e, b, k, d);
                },
                decrypt: function (b, k, d) {
                  return ("string" == typeof k ? c : a).decrypt(e, b, k, d);
                }
              };
            }
          });
          d.StreamCipher = v.extend({
            _doFinalize: function () {
              return this._process(!0);
            },
            blockSize: 1
          });

          var b = p.mode = {},
              x = function (e, a, b) {
            var c = this._iv;
            c ? this._iv = u : c = this._prevBlock;

            for (var d = 0; d < b; d++) e[a + d] ^= c[d];
          },
              q = (d.BlockCipherMode = l.extend({
            createEncryptor: function (e, a) {
              return this.Encryptor.create(e, a);
            },
            createDecryptor: function (e, a) {
              return this.Decryptor.create(e, a);
            },
            init: function (e, a) {
              this._cipher = e;
              this._iv = a;
            }
          })).extend();

          q.Encryptor = q.extend({
            processBlock: function (e, a) {
              var b = this._cipher,
                  c = b.blockSize;
              x.call(this, e, a, c);
              b.encryptBlock(e, a);
              this._prevBlock = e.slice(a, a + c);
            }
          });
          q.Decryptor = q.extend({
            processBlock: function (e, a) {
              var b = this._cipher,
                  c = b.blockSize,
                  d = e.slice(a, a + c);
              b.decryptBlock(e, a);
              x.call(this, e, a, c);
              this._prevBlock = d;
            }
          });
          b = b.CBC = q;
          q = (p.pad = {}).Pkcs7 = {
            pad: function (a, b) {
              for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; n < c; n += 4) l.push(d);

              c = s.create(l, c);
              a.concat(c);
            },
            unpad: function (a) {
              a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255;
            }
          };
          d.BlockCipher = v.extend({
            cfg: v.cfg.extend({
              mode: b,
              padding: q
            }),
            reset: function () {
              v.reset.call(this);
              var a = this.cfg,
                  b = a.iv,
                  a = a.mode;
              if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;else c = a.createDecryptor, this._minBufferSize = 1;
              this._mode = c.call(a, this, b && b.words);
            },
            _doProcessBlock: function (a, b) {
              this._mode.processBlock(a, b);
            },
            _doFinalize: function () {
              var a = this.cfg.padding;

              if (this._xformMode == this._ENC_XFORM_MODE) {
                a.pad(this._data, this.blockSize);

                var b = this._process(!0);
              } else b = this._process(!0), a.unpad(b);

              return b;
            },
            blockSize: 4
          });
          var n = d.CipherParams = l.extend({
            init: function (a) {
              this.mixIn(a);
            },
            toString: function (a) {
              return (a || this.formatter).stringify(this);
            }
          }),
              b = (p.format = {}).OpenSSL = {
            stringify: function (a) {
              var b = a.ciphertext;
              a = a.salt;
              return (a ? s.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r);
            },
            parse: function (a) {
              a = r.parse(a);
              var b = a.words;

              if (1398893684 == b[0] && 1701076831 == b[1]) {
                var c = s.create(b.slice(2, 4));
                b.splice(0, 4);
                a.sigBytes -= 16;
              }

              return n.create({
                ciphertext: a,
                salt: c
              });
            }
          },
              a = d.SerializableCipher = l.extend({
            cfg: l.extend({
              format: b
            }),
            encrypt: function (a, b, c, d) {
              d = this.cfg.extend(d);
              var l = a.createEncryptor(c, d);
              b = l.finalize(b);
              l = l.cfg;
              return n.create({
                ciphertext: b,
                key: c,
                iv: l.iv,
                algorithm: a,
                mode: l.mode,
                padding: l.padding,
                blockSize: a.blockSize,
                formatter: d.format
              });
            },
            decrypt: function (a, b, c, d) {
              d = this.cfg.extend(d);
              b = this._parse(b, d.format);
              return a.createDecryptor(c, d).finalize(b.ciphertext);
            },
            _parse: function (a, b) {
              return "string" == typeof a ? b.parse(a, this) : a;
            }
          }),
              p = (p.kdf = {}).OpenSSL = {
            execute: function (a, b, c, d) {
              d || (d = s.random(8));
              a = w.create({
                keySize: b + c
              }).compute(a, d);
              c = s.create(a.words.slice(b), 4 * c);
              a.sigBytes = 4 * b;
              return n.create({
                key: a,
                iv: c,
                salt: d
              });
            }
          },
              c = d.PasswordBasedCipher = a.extend({
            cfg: a.cfg.extend({
              kdf: p
            }),
            encrypt: function (b, c, d, l) {
              l = this.cfg.extend(l);
              d = l.kdf.execute(d, b.keySize, b.ivSize);
              l.iv = d.iv;
              b = a.encrypt.call(this, b, c, d.key, l);
              b.mixIn(d);
              return b;
            },
            decrypt: function (b, c, d, l) {
              l = this.cfg.extend(l);
              c = this._parse(c, l.format);
              d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);
              l.iv = d.iv;
              return a.decrypt.call(this, b, c, d.key, l);
            }
          });
        }();

        (function () {
          for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++) a[c] = 128 > c ? c << 1 : c << 1 ^ 283;

          for (var e = 0, j = 0, c = 0; 256 > c; c++) {
            var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4,
                k = k >>> 8 ^ k & 255 ^ 99;
            l[e] = k;
            s[k] = e;
            var z = a[e],
                F = a[z],
                G = a[F],
                y = 257 * a[k] ^ 16843008 * k;
            t[e] = y << 24 | y >>> 8;
            r[e] = y << 16 | y >>> 16;
            w[e] = y << 8 | y >>> 24;
            v[e] = y;
            y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e;
            b[k] = y << 24 | y >>> 8;
            x[k] = y << 16 | y >>> 16;
            q[k] = y << 8 | y >>> 24;
            n[k] = y;
            e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1;
          }

          var H = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
              d = d.AES = p.extend({
            _doReset: function () {
              for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j < a; j++) if (j < d) e[j] = c[j];else {
                var k = e[j - 1];
                j % d ? 6 < d && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255]) : (k = k << 8 | k >>> 24, k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255], k ^= H[j / d | 0] << 24);
                e[j] = e[j - d] ^ k;
              }

              c = this._invKeySchedule = [];

              for (d = 0; d < a; d++) j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>> 8 & 255]] ^ n[l[k & 255]];
            },
            encryptBlock: function (a, b) {
              this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l);
            },
            decryptBlock: function (a, c) {
              var d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d;

              this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);

              d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d;
            },
            _doCryptBlock: function (a, b, c, d, e, j, l, f) {
              for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r < m; r++) var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[n & 255] ^ c[p++], s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[g & 255] ^ c[p++], t = d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[h & 255] ^ c[p++], n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[k & 255] ^ c[p++], g = q, h = s, k = t;

              q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[n & 255]) ^ c[p++];
              s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[g & 255]) ^ c[p++];
              t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[h & 255]) ^ c[p++];
              n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[k & 255]) ^ c[p++];
              a[b] = q;
              a[b + 1] = s;
              a[b + 2] = t;
              a[b + 3] = n;
            },
            keySize: 8
          });
          u.AES = p._createHelper(d);
        })();

        ;
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */

        var CryptoJS = CryptoJS || function (h, s) {
          var f = {},
              g = f.lib = {},
              q = function () {},
              m = g.Base = {
            extend: function (a) {
              q.prototype = this;
              var c = new q();
              a && c.mixIn(a);
              c.hasOwnProperty("init") || (c.init = function () {
                c.$super.init.apply(this, arguments);
              });
              c.init.prototype = c;
              c.$super = this;
              return c;
            },
            create: function () {
              var a = this.extend();
              a.init.apply(a, arguments);
              return a;
            },
            init: function () {},
            mixIn: function (a) {
              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);

              a.hasOwnProperty("toString") && (this.toString = a.toString);
            },
            clone: function () {
              return this.init.prototype.extend(this);
            }
          },
              r = g.WordArray = m.extend({
            init: function (a, c) {
              a = this.words = a || [];
              this.sigBytes = c != s ? c : 4 * a.length;
            },
            toString: function (a) {
              return (a || k).stringify(this);
            },
            concat: function (a) {
              var c = this.words,
                  d = a.words,
                  b = this.sigBytes;
              a = a.sigBytes;
              this.clamp();
              if (b % 4) for (var e = 0; e < a; e++) c[b + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((b + e) % 4);else if (65535 < d.length) for (e = 0; e < a; e += 4) c[b + e >>> 2] = d[e >>> 2];else c.push.apply(c, d);
              this.sigBytes += a;
              return this;
            },
            clamp: function () {
              var a = this.words,
                  c = this.sigBytes;
              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
              a.length = h.ceil(c / 4);
            },
            clone: function () {
              var a = m.clone.call(this);
              a.words = this.words.slice(0);
              return a;
            },
            random: function (a) {
              for (var c = [], d = 0; d < a; d += 4) c.push(4294967296 * h.random() | 0);

              return new r.init(c, a);
            }
          }),
              l = f.enc = {},
              k = l.Hex = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var d = [], b = 0; b < a; b++) {
                var e = c[b >>> 2] >>> 24 - 8 * (b % 4) & 255;
                d.push((e >>> 4).toString(16));
                d.push((e & 15).toString(16));
              }

              return d.join("");
            },
            parse: function (a) {
              for (var c = a.length, d = [], b = 0; b < c; b += 2) d[b >>> 3] |= parseInt(a.substr(b, 2), 16) << 24 - 4 * (b % 8);

              return new r.init(d, c / 2);
            }
          },
              n = l.Latin1 = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var d = [], b = 0; b < a; b++) d.push(String.fromCharCode(c[b >>> 2] >>> 24 - 8 * (b % 4) & 255));

              return d.join("");
            },
            parse: function (a) {
              for (var c = a.length, d = [], b = 0; b < c; b++) d[b >>> 2] |= (a.charCodeAt(b) & 255) << 24 - 8 * (b % 4);

              return new r.init(d, c);
            }
          },
              j = l.Utf8 = {
            stringify: function (a) {
              try {
                return decodeURIComponent(escape(n.stringify(a)));
              } catch (c) {
                throw Error("Malformed UTF-8 data");
              }
            },
            parse: function (a) {
              return n.parse(unescape(encodeURIComponent(a)));
            }
          },
              u = g.BufferedBlockAlgorithm = m.extend({
            reset: function () {
              this._data = new r.init();
              this._nDataBytes = 0;
            },
            _append: function (a) {
              "string" == typeof a && (a = j.parse(a));

              this._data.concat(a);

              this._nDataBytes += a.sigBytes;
            },
            _process: function (a) {
              var c = this._data,
                  d = c.words,
                  b = c.sigBytes,
                  e = this.blockSize,
                  f = b / (4 * e),
                  f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0);
              a = f * e;
              b = h.min(4 * a, b);

              if (a) {
                for (var g = 0; g < a; g += e) this._doProcessBlock(d, g);

                g = d.splice(0, a);
                c.sigBytes -= b;
              }

              return new r.init(g, b);
            },
            clone: function () {
              var a = m.clone.call(this);
              a._data = this._data.clone();
              return a;
            },
            _minBufferSize: 0
          });

          g.Hasher = u.extend({
            cfg: m.extend(),
            init: function (a) {
              this.cfg = this.cfg.extend(a);
              this.reset();
            },
            reset: function () {
              u.reset.call(this);

              this._doReset();
            },
            update: function (a) {
              this._append(a);

              this._process();

              return this;
            },
            finalize: function (a) {
              a && this._append(a);
              return this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function (a) {
              return function (c, d) {
                return new a.init(d).finalize(c);
              };
            },
            _createHmacHelper: function (a) {
              return function (c, d) {
                return new t.HMAC.init(a, d).finalize(c);
              };
            }
          });
          var t = f.algo = {};
          return f;
        }(Math);

        (function (h) {
          for (var s = CryptoJS, f = s.lib, g = f.WordArray, q = f.Hasher, f = s.algo, m = [], r = [], l = function (a) {
            return 4294967296 * (a - (a | 0)) | 0;
          }, k = 2, n = 0; 64 > n;) {
            var j;

            a: {
              j = k;

              for (var u = h.sqrt(j), t = 2; t <= u; t++) if (!(j % t)) {
                j = !1;
                break a;
              }

              j = !0;
            }

            j && (8 > n && (m[n] = l(h.pow(k, 0.5))), r[n] = l(h.pow(k, 1 / 3)), n++);
            k++;
          }

          var a = [],
              f = f.SHA256 = q.extend({
            _doReset: function () {
              this._hash = new g.init(m.slice(0));
            },
            _doProcessBlock: function (c, d) {
              for (var b = this._hash.words, e = b[0], f = b[1], g = b[2], j = b[3], h = b[4], m = b[5], n = b[6], q = b[7], p = 0; 64 > p; p++) {
                if (16 > p) a[p] = c[d + p] | 0;else {
                  var k = a[p - 15],
                      l = a[p - 2];
                  a[p] = ((k << 25 | k >>> 7) ^ (k << 14 | k >>> 18) ^ k >>> 3) + a[p - 7] + ((l << 15 | l >>> 17) ^ (l << 13 | l >>> 19) ^ l >>> 10) + a[p - 16];
                }
                k = q + ((h << 26 | h >>> 6) ^ (h << 21 | h >>> 11) ^ (h << 7 | h >>> 25)) + (h & m ^ ~h & n) + r[p] + a[p];
                l = ((e << 30 | e >>> 2) ^ (e << 19 | e >>> 13) ^ (e << 10 | e >>> 22)) + (e & f ^ e & g ^ f & g);
                q = n;
                n = m;
                m = h;
                h = j + k | 0;
                j = g;
                g = f;
                f = e;
                e = k + l | 0;
              }

              b[0] = b[0] + e | 0;
              b[1] = b[1] + f | 0;
              b[2] = b[2] + g | 0;
              b[3] = b[3] + j | 0;
              b[4] = b[4] + h | 0;
              b[5] = b[5] + m | 0;
              b[6] = b[6] + n | 0;
              b[7] = b[7] + q | 0;
            },
            _doFinalize: function () {
              var a = this._data,
                  d = a.words,
                  b = 8 * this._nDataBytes,
                  e = 8 * a.sigBytes;
              d[e >>> 5] |= 128 << 24 - e % 32;
              d[(e + 64 >>> 9 << 4) + 14] = h.floor(b / 4294967296);
              d[(e + 64 >>> 9 << 4) + 15] = b;
              a.sigBytes = 4 * d.length;

              this._process();

              return this._hash;
            },
            clone: function () {
              var a = q.clone.call(this);
              a._hash = this._hash.clone();
              return a;
            }
          });
          s.SHA256 = q._createHelper(f);
          s.HmacSHA256 = q._createHmacHelper(f);
        })(Math);

        (function () {
          var h = CryptoJS,
              s = h.enc.Utf8;
          h.algo.HMAC = h.lib.Base.extend({
            init: function (f, g) {
              f = this._hasher = new f.init();
              "string" == typeof g && (g = s.parse(g));
              var h = f.blockSize,
                  m = 4 * h;
              g.sigBytes > m && (g = f.finalize(g));
              g.clamp();

              for (var r = this._oKey = g.clone(), l = this._iKey = g.clone(), k = r.words, n = l.words, j = 0; j < h; j++) k[j] ^= 1549556828, n[j] ^= 909522486;

              r.sigBytes = l.sigBytes = m;
              this.reset();
            },
            reset: function () {
              var f = this._hasher;
              f.reset();
              f.update(this._iKey);
            },
            update: function (f) {
              this._hasher.update(f);

              return this;
            },
            finalize: function (f) {
              var g = this._hasher;
              f = g.finalize(f);
              g.reset();
              return g.finalize(this._oKey.clone().concat(f));
            }
          });
        })();

        ;
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */

        var CryptoJS = CryptoJS || function (a, j) {
          var c = {},
              b = c.lib = {},
              f = function () {},
              l = b.Base = {
            extend: function (a) {
              f.prototype = this;
              var d = new f();
              a && d.mixIn(a);
              d.hasOwnProperty("init") || (d.init = function () {
                d.$super.init.apply(this, arguments);
              });
              d.init.prototype = d;
              d.$super = this;
              return d;
            },
            create: function () {
              var a = this.extend();
              a.init.apply(a, arguments);
              return a;
            },
            init: function () {},
            mixIn: function (a) {
              for (var d in a) a.hasOwnProperty(d) && (this[d] = a[d]);

              a.hasOwnProperty("toString") && (this.toString = a.toString);
            },
            clone: function () {
              return this.init.prototype.extend(this);
            }
          },
              u = b.WordArray = l.extend({
            init: function (a, d) {
              a = this.words = a || [];
              this.sigBytes = d != j ? d : 4 * a.length;
            },
            toString: function (a) {
              return (a || m).stringify(this);
            },
            concat: function (a) {
              var d = this.words,
                  M = a.words,
                  e = this.sigBytes;
              a = a.sigBytes;
              this.clamp();
              if (e % 4) for (var b = 0; b < a; b++) d[e + b >>> 2] |= (M[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((e + b) % 4);else if (65535 < M.length) for (b = 0; b < a; b += 4) d[e + b >>> 2] = M[b >>> 2];else d.push.apply(d, M);
              this.sigBytes += a;
              return this;
            },
            clamp: function () {
              var D = this.words,
                  d = this.sigBytes;
              D[d >>> 2] &= 4294967295 << 32 - 8 * (d % 4);
              D.length = a.ceil(d / 4);
            },
            clone: function () {
              var a = l.clone.call(this);
              a.words = this.words.slice(0);
              return a;
            },
            random: function (D) {
              for (var d = [], b = 0; b < D; b += 4) d.push(4294967296 * a.random() | 0);

              return new u.init(d, D);
            }
          }),
              k = c.enc = {},
              m = k.Hex = {
            stringify: function (a) {
              var d = a.words;
              a = a.sigBytes;

              for (var b = [], e = 0; e < a; e++) {
                var c = d[e >>> 2] >>> 24 - 8 * (e % 4) & 255;
                b.push((c >>> 4).toString(16));
                b.push((c & 15).toString(16));
              }

              return b.join("");
            },
            parse: function (a) {
              for (var d = a.length, b = [], e = 0; e < d; e += 2) b[e >>> 3] |= parseInt(a.substr(e, 2), 16) << 24 - 4 * (e % 8);

              return new u.init(b, d / 2);
            }
          },
              y = k.Latin1 = {
            stringify: function (a) {
              var b = a.words;
              a = a.sigBytes;

              for (var c = [], e = 0; e < a; e++) c.push(String.fromCharCode(b[e >>> 2] >>> 24 - 8 * (e % 4) & 255));

              return c.join("");
            },
            parse: function (a) {
              for (var b = a.length, c = [], e = 0; e < b; e++) c[e >>> 2] |= (a.charCodeAt(e) & 255) << 24 - 8 * (e % 4);

              return new u.init(c, b);
            }
          },
              z = k.Utf8 = {
            stringify: function (a) {
              try {
                return decodeURIComponent(escape(y.stringify(a)));
              } catch (b) {
                throw Error("Malformed UTF-8 data");
              }
            },
            parse: function (a) {
              return y.parse(unescape(encodeURIComponent(a)));
            }
          },
              x = b.BufferedBlockAlgorithm = l.extend({
            reset: function () {
              this._data = new u.init();
              this._nDataBytes = 0;
            },
            _append: function (a) {
              "string" == typeof a && (a = z.parse(a));

              this._data.concat(a);

              this._nDataBytes += a.sigBytes;
            },
            _process: function (b) {
              var d = this._data,
                  c = d.words,
                  e = d.sigBytes,
                  l = this.blockSize,
                  k = e / (4 * l),
                  k = b ? a.ceil(k) : a.max((k | 0) - this._minBufferSize, 0);
              b = k * l;
              e = a.min(4 * b, e);

              if (b) {
                for (var x = 0; x < b; x += l) this._doProcessBlock(c, x);

                x = c.splice(0, b);
                d.sigBytes -= e;
              }

              return new u.init(x, e);
            },
            clone: function () {
              var a = l.clone.call(this);
              a._data = this._data.clone();
              return a;
            },
            _minBufferSize: 0
          });

          b.Hasher = x.extend({
            cfg: l.extend(),
            init: function (a) {
              this.cfg = this.cfg.extend(a);
              this.reset();
            },
            reset: function () {
              x.reset.call(this);

              this._doReset();
            },
            update: function (a) {
              this._append(a);

              this._process();

              return this;
            },
            finalize: function (a) {
              a && this._append(a);
              return this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function (a) {
              return function (b, c) {
                return new a.init(c).finalize(b);
              };
            },
            _createHmacHelper: function (a) {
              return function (b, c) {
                return new ja.HMAC.init(a, c).finalize(b);
              };
            }
          });
          var ja = c.algo = {};
          return c;
        }(Math);

        (function (a) {
          var j = CryptoJS,
              c = j.lib,
              b = c.Base,
              f = c.WordArray,
              j = j.x64 = {};
          j.Word = b.extend({
            init: function (a, b) {
              this.high = a;
              this.low = b;
            }
          });
          j.WordArray = b.extend({
            init: function (b, c) {
              b = this.words = b || [];
              this.sigBytes = c != a ? c : 8 * b.length;
            },
            toX32: function () {
              for (var a = this.words, b = a.length, c = [], m = 0; m < b; m++) {
                var y = a[m];
                c.push(y.high);
                c.push(y.low);
              }

              return f.create(c, this.sigBytes);
            },
            clone: function () {
              for (var a = b.clone.call(this), c = a.words = this.words.slice(0), k = c.length, f = 0; f < k; f++) c[f] = c[f].clone();

              return a;
            }
          });
        })();

        (function () {
          function a() {
            return f.create.apply(f, arguments);
          }

          for (var j = CryptoJS, c = j.lib.Hasher, b = j.x64, f = b.Word, l = b.WordArray, b = j.algo, u = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317), a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291, 2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899), a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470, 3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)], k = [], m = 0; 80 > m; m++) k[m] = a();

          b = b.SHA512 = c.extend({
            _doReset: function () {
              this._hash = new l.init([new f.init(1779033703, 4089235720), new f.init(3144134277, 2227873595), new f.init(1013904242, 4271175723), new f.init(2773480762, 1595750129), new f.init(1359893119, 2917565137), new f.init(2600822924, 725511199), new f.init(528734635, 4215389547), new f.init(1541459225, 327033209)]);
            },
            _doProcessBlock: function (a, b) {
              for (var c = this._hash.words, f = c[0], j = c[1], d = c[2], l = c[3], e = c[4], m = c[5], N = c[6], c = c[7], aa = f.high, O = f.low, ba = j.high, P = j.low, ca = d.high, Q = d.low, da = l.high, R = l.low, ea = e.high, S = e.low, fa = m.high, T = m.low, ga = N.high, U = N.low, ha = c.high, V = c.low, r = aa, n = O, G = ba, E = P, H = ca, F = Q, Y = da, I = R, s = ea, p = S, W = fa, J = T, X = ga, K = U, Z = ha, L = V, t = 0; 80 > t; t++) {
                var A = k[t];
                if (16 > t) var q = A.high = a[b + 2 * t] | 0,
                    g = A.low = a[b + 2 * t + 1] | 0;else {
                  var q = k[t - 15],
                      g = q.high,
                      v = q.low,
                      q = (g >>> 1 | v << 31) ^ (g >>> 8 | v << 24) ^ g >>> 7,
                      v = (v >>> 1 | g << 31) ^ (v >>> 8 | g << 24) ^ (v >>> 7 | g << 25),
                      C = k[t - 2],
                      g = C.high,
                      h = C.low,
                      C = (g >>> 19 | h << 13) ^ (g << 3 | h >>> 29) ^ g >>> 6,
                      h = (h >>> 19 | g << 13) ^ (h << 3 | g >>> 29) ^ (h >>> 6 | g << 26),
                      g = k[t - 7],
                      $ = g.high,
                      B = k[t - 16],
                      w = B.high,
                      B = B.low,
                      g = v + g.low,
                      q = q + $ + (g >>> 0 < v >>> 0 ? 1 : 0),
                      g = g + h,
                      q = q + C + (g >>> 0 < h >>> 0 ? 1 : 0),
                      g = g + B,
                      q = q + w + (g >>> 0 < B >>> 0 ? 1 : 0);
                  A.high = q;
                  A.low = g;
                }
                var $ = s & W ^ ~s & X,
                    B = p & J ^ ~p & K,
                    A = r & G ^ r & H ^ G & H,
                    ka = n & E ^ n & F ^ E & F,
                    v = (r >>> 28 | n << 4) ^ (r << 30 | n >>> 2) ^ (r << 25 | n >>> 7),
                    C = (n >>> 28 | r << 4) ^ (n << 30 | r >>> 2) ^ (n << 25 | r >>> 7),
                    h = u[t],
                    la = h.high,
                    ia = h.low,
                    h = L + ((p >>> 14 | s << 18) ^ (p >>> 18 | s << 14) ^ (p << 23 | s >>> 9)),
                    w = Z + ((s >>> 14 | p << 18) ^ (s >>> 18 | p << 14) ^ (s << 23 | p >>> 9)) + (h >>> 0 < L >>> 0 ? 1 : 0),
                    h = h + B,
                    w = w + $ + (h >>> 0 < B >>> 0 ? 1 : 0),
                    h = h + ia,
                    w = w + la + (h >>> 0 < ia >>> 0 ? 1 : 0),
                    h = h + g,
                    w = w + q + (h >>> 0 < g >>> 0 ? 1 : 0),
                    g = C + ka,
                    A = v + A + (g >>> 0 < C >>> 0 ? 1 : 0),
                    Z = X,
                    L = K,
                    X = W,
                    K = J,
                    W = s,
                    J = p,
                    p = I + h | 0,
                    s = Y + w + (p >>> 0 < I >>> 0 ? 1 : 0) | 0,
                    Y = H,
                    I = F,
                    H = G,
                    F = E,
                    G = r,
                    E = n,
                    n = h + g | 0,
                    r = w + A + (n >>> 0 < h >>> 0 ? 1 : 0) | 0;
              }

              O = f.low = O + n;
              f.high = aa + r + (O >>> 0 < n >>> 0 ? 1 : 0);
              P = j.low = P + E;
              j.high = ba + G + (P >>> 0 < E >>> 0 ? 1 : 0);
              Q = d.low = Q + F;
              d.high = ca + H + (Q >>> 0 < F >>> 0 ? 1 : 0);
              R = l.low = R + I;
              l.high = da + Y + (R >>> 0 < I >>> 0 ? 1 : 0);
              S = e.low = S + p;
              e.high = ea + s + (S >>> 0 < p >>> 0 ? 1 : 0);
              T = m.low = T + J;
              m.high = fa + W + (T >>> 0 < J >>> 0 ? 1 : 0);
              U = N.low = U + K;
              N.high = ga + X + (U >>> 0 < K >>> 0 ? 1 : 0);
              V = c.low = V + L;
              c.high = ha + Z + (V >>> 0 < L >>> 0 ? 1 : 0);
            },
            _doFinalize: function () {
              var a = this._data,
                  b = a.words,
                  c = 8 * this._nDataBytes,
                  f = 8 * a.sigBytes;
              b[f >>> 5] |= 128 << 24 - f % 32;
              b[(f + 128 >>> 10 << 5) + 30] = Math.floor(c / 4294967296);
              b[(f + 128 >>> 10 << 5) + 31] = c;
              a.sigBytes = 4 * b.length;

              this._process();

              return this._hash.toX32();
            },
            clone: function () {
              var a = c.clone.call(this);
              a._hash = this._hash.clone();
              return a;
            },
            blockSize: 32
          });
          j.SHA512 = c._createHelper(b);
          j.HmacSHA512 = c._createHmacHelper(b);
        })();

        (function () {
          var a = CryptoJS,
              j = a.enc.Utf8;
          a.algo.HMAC = a.lib.Base.extend({
            init: function (a, b) {
              a = this._hasher = new a.init();
              "string" == typeof b && (b = j.parse(b));
              var f = a.blockSize,
                  l = 4 * f;
              b.sigBytes > l && (b = a.finalize(b));
              b.clamp();

              for (var u = this._oKey = b.clone(), k = this._iKey = b.clone(), m = u.words, y = k.words, z = 0; z < f; z++) m[z] ^= 1549556828, y[z] ^= 909522486;

              u.sigBytes = k.sigBytes = l;
              this.reset();
            },
            reset: function () {
              var a = this._hasher;
              a.reset();
              a.update(this._iKey);
            },
            update: function (a) {
              this._hasher.update(a);

              return this;
            },
            finalize: function (a) {
              var b = this._hasher;
              a = b.finalize(a);
              b.reset();
              return b.finalize(this._oKey.clone().concat(a));
            }
          });
        })();

        ;
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */

        var CryptoJS = CryptoJS || function (g, j) {
          var e = {},
              d = e.lib = {},
              m = function () {},
              n = d.Base = {
            extend: function (a) {
              m.prototype = this;
              var c = new m();
              a && c.mixIn(a);
              c.hasOwnProperty("init") || (c.init = function () {
                c.$super.init.apply(this, arguments);
              });
              c.init.prototype = c;
              c.$super = this;
              return c;
            },
            create: function () {
              var a = this.extend();
              a.init.apply(a, arguments);
              return a;
            },
            init: function () {},
            mixIn: function (a) {
              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);

              a.hasOwnProperty("toString") && (this.toString = a.toString);
            },
            clone: function () {
              return this.init.prototype.extend(this);
            }
          },
              q = d.WordArray = n.extend({
            init: function (a, c) {
              a = this.words = a || [];
              this.sigBytes = c != j ? c : 4 * a.length;
            },
            toString: function (a) {
              return (a || l).stringify(this);
            },
            concat: function (a) {
              var c = this.words,
                  p = a.words,
                  f = this.sigBytes;
              a = a.sigBytes;
              this.clamp();
              if (f % 4) for (var b = 0; b < a; b++) c[f + b >>> 2] |= (p[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((f + b) % 4);else if (65535 < p.length) for (b = 0; b < a; b += 4) c[f + b >>> 2] = p[b >>> 2];else c.push.apply(c, p);
              this.sigBytes += a;
              return this;
            },
            clamp: function () {
              var a = this.words,
                  c = this.sigBytes;
              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
              a.length = g.ceil(c / 4);
            },
            clone: function () {
              var a = n.clone.call(this);
              a.words = this.words.slice(0);
              return a;
            },
            random: function (a) {
              for (var c = [], b = 0; b < a; b += 4) c.push(4294967296 * g.random() | 0);

              return new q.init(c, a);
            }
          }),
              b = e.enc = {},
              l = b.Hex = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var b = [], f = 0; f < a; f++) {
                var d = c[f >>> 2] >>> 24 - 8 * (f % 4) & 255;
                b.push((d >>> 4).toString(16));
                b.push((d & 15).toString(16));
              }

              return b.join("");
            },
            parse: function (a) {
              for (var c = a.length, b = [], f = 0; f < c; f += 2) b[f >>> 3] |= parseInt(a.substr(f, 2), 16) << 24 - 4 * (f % 8);

              return new q.init(b, c / 2);
            }
          },
              k = b.Latin1 = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var b = [], f = 0; f < a; f++) b.push(String.fromCharCode(c[f >>> 2] >>> 24 - 8 * (f % 4) & 255));

              return b.join("");
            },
            parse: function (a) {
              for (var c = a.length, b = [], f = 0; f < c; f++) b[f >>> 2] |= (a.charCodeAt(f) & 255) << 24 - 8 * (f % 4);

              return new q.init(b, c);
            }
          },
              h = b.Utf8 = {
            stringify: function (a) {
              try {
                return decodeURIComponent(escape(k.stringify(a)));
              } catch (b) {
                throw Error("Malformed UTF-8 data");
              }
            },
            parse: function (a) {
              return k.parse(unescape(encodeURIComponent(a)));
            }
          },
              u = d.BufferedBlockAlgorithm = n.extend({
            reset: function () {
              this._data = new q.init();
              this._nDataBytes = 0;
            },
            _append: function (a) {
              "string" == typeof a && (a = h.parse(a));

              this._data.concat(a);

              this._nDataBytes += a.sigBytes;
            },
            _process: function (a) {
              var b = this._data,
                  d = b.words,
                  f = b.sigBytes,
                  l = this.blockSize,
                  e = f / (4 * l),
                  e = a ? g.ceil(e) : g.max((e | 0) - this._minBufferSize, 0);
              a = e * l;
              f = g.min(4 * a, f);

              if (a) {
                for (var h = 0; h < a; h += l) this._doProcessBlock(d, h);

                h = d.splice(0, a);
                b.sigBytes -= f;
              }

              return new q.init(h, f);
            },
            clone: function () {
              var a = n.clone.call(this);
              a._data = this._data.clone();
              return a;
            },
            _minBufferSize: 0
          });

          d.Hasher = u.extend({
            cfg: n.extend(),
            init: function (a) {
              this.cfg = this.cfg.extend(a);
              this.reset();
            },
            reset: function () {
              u.reset.call(this);

              this._doReset();
            },
            update: function (a) {
              this._append(a);

              this._process();

              return this;
            },
            finalize: function (a) {
              a && this._append(a);
              return this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function (a) {
              return function (b, d) {
                return new a.init(d).finalize(b);
              };
            },
            _createHmacHelper: function (a) {
              return function (b, d) {
                return new w.HMAC.init(a, d).finalize(b);
              };
            }
          });
          var w = e.algo = {};
          return e;
        }(Math);

        (function () {
          var g = CryptoJS,
              j = g.lib,
              e = j.WordArray,
              d = j.Hasher,
              m = [],
              j = g.algo.SHA1 = d.extend({
            _doReset: function () {
              this._hash = new e.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            },
            _doProcessBlock: function (d, e) {
              for (var b = this._hash.words, l = b[0], k = b[1], h = b[2], g = b[3], j = b[4], a = 0; 80 > a; a++) {
                if (16 > a) m[a] = d[e + a] | 0;else {
                  var c = m[a - 3] ^ m[a - 8] ^ m[a - 14] ^ m[a - 16];
                  m[a] = c << 1 | c >>> 31;
                }
                c = (l << 5 | l >>> 27) + j + m[a];
                c = 20 > a ? c + ((k & h | ~k & g) + 1518500249) : 40 > a ? c + ((k ^ h ^ g) + 1859775393) : 60 > a ? c + ((k & h | k & g | h & g) - 1894007588) : c + ((k ^ h ^ g) - 899497514);
                j = g;
                g = h;
                h = k << 30 | k >>> 2;
                k = l;
                l = c;
              }

              b[0] = b[0] + l | 0;
              b[1] = b[1] + k | 0;
              b[2] = b[2] + h | 0;
              b[3] = b[3] + g | 0;
              b[4] = b[4] + j | 0;
            },
            _doFinalize: function () {
              var d = this._data,
                  e = d.words,
                  b = 8 * this._nDataBytes,
                  l = 8 * d.sigBytes;
              e[l >>> 5] |= 128 << 24 - l % 32;
              e[(l + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);
              e[(l + 64 >>> 9 << 4) + 15] = b;
              d.sigBytes = 4 * e.length;

              this._process();

              return this._hash;
            },
            clone: function () {
              var e = d.clone.call(this);
              e._hash = this._hash.clone();
              return e;
            }
          });
          g.SHA1 = d._createHelper(j);
          g.HmacSHA1 = d._createHmacHelper(j);
        })();

        (function () {
          var g = CryptoJS,
              j = g.enc.Utf8;
          g.algo.HMAC = g.lib.Base.extend({
            init: function (e, d) {
              e = this._hasher = new e.init();
              "string" == typeof d && (d = j.parse(d));
              var g = e.blockSize,
                  n = 4 * g;
              d.sigBytes > n && (d = e.finalize(d));
              d.clamp();

              for (var q = this._oKey = d.clone(), b = this._iKey = d.clone(), l = q.words, k = b.words, h = 0; h < g; h++) l[h] ^= 1549556828, k[h] ^= 909522486;

              q.sigBytes = b.sigBytes = n;
              this.reset();
            },
            reset: function () {
              var e = this._hasher;
              e.reset();
              e.update(this._iKey);
            },
            update: function (e) {
              this._hasher.update(e);

              return this;
            },
            finalize: function (e) {
              var d = this._hasher;
              e = d.finalize(e);
              d.reset();
              return d.finalize(this._oKey.clone().concat(e));
            }
          });
        })();

        (function () {
          var g = CryptoJS,
              j = g.lib,
              e = j.Base,
              d = j.WordArray,
              j = g.algo,
              m = j.HMAC,
              n = j.PBKDF2 = e.extend({
            cfg: e.extend({
              keySize: 4,
              hasher: j.SHA1,
              iterations: 1
            }),
            init: function (d) {
              this.cfg = this.cfg.extend(d);
            },
            compute: function (e, b) {
              for (var g = this.cfg, k = m.create(g.hasher, e), h = d.create(), j = d.create([1]), n = h.words, a = j.words, c = g.keySize, g = g.iterations; n.length < c;) {
                var p = k.update(b).finalize(j);
                k.reset();

                for (var f = p.words, v = f.length, s = p, t = 1; t < g; t++) {
                  s = k.finalize(s);
                  k.reset();

                  for (var x = s.words, r = 0; r < v; r++) f[r] ^= x[r];
                }

                h.concat(p);
                a[0]++;
              }

              h.sigBytes = 4 * c;
              return h;
            }
          });

          g.PBKDF2 = function (d, b, e) {
            return n.create(e).compute(d, b);
          };
        })();

        ;
        /*
        CryptoJS v3.1.2
        code.google.com/p/crypto-js
        (c) 2009-2013 by Jeff Mott. All rights reserved.
        code.google.com/p/crypto-js/wiki/License
        */

        var CryptoJS = CryptoJS || function (e, m) {
          var p = {},
              j = p.lib = {},
              l = function () {},
              f = j.Base = {
            extend: function (a) {
              l.prototype = this;
              var c = new l();
              a && c.mixIn(a);
              c.hasOwnProperty("init") || (c.init = function () {
                c.$super.init.apply(this, arguments);
              });
              c.init.prototype = c;
              c.$super = this;
              return c;
            },
            create: function () {
              var a = this.extend();
              a.init.apply(a, arguments);
              return a;
            },
            init: function () {},
            mixIn: function (a) {
              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);

              a.hasOwnProperty("toString") && (this.toString = a.toString);
            },
            clone: function () {
              return this.init.prototype.extend(this);
            }
          },
              n = j.WordArray = f.extend({
            init: function (a, c) {
              a = this.words = a || [];
              this.sigBytes = c != m ? c : 4 * a.length;
            },
            toString: function (a) {
              return (a || h).stringify(this);
            },
            concat: function (a) {
              var c = this.words,
                  q = a.words,
                  d = this.sigBytes;
              a = a.sigBytes;
              this.clamp();
              if (d % 4) for (var b = 0; b < a; b++) c[d + b >>> 2] |= (q[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((d + b) % 4);else if (65535 < q.length) for (b = 0; b < a; b += 4) c[d + b >>> 2] = q[b >>> 2];else c.push.apply(c, q);
              this.sigBytes += a;
              return this;
            },
            clamp: function () {
              var a = this.words,
                  c = this.sigBytes;
              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
              a.length = e.ceil(c / 4);
            },
            clone: function () {
              var a = f.clone.call(this);
              a.words = this.words.slice(0);
              return a;
            },
            random: function (a) {
              for (var c = [], b = 0; b < a; b += 4) c.push(4294967296 * e.random() | 0);

              return new n.init(c, a);
            }
          }),
              b = p.enc = {},
              h = b.Hex = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var b = [], d = 0; d < a; d++) {
                var f = c[d >>> 2] >>> 24 - 8 * (d % 4) & 255;
                b.push((f >>> 4).toString(16));
                b.push((f & 15).toString(16));
              }

              return b.join("");
            },
            parse: function (a) {
              for (var c = a.length, b = [], d = 0; d < c; d += 2) b[d >>> 3] |= parseInt(a.substr(d, 2), 16) << 24 - 4 * (d % 8);

              return new n.init(b, c / 2);
            }
          },
              g = b.Latin1 = {
            stringify: function (a) {
              var c = a.words;
              a = a.sigBytes;

              for (var b = [], d = 0; d < a; d++) b.push(String.fromCharCode(c[d >>> 2] >>> 24 - 8 * (d % 4) & 255));

              return b.join("");
            },
            parse: function (a) {
              for (var c = a.length, b = [], d = 0; d < c; d++) b[d >>> 2] |= (a.charCodeAt(d) & 255) << 24 - 8 * (d % 4);

              return new n.init(b, c);
            }
          },
              r = b.Utf8 = {
            stringify: function (a) {
              try {
                return decodeURIComponent(escape(g.stringify(a)));
              } catch (c) {
                throw Error("Malformed UTF-8 data");
              }
            },
            parse: function (a) {
              return g.parse(unescape(encodeURIComponent(a)));
            }
          },
              k = j.BufferedBlockAlgorithm = f.extend({
            reset: function () {
              this._data = new n.init();
              this._nDataBytes = 0;
            },
            _append: function (a) {
              "string" == typeof a && (a = r.parse(a));

              this._data.concat(a);

              this._nDataBytes += a.sigBytes;
            },
            _process: function (a) {
              var c = this._data,
                  b = c.words,
                  d = c.sigBytes,
                  f = this.blockSize,
                  h = d / (4 * f),
                  h = a ? e.ceil(h) : e.max((h | 0) - this._minBufferSize, 0);
              a = h * f;
              d = e.min(4 * a, d);

              if (a) {
                for (var g = 0; g < a; g += f) this._doProcessBlock(b, g);

                g = b.splice(0, a);
                c.sigBytes -= d;
              }

              return new n.init(g, d);
            },
            clone: function () {
              var a = f.clone.call(this);
              a._data = this._data.clone();
              return a;
            },
            _minBufferSize: 0
          });

          j.Hasher = k.extend({
            cfg: f.extend(),
            init: function (a) {
              this.cfg = this.cfg.extend(a);
              this.reset();
            },
            reset: function () {
              k.reset.call(this);

              this._doReset();
            },
            update: function (a) {
              this._append(a);

              this._process();

              return this;
            },
            finalize: function (a) {
              a && this._append(a);
              return this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function (a) {
              return function (c, b) {
                return new a.init(b).finalize(c);
              };
            },
            _createHmacHelper: function (a) {
              return function (b, f) {
                return new s.HMAC.init(a, f).finalize(b);
              };
            }
          });
          var s = p.algo = {};
          return p;
        }(Math);

        (function () {
          var e = CryptoJS,
              m = e.lib,
              p = m.WordArray,
              j = m.Hasher,
              l = [],
              m = e.algo.SHA1 = j.extend({
            _doReset: function () {
              this._hash = new p.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            },
            _doProcessBlock: function (f, n) {
              for (var b = this._hash.words, h = b[0], g = b[1], e = b[2], k = b[3], j = b[4], a = 0; 80 > a; a++) {
                if (16 > a) l[a] = f[n + a] | 0;else {
                  var c = l[a - 3] ^ l[a - 8] ^ l[a - 14] ^ l[a - 16];
                  l[a] = c << 1 | c >>> 31;
                }
                c = (h << 5 | h >>> 27) + j + l[a];
                c = 20 > a ? c + ((g & e | ~g & k) + 1518500249) : 40 > a ? c + ((g ^ e ^ k) + 1859775393) : 60 > a ? c + ((g & e | g & k | e & k) - 1894007588) : c + ((g ^ e ^ k) - 899497514);
                j = k;
                k = e;
                e = g << 30 | g >>> 2;
                g = h;
                h = c;
              }

              b[0] = b[0] + h | 0;
              b[1] = b[1] + g | 0;
              b[2] = b[2] + e | 0;
              b[3] = b[3] + k | 0;
              b[4] = b[4] + j | 0;
            },
            _doFinalize: function () {
              var f = this._data,
                  e = f.words,
                  b = 8 * this._nDataBytes,
                  h = 8 * f.sigBytes;
              e[h >>> 5] |= 128 << 24 - h % 32;
              e[(h + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);
              e[(h + 64 >>> 9 << 4) + 15] = b;
              f.sigBytes = 4 * e.length;

              this._process();

              return this._hash;
            },
            clone: function () {
              var e = j.clone.call(this);
              e._hash = this._hash.clone();
              return e;
            }
          });
          e.SHA1 = j._createHelper(m);
          e.HmacSHA1 = j._createHmacHelper(m);
        })();

        ;
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);

                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }

            return _arr;
          }

          return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
          return typeof obj;
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }

          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        function _asyncToGenerator(fn) {
          return function () {
            var gen = fn.apply(this, arguments);
            return new Promise(function (resolve, reject) {
              function step(key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }

                if (info.done) {
                  resolve(value);
                } else {
                  return Promise.resolve(value).then(function (value) {
                    step("next", value);
                  }, function (err) {
                    step("throw", err);
                  });
                }
              }

              return step("next");
            });
          };
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        var SFAlertManager = exports.SFAlertManager = function () {
          function SFAlertManager() {
            _classCallCheck(this, SFAlertManager);
          }

          _createClass(SFAlertManager, [{
            key: "alert",
            value: function () {
              var _ref = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee(params) {
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        return _context.abrupt("return", new Promise(function (resolve, reject) {
                          window.alert(params.text);
                          resolve();
                        }));

                      case 1:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));

              function alert(_x) {
                return _ref.apply(this, arguments);
              }

              return alert;
            }()
          }, {
            key: "confirm",
            value: function () {
              var _ref2 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee2(params) {
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        return _context2.abrupt("return", new Promise(function (resolve, reject) {
                          if (window.confirm(params.text)) {
                            resolve();
                          } else {
                            reject();
                          }
                        }));

                      case 1:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, this);
              }));

              function confirm(_x2) {
                return _ref2.apply(this, arguments);
              }

              return confirm;
            }()
          }]);

          return SFAlertManager;
        }();

        ;

        var SFAuthManager = exports.SFAuthManager = function () {
          function SFAuthManager(storageManager, httpManager, alertManager, timeout) {
            _classCallCheck(this, SFAuthManager);

            SFAuthManager.DidSignOutEvent = "DidSignOutEvent";
            SFAuthManager.WillSignInEvent = "WillSignInEvent";
            SFAuthManager.DidSignInEvent = "DidSignInEvent";
            this.httpManager = httpManager;
            this.storageManager = storageManager;
            this.alertManager = alertManager || new SFAlertManager();
            this.$timeout = timeout || setTimeout.bind(window);
            this.eventHandlers = [];
          }

          _createClass(SFAuthManager, [{
            key: "addEventHandler",
            value: function addEventHandler(handler) {
              this.eventHandlers.push(handler);
              return handler;
            }
          }, {
            key: "removeEventHandler",
            value: function removeEventHandler(handler) {
              _.pull(this.eventHandlers, handler);
            }
          }, {
            key: "notifyEvent",
            value: function notifyEvent(event, data) {
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = this.eventHandlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var handler = _step.value;
                  handler(event, data || {});
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            }
          }, {
            key: "saveKeys",
            value: function () {
              var _ref3 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee3(keys) {
                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        this._keys = keys;
                        _context3.next = 3;
                        return this.storageManager.setItem("mk", keys.mk);

                      case 3:
                        _context3.next = 5;
                        return this.storageManager.setItem("ak", keys.ak);

                      case 5:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3, this);
              }));

              function saveKeys(_x3) {
                return _ref3.apply(this, arguments);
              }

              return saveKeys;
            }()
          }, {
            key: "signout",
            value: function () {
              var _ref4 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee4(clearAllData) {
                var _this = this;

                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        this._keys = null;
                        this._authParams = null;

                        if (!clearAllData) {
                          _context4.next = 6;
                          break;
                        }

                        return _context4.abrupt("return", this.storageManager.clearAllData().then(function () {
                          _this.notifyEvent(SFAuthManager.DidSignOutEvent);
                        }));

                      case 6:
                        this.notifyEvent(SFAuthManager.DidSignOutEvent);

                      case 7:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4, this);
              }));

              function signout(_x4) {
                return _ref4.apply(this, arguments);
              }

              return signout;
            }()
          }, {
            key: "keys",
            value: function () {
              var _ref5 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee5() {
                var mk;
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (this._keys) {
                          _context5.next = 11;
                          break;
                        }

                        _context5.next = 3;
                        return this.storageManager.getItem("mk");

                      case 3:
                        mk = _context5.sent;

                        if (mk) {
                          _context5.next = 6;
                          break;
                        }

                        return _context5.abrupt("return", null);

                      case 6:
                        _context5.t0 = mk;
                        _context5.next = 9;
                        return this.storageManager.getItem("ak");

                      case 9:
                        _context5.t1 = _context5.sent;
                        this._keys = {
                          mk: _context5.t0,
                          ak: _context5.t1
                        };

                      case 11:
                        return _context5.abrupt("return", this._keys);

                      case 12:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5, this);
              }));

              function keys() {
                return _ref5.apply(this, arguments);
              }

              return keys;
            }()
          }, {
            key: "getAuthParams",
            value: function () {
              var _ref6 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee6() {
                var data;
                return regeneratorRuntime.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        if (this._authParams) {
                          _context6.next = 5;
                          break;
                        }

                        _context6.next = 3;
                        return this.storageManager.getItem("auth_params");

                      case 3:
                        data = _context6.sent;
                        this._authParams = JSON.parse(data);

                      case 5:
                        if (!(this._authParams && !this._authParams.version)) {
                          _context6.next = 9;
                          break;
                        }

                        _context6.next = 8;
                        return this.defaultProtocolVersion();

                      case 8:
                        this._authParams.version = _context6.sent;

                      case 9:
                        return _context6.abrupt("return", this._authParams);

                      case 10:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6, this);
              }));

              function getAuthParams() {
                return _ref6.apply(this, arguments);
              }

              return getAuthParams;
            }()
          }, {
            key: "defaultProtocolVersion",
            value: function () {
              var _ref7 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee7() {
                var keys;
                return regeneratorRuntime.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        _context7.next = 2;
                        return this.keys();

                      case 2:
                        keys = _context7.sent;

                        if (!(keys && keys.ak)) {
                          _context7.next = 7;
                          break;
                        }

                        return _context7.abrupt("return", "002");

                      case 7:
                        return _context7.abrupt("return", "001");

                      case 8:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7, this);
              }));

              function defaultProtocolVersion() {
                return _ref7.apply(this, arguments);
              }

              return defaultProtocolVersion;
            }()
          }, {
            key: "protocolVersion",
            value: function () {
              var _ref8 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee8() {
                var authParams;
                return regeneratorRuntime.wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        _context8.next = 2;
                        return this.getAuthParams();

                      case 2:
                        authParams = _context8.sent;

                        if (!(authParams && authParams.version)) {
                          _context8.next = 5;
                          break;
                        }

                        return _context8.abrupt("return", authParams.version);

                      case 5:
                        return _context8.abrupt("return", this.defaultProtocolVersion());

                      case 6:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8, this);
              }));

              function protocolVersion() {
                return _ref8.apply(this, arguments);
              }

              return protocolVersion;
            }()
          }, {
            key: "getAuthParamsForEmail",
            value: function () {
              var _ref9 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee9(url, email, extraParams) {
                var _this2 = this;

                return regeneratorRuntime.wrap(function _callee9$(_context9) {
                  while (1) {
                    switch (_context9.prev = _context9.next) {
                      case 0:
                        return _context9.abrupt("return", new Promise(function (resolve, reject) {
                          var requestUrl = url + "/auth/params";

                          _this2.httpManager.getAbsolute(requestUrl, _.merge({
                            email: email
                          }, extraParams), function (response) {
                            resolve(response);
                          }, function (response) {
                            console.error("Error getting auth params", response);

                            if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                              response = {
                                error: {
                                  message: "A server error occurred while trying to sign in. Please try again."
                                }
                              };
                            }

                            resolve(response);
                          });
                        }));

                      case 1:
                      case "end":
                        return _context9.stop();
                    }
                  }
                }, _callee9, this);
              }));

              function getAuthParamsForEmail(_x5, _x6, _x7) {
                return _ref9.apply(this, arguments);
              }

              return getAuthParamsForEmail;
            }()
          }, {
            key: "lock",
            value: function lock() {
              this.locked = true;
            }
          }, {
            key: "unlock",
            value: function unlock() {
              this.locked = false;
            }
          }, {
            key: "isLocked",
            value: function isLocked() {
              return this.locked == true;
            }
          }, {
            key: "unlockAndResolve",
            value: function unlockAndResolve(resolve, param) {
              this.unlock();
              resolve(param);
            }
          }, {
            key: "login",
            value: function () {
              var _ref10 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee12(url, email, password, strictSignin, extraParams) {
                var _this3 = this;

                return regeneratorRuntime.wrap(function _callee12$(_context12) {
                  while (1) {
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        return _context12.abrupt("return", new Promise(function () {
                          var _ref11 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee11(resolve, reject) {
                            var existingKeys, authParams, message, _message, abort, _message2, minimum, _message3, latestVersion, _message4, keys, requestUrl, params;

                            return regeneratorRuntime.wrap(function _callee11$(_context11) {
                              while (1) {
                                switch (_context11.prev = _context11.next) {
                                  case 0:
                                    _context11.next = 2;
                                    return _this3.keys();

                                  case 2:
                                    existingKeys = _context11.sent;

                                    if (!(existingKeys != null)) {
                                      _context11.next = 6;
                                      break;
                                    }

                                    resolve({
                                      error: {
                                        message: "Cannot log in because already signed in."
                                      }
                                    });
                                    return _context11.abrupt("return");

                                  case 6:
                                    if (!_this3.isLocked()) {
                                      _context11.next = 9;
                                      break;
                                    }

                                    resolve({
                                      error: {
                                        message: "Login already in progress."
                                      }
                                    });
                                    return _context11.abrupt("return");

                                  case 9:
                                    _this3.lock();

                                    _this3.notifyEvent(SFAuthManager.WillSignInEvent);

                                    _context11.next = 13;
                                    return _this3.getAuthParamsForEmail(url, email, extraParams);

                                  case 13:
                                    authParams = _context11.sent; // SF3 requires a unique identifier in the auth params

                                    authParams.identifier = email;

                                    if (!authParams.error) {
                                      _context11.next = 18;
                                      break;
                                    }

                                    _this3.unlockAndResolve(resolve, authParams);

                                    return _context11.abrupt("return");

                                  case 18:
                                    if (!(!authParams || !authParams.pw_cost)) {
                                      _context11.next = 21;
                                      break;
                                    }

                                    _this3.unlockAndResolve(resolve, {
                                      error: {
                                        message: "Invalid email or password."
                                      }
                                    });

                                    return _context11.abrupt("return");

                                  case 21:
                                    if (SFJS.supportedVersions().includes(authParams.version)) {
                                      _context11.next = 25;
                                      break;
                                    }

                                    if (SFJS.isVersionNewerThanLibraryVersion(authParams.version)) {
                                      // The user has a new account type, but is signing in to an older client.
                                      message = "This version of the application does not support your newer account type. Please upgrade to the latest version of Standard Notes to sign in.";
                                    } else {
                                      // The user has a very old account type, which is no longer supported by this client
                                      message = "The protocol version associated with your account is outdated and no longer supported by this application. Please visit standardnotes.org/help/security for more information.";
                                    }

                                    _this3.unlockAndResolve(resolve, {
                                      error: {
                                        message: message
                                      }
                                    });

                                    return _context11.abrupt("return");

                                  case 25:
                                    if (!SFJS.isProtocolVersionOutdated(authParams.version)) {
                                      _context11.next = 32;
                                      break;
                                    }

                                    _message = "The encryption version for your account, " + authParams.version + ", is outdated and requires upgrade. You may proceed with login, but are advised to perform a security update using the web or desktop application. Please visit standardnotes.org/help/security for more information.";
                                    abort = false;
                                    _context11.next = 30;
                                    return _this3.alertManager.confirm({
                                      title: "Update Needed",
                                      text: _message,
                                      confirmButtonText: "Sign In"
                                    }).catch(function () {
                                      _this3.unlockAndResolve(resolve, {
                                        error: {}
                                      });

                                      abort = true;
                                    });

                                  case 30:
                                    if (!abort) {
                                      _context11.next = 32;
                                      break;
                                    }

                                    return _context11.abrupt("return");

                                  case 32:
                                    if (SFJS.supportsPasswordDerivationCost(authParams.pw_cost)) {
                                      _context11.next = 36;
                                      break;
                                    }

                                    _message2 = "Your account was created on a platform with higher security capabilities than this browser supports. " + "If we attempted to generate your login keys here, it would take hours. " + "Please use a browser with more up to date security capabilities, like Google Chrome or Firefox, to log in.";

                                    _this3.unlockAndResolve(resolve, {
                                      error: {
                                        message: _message2
                                      }
                                    });

                                    return _context11.abrupt("return");

                                  case 36:
                                    minimum = SFJS.costMinimumForVersion(authParams.version);

                                    if (!(authParams.pw_cost < minimum)) {
                                      _context11.next = 41;
                                      break;
                                    }

                                    _message3 = "Unable to login due to insecure password parameters. Please visit standardnotes.org/help/security for more information.";

                                    _this3.unlockAndResolve(resolve, {
                                      error: {
                                        message: _message3
                                      }
                                    });

                                    return _context11.abrupt("return");

                                  case 41:
                                    if (!strictSignin) {
                                      _context11.next = 47;
                                      break;
                                    } // Refuse sign in if authParams.version is anything but the latest version


                                    latestVersion = SFJS.version();

                                    if (!(authParams.version !== latestVersion)) {
                                      _context11.next = 47;
                                      break;
                                    }

                                    _message4 = "Strict sign in refused server sign in parameters. The latest security version is " + latestVersion + ", but your account is reported to have version " + authParams.version + ". If you'd like to proceed with sign in anyway, please disable strict sign in and try again.";

                                    _this3.unlockAndResolve(resolve, {
                                      error: {
                                        message: _message4
                                      }
                                    });

                                    return _context11.abrupt("return");

                                  case 47:
                                    _context11.next = 49;
                                    return SFJS.crypto.computeEncryptionKeysForUser(password, authParams);

                                  case 49:
                                    keys = _context11.sent;
                                    requestUrl = url + "/auth/sign_in";
                                    params = _.merge({
                                      password: keys.pw,
                                      email: email
                                    }, extraParams);

                                    _this3.httpManager.postAbsolute(requestUrl, params, function () {
                                      var _ref12 = _asyncToGenerator(
                                      /*#__PURE__*/
                                      regeneratorRuntime.mark(function _callee10(response) {
                                        return regeneratorRuntime.wrap(function _callee10$(_context10) {
                                          while (1) {
                                            switch (_context10.prev = _context10.next) {
                                              case 0:
                                                _context10.next = 2;
                                                return _this3.handleAuthResponse(response, email, url, authParams, keys);

                                              case 2:
                                                _this3.notifyEvent(SFAuthManager.DidSignInEvent);

                                                _this3.$timeout(function () {
                                                  return _this3.unlockAndResolve(resolve, response);
                                                });

                                              case 4:
                                              case "end":
                                                return _context10.stop();
                                            }
                                          }
                                        }, _callee10, _this3);
                                      }));

                                      return function (_x15) {
                                        return _ref12.apply(this, arguments);
                                      };
                                    }(), function (response) {
                                      console.error("Error logging in", response);

                                      if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                                        response = {
                                          error: {
                                            message: "A server error occurred while trying to sign in. Please try again."
                                          }
                                        };
                                      }

                                      _this3.$timeout(function () {
                                        return _this3.unlockAndResolve(resolve, response);
                                      });
                                    });

                                  case 53:
                                  case "end":
                                    return _context11.stop();
                                }
                              }
                            }, _callee11, _this3);
                          }));

                          return function (_x13, _x14) {
                            return _ref11.apply(this, arguments);
                          };
                        }()));

                      case 1:
                      case "end":
                        return _context12.stop();
                    }
                  }
                }, _callee12, this);
              }));

              function login(_x8, _x9, _x10, _x11, _x12) {
                return _ref10.apply(this, arguments);
              }

              return login;
            }()
          }, {
            key: "register",
            value: function register(url, email, password) {
              var _this4 = this;

              return new Promise(function () {
                var _ref13 = _asyncToGenerator(
                /*#__PURE__*/
                regeneratorRuntime.mark(function _callee14(resolve, reject) {
                  var results, keys, authParams, requestUrl, params;
                  return regeneratorRuntime.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          if (!_this4.isLocked()) {
                            _context14.next = 3;
                            break;
                          }

                          resolve({
                            error: {
                              message: "Register already in progress."
                            }
                          });
                          return _context14.abrupt("return");

                        case 3:
                          _this4.lock();

                          _context14.next = 6;
                          return SFJS.crypto.generateInitialKeysAndAuthParamsForUser(email, password);

                        case 6:
                          results = _context14.sent;
                          keys = results.keys;
                          authParams = results.authParams;
                          requestUrl = url + "/auth";
                          params = _.merge({
                            password: keys.pw,
                            email: email
                          }, authParams);

                          _this4.httpManager.postAbsolute(requestUrl, params, function () {
                            var _ref14 = _asyncToGenerator(
                            /*#__PURE__*/
                            regeneratorRuntime.mark(function _callee13(response) {
                              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                                while (1) {
                                  switch (_context13.prev = _context13.next) {
                                    case 0:
                                      _context13.next = 2;
                                      return _this4.handleAuthResponse(response, email, url, authParams, keys);

                                    case 2:
                                      _this4.unlockAndResolve(resolve, response);

                                    case 3:
                                    case "end":
                                      return _context13.stop();
                                  }
                                }
                              }, _callee13, _this4);
                            }));

                            return function (_x18) {
                              return _ref14.apply(this, arguments);
                            };
                          }(), function (response) {
                            console.error("Registration error", response);

                            if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                              response = {
                                error: {
                                  message: "A server error occurred while trying to register. Please try again."
                                }
                              };
                            }

                            _this4.unlockAndResolve(resolve, response);
                          });

                        case 12:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14, _this4);
                }));

                return function (_x16, _x17) {
                  return _ref13.apply(this, arguments);
                };
              }());
            }
          }, {
            key: "changePassword",
            value: function () {
              var _ref15 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee17(url, email, current_server_pw, newKeys, newAuthParams) {
                var _this5 = this;

                return regeneratorRuntime.wrap(function _callee17$(_context17) {
                  while (1) {
                    switch (_context17.prev = _context17.next) {
                      case 0:
                        return _context17.abrupt("return", new Promise(function () {
                          var _ref16 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee16(resolve, reject) {
                            var newServerPw, requestUrl, params;
                            return regeneratorRuntime.wrap(function _callee16$(_context16) {
                              while (1) {
                                switch (_context16.prev = _context16.next) {
                                  case 0:
                                    if (!_this5.isLocked()) {
                                      _context16.next = 3;
                                      break;
                                    }

                                    resolve({
                                      error: {
                                        message: "Change password already in progress."
                                      }
                                    });
                                    return _context16.abrupt("return");

                                  case 3:
                                    _this5.lock();

                                    newServerPw = newKeys.pw;
                                    requestUrl = url + "/auth/change_pw";
                                    params = _.merge({
                                      new_password: newServerPw,
                                      current_password: current_server_pw
                                    }, newAuthParams);

                                    _this5.httpManager.postAbsolute(requestUrl, params, function () {
                                      var _ref17 = _asyncToGenerator(
                                      /*#__PURE__*/
                                      regeneratorRuntime.mark(function _callee15(response) {
                                        return regeneratorRuntime.wrap(function _callee15$(_context15) {
                                          while (1) {
                                            switch (_context15.prev = _context15.next) {
                                              case 0:
                                                _context15.next = 2;
                                                return _this5.handleAuthResponse(response, email, null, newAuthParams, newKeys);

                                              case 2:
                                                _this5.unlockAndResolve(resolve, response);

                                              case 3:
                                              case "end":
                                                return _context15.stop();
                                            }
                                          }
                                        }, _callee15, _this5);
                                      }));

                                      return function (_x26) {
                                        return _ref17.apply(this, arguments);
                                      };
                                    }(), function (response) {
                                      if ((typeof response === "undefined" ? "undefined" : _typeof(response)) !== 'object') {
                                        response = {
                                          error: {
                                            message: "Something went wrong while changing your password. Your password was not changed. Please try again."
                                          }
                                        };
                                      }

                                      _this5.unlockAndResolve(resolve, response);
                                    });

                                  case 8:
                                  case "end":
                                    return _context16.stop();
                                }
                              }
                            }, _callee16, _this5);
                          }));

                          return function (_x24, _x25) {
                            return _ref16.apply(this, arguments);
                          };
                        }()));

                      case 1:
                      case "end":
                        return _context17.stop();
                    }
                  }
                }, _callee17, this);
              }));

              function changePassword(_x19, _x20, _x21, _x22, _x23) {
                return _ref15.apply(this, arguments);
              }

              return changePassword;
            }()
          }, {
            key: "handleAuthResponse",
            value: function () {
              var _ref18 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee18(response, email, url, authParams, keys) {
                return regeneratorRuntime.wrap(function _callee18$(_context18) {
                  while (1) {
                    switch (_context18.prev = _context18.next) {
                      case 0:
                        if (!url) {
                          _context18.next = 3;
                          break;
                        }

                        _context18.next = 3;
                        return this.storageManager.setItem("server", url);

                      case 3:
                        this._authParams = authParams;
                        _context18.next = 6;
                        return this.storageManager.setItem("auth_params", JSON.stringify(authParams));

                      case 6:
                        _context18.next = 8;
                        return this.storageManager.setItem("jwt", response.token);

                      case 8:
                        return _context18.abrupt("return", this.saveKeys(keys));

                      case 9:
                      case "end":
                        return _context18.stop();
                    }
                  }
                }, _callee18, this);
              }));

              function handleAuthResponse(_x27, _x28, _x29, _x30, _x31) {
                return _ref18.apply(this, arguments);
              }

              return handleAuthResponse;
            }()
          }]);

          return SFAuthManager;
        }();

        ;
        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

        var SFHttpManager = exports.SFHttpManager = function () {
          function SFHttpManager(timeout) {
            _classCallCheck(this, SFHttpManager); // calling callbacks in a $timeout allows UI to update


            this.$timeout = timeout || setTimeout.bind(globalScope);
          }

          _createClass(SFHttpManager, [{
            key: "setJWTRequestHandler",
            value: function setJWTRequestHandler(handler) {
              this.jwtRequestHandler = handler;
            }
          }, {
            key: "setAuthHeadersForRequest",
            value: function () {
              var _ref19 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee19(request) {
                var token;
                return regeneratorRuntime.wrap(function _callee19$(_context19) {
                  while (1) {
                    switch (_context19.prev = _context19.next) {
                      case 0:
                        _context19.next = 2;
                        return this.jwtRequestHandler();

                      case 2:
                        token = _context19.sent;

                        if (token) {
                          request.setRequestHeader('Authorization', 'Bearer ' + token);
                        }

                      case 4:
                      case "end":
                        return _context19.stop();
                    }
                  }
                }, _callee19, this);
              }));

              function setAuthHeadersForRequest(_x32) {
                return _ref19.apply(this, arguments);
              }

              return setAuthHeadersForRequest;
            }()
          }, {
            key: "postAbsolute",
            value: function () {
              var _ref20 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee20(url, params, onsuccess, onerror) {
                return regeneratorRuntime.wrap(function _callee20$(_context20) {
                  while (1) {
                    switch (_context20.prev = _context20.next) {
                      case 0:
                        return _context20.abrupt("return", this.httpRequest("post", url, params, onsuccess, onerror));

                      case 1:
                      case "end":
                        return _context20.stop();
                    }
                  }
                }, _callee20, this);
              }));

              function postAbsolute(_x33, _x34, _x35, _x36) {
                return _ref20.apply(this, arguments);
              }

              return postAbsolute;
            }()
          }, {
            key: "patchAbsolute",
            value: function () {
              var _ref21 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee21(url, params, onsuccess, onerror) {
                return regeneratorRuntime.wrap(function _callee21$(_context21) {
                  while (1) {
                    switch (_context21.prev = _context21.next) {
                      case 0:
                        return _context21.abrupt("return", this.httpRequest("patch", url, params, onsuccess, onerror));

                      case 1:
                      case "end":
                        return _context21.stop();
                    }
                  }
                }, _callee21, this);
              }));

              function patchAbsolute(_x37, _x38, _x39, _x40) {
                return _ref21.apply(this, arguments);
              }

              return patchAbsolute;
            }()
          }, {
            key: "getAbsolute",
            value: function () {
              var _ref22 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee22(url, params, onsuccess, onerror) {
                return regeneratorRuntime.wrap(function _callee22$(_context22) {
                  while (1) {
                    switch (_context22.prev = _context22.next) {
                      case 0:
                        return _context22.abrupt("return", this.httpRequest("get", url, params, onsuccess, onerror));

                      case 1:
                      case "end":
                        return _context22.stop();
                    }
                  }
                }, _callee22, this);
              }));

              function getAbsolute(_x41, _x42, _x43, _x44) {
                return _ref22.apply(this, arguments);
              }

              return getAbsolute;
            }()
          }, {
            key: "httpRequest",
            value: function () {
              var _ref23 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee24(verb, url, params, onsuccess, onerror) {
                var _this6 = this;

                return regeneratorRuntime.wrap(function _callee24$(_context24) {
                  while (1) {
                    switch (_context24.prev = _context24.next) {
                      case 0:
                        return _context24.abrupt("return", new Promise(function () {
                          var _ref24 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee23(resolve, reject) {
                            var xmlhttp;
                            return regeneratorRuntime.wrap(function _callee23$(_context23) {
                              while (1) {
                                switch (_context23.prev = _context23.next) {
                                  case 0:
                                    xmlhttp = new XMLHttpRequest();

                                    xmlhttp.onreadystatechange = function () {
                                      if (xmlhttp.readyState == 4) {
                                        var response = xmlhttp.responseText;

                                        if (response) {
                                          try {
                                            response = JSON.parse(response);
                                          } catch (e) {}
                                        }

                                        if (xmlhttp.status >= 200 && xmlhttp.status <= 299) {
                                          _this6.$timeout(function () {
                                            onsuccess(response);
                                            resolve(response);
                                          });
                                        } else {
                                          console.error("Request error:", response);

                                          _this6.$timeout(function () {
                                            onerror(response, xmlhttp.status);
                                            reject(response);
                                          });
                                        }
                                      }
                                    };

                                    if (verb == "get" && Object.keys(params).length > 0) {
                                      url = url + _this6.formatParams(params);
                                    }

                                    xmlhttp.open(verb, url, true);
                                    _context23.next = 6;
                                    return _this6.setAuthHeadersForRequest(xmlhttp);

                                  case 6:
                                    xmlhttp.setRequestHeader('Content-type', 'application/json');

                                    if (verb == "post" || verb == "patch") {
                                      xmlhttp.send(JSON.stringify(params));
                                    } else {
                                      xmlhttp.send();
                                    }

                                  case 8:
                                  case "end":
                                    return _context23.stop();
                                }
                              }
                            }, _callee23, _this6);
                          }));

                          return function (_x50, _x51) {
                            return _ref24.apply(this, arguments);
                          };
                        }()));

                      case 1:
                      case "end":
                        return _context24.stop();
                    }
                  }
                }, _callee24, this);
              }));

              function httpRequest(_x45, _x46, _x47, _x48, _x49) {
                return _ref23.apply(this, arguments);
              }

              return httpRequest;
            }()
          }, {
            key: "formatParams",
            value: function formatParams(params) {
              return "?" + Object.keys(params).map(function (key) {
                return key + "=" + encodeURIComponent(params[key]);
              }).join("&");
            }
          }]);

          return SFHttpManager;
        }();

        ;

        var SFMigrationManager = exports.SFMigrationManager = function () {
          function SFMigrationManager(modelManager, syncManager, storageManager, authManager) {
            var _this7 = this;

            _classCallCheck(this, SFMigrationManager);

            this.modelManager = modelManager;
            this.syncManager = syncManager;
            this.storageManager = storageManager;
            this.completionHandlers = [];
            this.loadMigrations(); // The syncManager used to dispatch a param called 'initialSync' in the 'sync:completed' event
            // to let us know of the first sync completion after login.
            // however it was removed as it was deemed to be unreliable (returned wrong value when a single sync request repeats on completion for pagination)
            // We'll now use authManager's events instead

            var didReceiveSignInEvent = false;
            var signInHandler = authManager.addEventHandler(function (event) {
              if (event == SFAuthManager.DidSignInEvent) {
                didReceiveSignInEvent = true;
              }
            });
            this.syncManager.addEventHandler(function () {
              var _ref25 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee25(event, data) {
                var dataLoadedEvent, syncCompleteEvent, completedList, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, migrationName, migration;

                return regeneratorRuntime.wrap(function _callee25$(_context25) {
                  while (1) {
                    switch (_context25.prev = _context25.next) {
                      case 0:
                        dataLoadedEvent = event == "local-data-loaded";
                        syncCompleteEvent = event == "sync:completed";

                        if (!(dataLoadedEvent || syncCompleteEvent)) {
                          _context25.next = 40;
                          break;
                        }

                        if (dataLoadedEvent) {
                          _this7.receivedLocalDataEvent = true;
                        } else if (syncCompleteEvent) {
                          _this7.receivedSyncCompletedEvent = true;
                        } // We want to run pending migrations only after local data has been loaded, and a sync has been completed.


                        if (!(_this7.receivedLocalDataEvent && _this7.receivedSyncCompletedEvent)) {
                          _context25.next = 40;
                          break;
                        }

                        if (!didReceiveSignInEvent) {
                          _context25.next = 39;
                          break;
                        } // Reset our collected state about sign in


                        didReceiveSignInEvent = false;
                        authManager.removeEventHandler(signInHandler); // If initial online sync, clear any completed migrations that occurred while offline,
                        // so they can run again now that we have updated user items. Only clear migrations that
                        // don't have `runOnlyOnce` set

                        _context25.next = 10;
                        return _this7.getCompletedMigrations();

                      case 10:
                        completedList = _context25.sent.slice();
                        _iteratorNormalCompletion2 = true;
                        _didIteratorError2 = false;
                        _iteratorError2 = undefined;
                        _context25.prev = 14;
                        _iterator2 = completedList[Symbol.iterator]();

                      case 16:
                        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                          _context25.next = 25;
                          break;
                        }

                        migrationName = _step2.value;
                        _context25.next = 20;
                        return _this7.migrationForEncodedName(migrationName);

                      case 20:
                        migration = _context25.sent;

                        if (!migration.runOnlyOnce) {
                          _.pull(_this7._completed, migrationName);
                        }

                      case 22:
                        _iteratorNormalCompletion2 = true;
                        _context25.next = 16;
                        break;

                      case 25:
                        _context25.next = 31;
                        break;

                      case 27:
                        _context25.prev = 27;
                        _context25.t0 = _context25["catch"](14);
                        _didIteratorError2 = true;
                        _iteratorError2 = _context25.t0;

                      case 31:
                        _context25.prev = 31;
                        _context25.prev = 32;

                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                          _iterator2.return();
                        }

                      case 34:
                        _context25.prev = 34;

                        if (!_didIteratorError2) {
                          _context25.next = 37;
                          break;
                        }

                        throw _iteratorError2;

                      case 37:
                        return _context25.finish(34);

                      case 38:
                        return _context25.finish(31);

                      case 39:
                        _this7.runPendingMigrations();

                      case 40:
                      case "end":
                        return _context25.stop();
                    }
                  }
                }, _callee25, _this7, [[14, 27, 31, 39], [32,, 34, 38]]);
              }));

              return function (_x52, _x53) {
                return _ref25.apply(this, arguments);
              };
            }());
          }

          _createClass(SFMigrationManager, [{
            key: "addCompletionHandler",
            value: function addCompletionHandler(handler) {
              this.completionHandlers.push(handler);
            }
          }, {
            key: "removeCompletionHandler",
            value: function removeCompletionHandler(handler) {
              _.pull(this.completionHandlers, handler);
            }
          }, {
            key: "migrationForEncodedName",
            value: function () {
              var _ref26 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee26(name) {
                var decoded;
                return regeneratorRuntime.wrap(function _callee26$(_context26) {
                  while (1) {
                    switch (_context26.prev = _context26.next) {
                      case 0:
                        _context26.next = 2;
                        return this.decode(name);

                      case 2:
                        decoded = _context26.sent;
                        return _context26.abrupt("return", this.migrations.find(function (migration) {
                          return migration.name == decoded;
                        }));

                      case 4:
                      case "end":
                        return _context26.stop();
                    }
                  }
                }, _callee26, this);
              }));

              function migrationForEncodedName(_x54) {
                return _ref26.apply(this, arguments);
              }

              return migrationForEncodedName;
            }()
          }, {
            key: "loadMigrations",
            value: function loadMigrations() {
              this.migrations = this.registeredMigrations();
            }
          }, {
            key: "registeredMigrations",
            value: function registeredMigrations() {// Subclasses should return an array of migrations here.
              // Migrations should have a unique `name`, `content_type`,
              // and `handler`, which is a function that accepts an array of matching items to migration.
            }
          }, {
            key: "runPendingMigrations",
            value: function () {
              var _ref27 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee27() {
                var pending, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, migration, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, item, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, handler;

                return regeneratorRuntime.wrap(function _callee27$(_context27) {
                  while (1) {
                    switch (_context27.prev = _context27.next) {
                      case 0:
                        _context27.next = 2;
                        return this.getPendingMigrations();

                      case 2:
                        pending = _context27.sent; // run in pre loop, keeping in mind that a migration may be run twice: when offline then again when signing in.
                        // we need to reset the items to a new array.

                        _iteratorNormalCompletion3 = true;
                        _didIteratorError3 = false;
                        _iteratorError3 = undefined;
                        _context27.prev = 6;

                        for (_iterator3 = pending[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                          migration = _step3.value;
                          migration.items = [];
                        }

                        _context27.next = 14;
                        break;

                      case 10:
                        _context27.prev = 10;
                        _context27.t0 = _context27["catch"](6);
                        _didIteratorError3 = true;
                        _iteratorError3 = _context27.t0;

                      case 14:
                        _context27.prev = 14;
                        _context27.prev = 15;

                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                          _iterator3.return();
                        }

                      case 17:
                        _context27.prev = 17;

                        if (!_didIteratorError3) {
                          _context27.next = 20;
                          break;
                        }

                        throw _iteratorError3;

                      case 20:
                        return _context27.finish(17);

                      case 21:
                        return _context27.finish(14);

                      case 22:
                        _iteratorNormalCompletion4 = true;
                        _didIteratorError4 = false;
                        _iteratorError4 = undefined;
                        _context27.prev = 25;
                        _iterator4 = this.modelManager.allNondummyItems[Symbol.iterator]();

                      case 27:
                        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                          _context27.next = 51;
                          break;
                        }

                        item = _step4.value;
                        _iteratorNormalCompletion7 = true;
                        _didIteratorError7 = false;
                        _iteratorError7 = undefined;
                        _context27.prev = 32;

                        for (_iterator7 = pending[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                          migration = _step7.value;

                          if (item.content_type == migration.content_type) {
                            migration.items.push(item);
                          }
                        }

                        _context27.next = 40;
                        break;

                      case 36:
                        _context27.prev = 36;
                        _context27.t1 = _context27["catch"](32);
                        _didIteratorError7 = true;
                        _iteratorError7 = _context27.t1;

                      case 40:
                        _context27.prev = 40;
                        _context27.prev = 41;

                        if (!_iteratorNormalCompletion7 && _iterator7.return) {
                          _iterator7.return();
                        }

                      case 43:
                        _context27.prev = 43;

                        if (!_didIteratorError7) {
                          _context27.next = 46;
                          break;
                        }

                        throw _iteratorError7;

                      case 46:
                        return _context27.finish(43);

                      case 47:
                        return _context27.finish(40);

                      case 48:
                        _iteratorNormalCompletion4 = true;
                        _context27.next = 27;
                        break;

                      case 51:
                        _context27.next = 57;
                        break;

                      case 53:
                        _context27.prev = 53;
                        _context27.t2 = _context27["catch"](25);
                        _didIteratorError4 = true;
                        _iteratorError4 = _context27.t2;

                      case 57:
                        _context27.prev = 57;
                        _context27.prev = 58;

                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                          _iterator4.return();
                        }

                      case 60:
                        _context27.prev = 60;

                        if (!_didIteratorError4) {
                          _context27.next = 63;
                          break;
                        }

                        throw _iteratorError4;

                      case 63:
                        return _context27.finish(60);

                      case 64:
                        return _context27.finish(57);

                      case 65:
                        _iteratorNormalCompletion5 = true;
                        _didIteratorError5 = false;
                        _iteratorError5 = undefined;
                        _context27.prev = 68;
                        _iterator5 = pending[Symbol.iterator]();

                      case 70:
                        if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                          _context27.next = 81;
                          break;
                        }

                        migration = _step5.value;

                        if (!(migration.items && migration.items.length > 0 || migration.customHandler)) {
                          _context27.next = 77;
                          break;
                        }

                        _context27.next = 75;
                        return this.runMigration(migration, migration.items);

                      case 75:
                        _context27.next = 78;
                        break;

                      case 77:
                        this.markMigrationCompleted(migration);

                      case 78:
                        _iteratorNormalCompletion5 = true;
                        _context27.next = 70;
                        break;

                      case 81:
                        _context27.next = 87;
                        break;

                      case 83:
                        _context27.prev = 83;
                        _context27.t3 = _context27["catch"](68);
                        _didIteratorError5 = true;
                        _iteratorError5 = _context27.t3;

                      case 87:
                        _context27.prev = 87;
                        _context27.prev = 88;

                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                          _iterator5.return();
                        }

                      case 90:
                        _context27.prev = 90;

                        if (!_didIteratorError5) {
                          _context27.next = 93;
                          break;
                        }

                        throw _iteratorError5;

                      case 93:
                        return _context27.finish(90);

                      case 94:
                        return _context27.finish(87);

                      case 95:
                        _iteratorNormalCompletion6 = true;
                        _didIteratorError6 = false;
                        _iteratorError6 = undefined;
                        _context27.prev = 98;

                        for (_iterator6 = this.completionHandlers[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                          handler = _step6.value;
                          handler();
                        }

                        _context27.next = 106;
                        break;

                      case 102:
                        _context27.prev = 102;
                        _context27.t4 = _context27["catch"](98);
                        _didIteratorError6 = true;
                        _iteratorError6 = _context27.t4;

                      case 106:
                        _context27.prev = 106;
                        _context27.prev = 107;

                        if (!_iteratorNormalCompletion6 && _iterator6.return) {
                          _iterator6.return();
                        }

                      case 109:
                        _context27.prev = 109;

                        if (!_didIteratorError6) {
                          _context27.next = 112;
                          break;
                        }

                        throw _iteratorError6;

                      case 112:
                        return _context27.finish(109);

                      case 113:
                        return _context27.finish(106);

                      case 114:
                      case "end":
                        return _context27.stop();
                    }
                  }
                }, _callee27, this, [[6, 10, 14, 22], [15,, 17, 21], [25, 53, 57, 65], [32, 36, 40, 48], [41,, 43, 47], [58,, 60, 64], [68, 83, 87, 95], [88,, 90, 94], [98, 102, 106, 114], [107,, 109, 113]]);
              }));

              function runPendingMigrations() {
                return _ref27.apply(this, arguments);
              }

              return runPendingMigrations;
            }()
          }, {
            key: "encode",
            value: function () {
              var _ref28 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee28(text) {
                return regeneratorRuntime.wrap(function _callee28$(_context28) {
                  while (1) {
                    switch (_context28.prev = _context28.next) {
                      case 0:
                        return _context28.abrupt("return", window.btoa(text));

                      case 1:
                      case "end":
                        return _context28.stop();
                    }
                  }
                }, _callee28, this);
              }));

              function encode(_x55) {
                return _ref28.apply(this, arguments);
              }

              return encode;
            }()
          }, {
            key: "decode",
            value: function () {
              var _ref29 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee29(text) {
                return regeneratorRuntime.wrap(function _callee29$(_context29) {
                  while (1) {
                    switch (_context29.prev = _context29.next) {
                      case 0:
                        return _context29.abrupt("return", window.atob(text));

                      case 1:
                      case "end":
                        return _context29.stop();
                    }
                  }
                }, _callee29, this);
              }));

              function decode(_x56) {
                return _ref29.apply(this, arguments);
              }

              return decode;
            }()
          }, {
            key: "getCompletedMigrations",
            value: function () {
              var _ref30 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee30() {
                var rawCompleted;
                return regeneratorRuntime.wrap(function _callee30$(_context30) {
                  while (1) {
                    switch (_context30.prev = _context30.next) {
                      case 0:
                        if (this._completed) {
                          _context30.next = 5;
                          break;
                        }

                        _context30.next = 3;
                        return this.storageManager.getItem("migrations");

                      case 3:
                        rawCompleted = _context30.sent;

                        if (rawCompleted) {
                          this._completed = JSON.parse(rawCompleted);
                        } else {
                          this._completed = [];
                        }

                      case 5:
                        return _context30.abrupt("return", this._completed);

                      case 6:
                      case "end":
                        return _context30.stop();
                    }
                  }
                }, _callee30, this);
              }));

              function getCompletedMigrations() {
                return _ref30.apply(this, arguments);
              }

              return getCompletedMigrations;
            }()
          }, {
            key: "getPendingMigrations",
            value: function () {
              var _ref31 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee31() {
                var completed, pending, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, migration;

                return regeneratorRuntime.wrap(function _callee31$(_context31) {
                  while (1) {
                    switch (_context31.prev = _context31.next) {
                      case 0:
                        _context31.next = 2;
                        return this.getCompletedMigrations();

                      case 2:
                        completed = _context31.sent;
                        pending = [];
                        _iteratorNormalCompletion8 = true;
                        _didIteratorError8 = false;
                        _iteratorError8 = undefined;
                        _context31.prev = 7;
                        _iterator8 = this.migrations[Symbol.iterator]();

                      case 9:
                        if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                          _context31.next = 22;
                          break;
                        }

                        migration = _step8.value;
                        _context31.t0 = completed;
                        _context31.next = 14;
                        return this.encode(migration.name);

                      case 14:
                        _context31.t1 = _context31.sent;
                        _context31.t2 = _context31.t0.indexOf.call(_context31.t0, _context31.t1);
                        _context31.t3 = -1;

                        if (!(_context31.t2 == _context31.t3)) {
                          _context31.next = 19;
                          break;
                        }

                        pending.push(migration);

                      case 19:
                        _iteratorNormalCompletion8 = true;
                        _context31.next = 9;
                        break;

                      case 22:
                        _context31.next = 28;
                        break;

                      case 24:
                        _context31.prev = 24;
                        _context31.t4 = _context31["catch"](7);
                        _didIteratorError8 = true;
                        _iteratorError8 = _context31.t4;

                      case 28:
                        _context31.prev = 28;
                        _context31.prev = 29;

                        if (!_iteratorNormalCompletion8 && _iterator8.return) {
                          _iterator8.return();
                        }

                      case 31:
                        _context31.prev = 31;

                        if (!_didIteratorError8) {
                          _context31.next = 34;
                          break;
                        }

                        throw _iteratorError8;

                      case 34:
                        return _context31.finish(31);

                      case 35:
                        return _context31.finish(28);

                      case 36:
                        return _context31.abrupt("return", pending);

                      case 37:
                      case "end":
                        return _context31.stop();
                    }
                  }
                }, _callee31, this, [[7, 24, 28, 36], [29,, 31, 35]]);
              }));

              function getPendingMigrations() {
                return _ref31.apply(this, arguments);
              }

              return getPendingMigrations;
            }()
          }, {
            key: "markMigrationCompleted",
            value: function () {
              var _ref32 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee32(migration) {
                var completed;
                return regeneratorRuntime.wrap(function _callee32$(_context32) {
                  while (1) {
                    switch (_context32.prev = _context32.next) {
                      case 0:
                        _context32.next = 2;
                        return this.getCompletedMigrations();

                      case 2:
                        completed = _context32.sent;
                        _context32.t0 = completed;
                        _context32.next = 6;
                        return this.encode(migration.name);

                      case 6:
                        _context32.t1 = _context32.sent;

                        _context32.t0.push.call(_context32.t0, _context32.t1);

                        this.storageManager.setItem("migrations", JSON.stringify(completed));
                        migration.running = false;

                      case 10:
                      case "end":
                        return _context32.stop();
                    }
                  }
                }, _callee32, this);
              }));

              function markMigrationCompleted(_x57) {
                return _ref32.apply(this, arguments);
              }

              return markMigrationCompleted;
            }()
          }, {
            key: "runMigration",
            value: function () {
              var _ref33 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee33(migration, items) {
                var _this8 = this;

                return regeneratorRuntime.wrap(function _callee33$(_context33) {
                  while (1) {
                    switch (_context33.prev = _context33.next) {
                      case 0:
                        if (!migration.running) {
                          _context33.next = 2;
                          break;
                        }

                        return _context33.abrupt("return");

                      case 2:
                        console.log("Running migration:", migration.name);
                        migration.running = true;

                        if (!migration.customHandler) {
                          _context33.next = 8;
                          break;
                        }

                        return _context33.abrupt("return", migration.customHandler().then(function () {
                          _this8.markMigrationCompleted(migration);
                        }));

                      case 8:
                        return _context33.abrupt("return", migration.handler(items).then(function () {
                          _this8.markMigrationCompleted(migration);
                        }));

                      case 9:
                      case "end":
                        return _context33.stop();
                    }
                  }
                }, _callee33, this);
              }));

              function runMigration(_x58, _x59) {
                return _ref33.apply(this, arguments);
              }

              return runMigration;
            }()
          }]);

          return SFMigrationManager;
        }();

        ;

        var SFModelManager = exports.SFModelManager = function () {
          function SFModelManager(timeout) {
            _classCallCheck(this, SFModelManager);

            SFModelManager.MappingSourceRemoteRetrieved = "MappingSourceRemoteRetrieved";
            SFModelManager.MappingSourceRemoteSaved = "MappingSourceRemoteSaved";
            SFModelManager.MappingSourceLocalSaved = "MappingSourceLocalSaved";
            SFModelManager.MappingSourceLocalRetrieved = "MappingSourceLocalRetrieved";
            SFModelManager.MappingSourceComponentRetrieved = "MappingSourceComponentRetrieved";
            SFModelManager.MappingSourceDesktopInstalled = "MappingSourceDesktopInstalled"; // When a component is installed by the desktop and some of its values change

            SFModelManager.MappingSourceRemoteActionRetrieved = "MappingSourceRemoteActionRetrieved";
            /* aciton-based Extensions like note history */

            SFModelManager.MappingSourceFileImport = "MappingSourceFileImport";

            SFModelManager.isMappingSourceRetrieved = function (source) {
              return [SFModelManager.MappingSourceRemoteRetrieved, SFModelManager.MappingSourceComponentRetrieved, SFModelManager.MappingSourceRemoteActionRetrieved].includes(source);
            };

            this.$timeout = timeout || setTimeout.bind(window);
            this.itemSyncObservers = [];
            this.itemsPendingRemoval = [];
            this.items = [];
            this.itemsHash = {};
            this.missedReferences = {};
            this.uuidChangeObservers = [];
          }

          _createClass(SFModelManager, [{
            key: "handleSignout",
            value: function handleSignout() {
              this.items.length = 0;
              this.itemsHash = {};
              this.itemsPendingRemoval.length = 0;
              this.missedReferences = {};
            }
          }, {
            key: "addModelUuidChangeObserver",
            value: function addModelUuidChangeObserver(id, callback) {
              this.uuidChangeObservers.push({
                id: id,
                callback: callback
              });
            }
          }, {
            key: "notifyObserversOfUuidChange",
            value: function notifyObserversOfUuidChange(oldItem, newItem) {
              var _iteratorNormalCompletion9 = true;
              var _didIteratorError9 = false;
              var _iteratorError9 = undefined;

              try {
                for (var _iterator9 = this.uuidChangeObservers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                  var observer = _step9.value;
                  observer.callback(oldItem, newItem);
                }
              } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion9 && _iterator9.return) {
                    _iterator9.return();
                  }
                } finally {
                  if (_didIteratorError9) {
                    throw _iteratorError9;
                  }
                }
              }
            }
          }, {
            key: "alternateUUIDForItem",
            value: function () {
              var _ref34 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee34(item) {
                var newItem, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, referencingObject;

                return regeneratorRuntime.wrap(function _callee34$(_context34) {
                  while (1) {
                    switch (_context34.prev = _context34.next) {
                      case 0:
                        // We need to clone this item and give it a new uuid, then delete item with old uuid from db (you can't modify uuid's in our indexeddb setup)
                        newItem = this.createItem(item, true);
                        _context34.next = 3;
                        return SFJS.crypto.generateUUID();

                      case 3:
                        newItem.uuid = _context34.sent; // Update uuids of relationships

                        newItem.informReferencesOfUUIDChange(item.uuid, newItem.uuid);
                        this.informModelsOfUUIDChangeForItem(newItem, item.uuid, newItem.uuid); // the new item should inherit the original's relationships

                        _iteratorNormalCompletion10 = true;
                        _didIteratorError10 = false;
                        _iteratorError10 = undefined;
                        _context34.prev = 9;

                        for (_iterator10 = item.referencingObjects[Symbol.iterator](); !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                          referencingObject = _step10.value;
                          referencingObject.setIsNoLongerBeingReferencedBy(item);
                          item.setIsNoLongerBeingReferencedBy(referencingObject);
                          referencingObject.addItemAsRelationship(newItem);
                          referencingObject.setDirty(true);
                        } // Used to set up referencingObjects for new item (so that other items can now properly reference this new item)


                        _context34.next = 17;
                        break;

                      case 13:
                        _context34.prev = 13;
                        _context34.t0 = _context34["catch"](9);
                        _didIteratorError10 = true;
                        _iteratorError10 = _context34.t0;

                      case 17:
                        _context34.prev = 17;
                        _context34.prev = 18;

                        if (!_iteratorNormalCompletion10 && _iterator10.return) {
                          _iterator10.return();
                        }

                      case 20:
                        _context34.prev = 20;

                        if (!_didIteratorError10) {
                          _context34.next = 23;
                          break;
                        }

                        throw _iteratorError10;

                      case 23:
                        return _context34.finish(20);

                      case 24:
                        return _context34.finish(17);

                      case 25:
                        this.resolveReferencesForItem(newItem);
                        console.log(item.uuid, "-->", newItem.uuid); // Set to deleted, then run through mapping function so that observers can be notified

                        item.deleted = true;
                        item.content.references = []; // Don't set dirty, because we don't need to sync old item. alternating uuid only occurs in two cases:
                        // signing in and merging offline data, or when a uuid-conflict occurs. In both cases, the original item never
                        // saves to a server, so doesn't need to be synced.
                        // informModelsOfUUIDChangeForItem may set this object to dirty, but we want to undo that here, so that the item gets deleted
                        // right away through the mapping function.

                        item.setDirty(false);
                        this.mapResponseItemsToLocalModels([item], SFModelManager.MappingSourceLocalSaved); // add new item

                        this.addItem(newItem);
                        newItem.setDirty(true);
                        this.notifyObserversOfUuidChange(item, newItem);
                        return _context34.abrupt("return", newItem);

                      case 35:
                      case "end":
                        return _context34.stop();
                    }
                  }
                }, _callee34, this, [[9, 13, 17, 25], [18,, 20, 24]]);
              }));

              function alternateUUIDForItem(_x60) {
                return _ref34.apply(this, arguments);
              }

              return alternateUUIDForItem;
            }()
          }, {
            key: "informModelsOfUUIDChangeForItem",
            value: function informModelsOfUUIDChangeForItem(newItem, oldUUID, newUUID) {
              // some models that only have one-way relationships might be interested to hear that an item has changed its uuid
              // for example, editors have a one way relationship with notes. When a note changes its UUID, it has no way to inform the editor
              // to update its relationships
              var _iteratorNormalCompletion11 = true;
              var _didIteratorError11 = false;
              var _iteratorError11 = undefined;

              try {
                for (var _iterator11 = this.items[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                  var model = _step11.value;
                  model.potentialItemOfInterestHasChangedItsUUID(newItem, oldUUID, newUUID);
                }
              } catch (err) {
                _didIteratorError11 = true;
                _iteratorError11 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion11 && _iterator11.return) {
                    _iterator11.return();
                  }
                } finally {
                  if (_didIteratorError11) {
                    throw _iteratorError11;
                  }
                }
              }
            }
          }, {
            key: "didSyncModelsOffline",
            value: function didSyncModelsOffline(items) {
              this.notifySyncObserversOfModels(items, SFModelManager.MappingSourceLocalSaved);
            }
          }, {
            key: "mapResponseItemsToLocalModels",
            value: function mapResponseItemsToLocalModels(items, source, sourceKey) {
              return this.mapResponseItemsToLocalModelsWithOptions({
                items: items,
                source: source,
                sourceKey: sourceKey
              });
            }
          }, {
            key: "mapResponseItemsToLocalModelsOmittingFields",
            value: function mapResponseItemsToLocalModelsOmittingFields(items, omitFields, source, sourceKey) {
              return this.mapResponseItemsToLocalModelsWithOptions({
                items: items,
                omitFields: omitFields,
                source: source,
                sourceKey: sourceKey
              });
            }
          }, {
            key: "mapResponseItemsToLocalModelsWithOptions",
            value: function mapResponseItemsToLocalModelsWithOptions(_ref35) {
              var items = _ref35.items,
                  omitFields = _ref35.omitFields,
                  source = _ref35.source,
                  sourceKey = _ref35.sourceKey,
                  options = _ref35.options;
              var models = [],
                  processedObjects = [],
                  modelsToNotifyObserversOf = []; // first loop should add and process items

              var _iteratorNormalCompletion12 = true;
              var _didIteratorError12 = false;
              var _iteratorError12 = undefined;

              try {
                for (var _iterator12 = items[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                  var json_obj = _step12.value;

                  if (!json_obj) {
                    continue;
                  } // content is missing if it has been sucessfullly decrypted but no content


                  var isMissingContent = !json_obj.content && !json_obj.errorDecrypting;
                  var isCorrupt = !json_obj.content_type || !json_obj.uuid;

                  if ((isCorrupt || isMissingContent) && !json_obj.deleted) {
                    // An item that is not deleted should never have empty content
                    console.error("Server response item is corrupt:", json_obj);
                    continue;
                  } // Lodash's _.omit, which was previously used, seems to cause unexpected behavior
                  // when json_obj is an ES6 item class. So we instead manually omit each key.


                  if (Array.isArray(omitFields)) {
                    var _iteratorNormalCompletion15 = true;
                    var _didIteratorError15 = false;
                    var _iteratorError15 = undefined;

                    try {
                      for (var _iterator15 = omitFields[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                        var key = _step15.value;
                        delete json_obj[key];
                      }
                    } catch (err) {
                      _didIteratorError15 = true;
                      _iteratorError15 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion15 && _iterator15.return) {
                          _iterator15.return();
                        }
                      } finally {
                        if (_didIteratorError15) {
                          throw _iteratorError15;
                        }
                      }
                    }
                  }

                  var item = this.findItem(json_obj.uuid);

                  if (item) {
                    item.updateFromJSON(json_obj); // If an item goes through mapping, it can no longer be a dummy.

                    item.dummy = false;
                  }

                  if (this.itemsPendingRemoval.includes(json_obj.uuid)) {
                    _.pull(this.itemsPendingRemoval, json_obj.uuid);

                    continue;
                  }

                  var contentType = json_obj["content_type"] || item && item.content_type;
                  var unknownContentType = this.acceptableContentTypes && !this.acceptableContentTypes.includes(contentType);

                  if (unknownContentType) {
                    continue;
                  }

                  var isDirtyItemPendingDelete = false;

                  if (json_obj.deleted == true) {
                    if (json_obj.dirty) {
                      // Item was marked as deleted but not yet synced
                      // We need to create this item as usual, but just not add it to individual arrays
                      // i.e add to this.items but not this.notes (so that it can be retrieved with getDirtyItems)
                      isDirtyItemPendingDelete = true;
                    } else {
                      if (item) {
                        modelsToNotifyObserversOf.push(item);
                        this.removeItemLocally(item);
                      }

                      continue;
                    }
                  }

                  if (!item) {
                    item = this.createItem(json_obj, true);
                  }

                  this.addItem(item, isDirtyItemPendingDelete); // Observers do not need to handle items that errored while decrypting.

                  if (!item.errorDecrypting) {
                    modelsToNotifyObserversOf.push(item);
                  }

                  models.push(item);
                  processedObjects.push(json_obj);
                } // second loop should process references

              } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion12 && _iterator12.return) {
                    _iterator12.return();
                  }
                } finally {
                  if (_didIteratorError12) {
                    throw _iteratorError12;
                  }
                }
              }

              var _iteratorNormalCompletion13 = true;
              var _didIteratorError13 = false;
              var _iteratorError13 = undefined;

              try {
                for (var _iterator13 = processedObjects.entries()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                  var _ref36 = _step13.value;

                  var _ref37 = _slicedToArray(_ref36, 2);

                  var index = _ref37[0];
                  var _json_obj = _ref37[1];
                  var model = models[index];

                  if (_json_obj.content) {
                    this.resolveReferencesForItem(model);
                  }

                  model.didFinishSyncing();
                }
              } catch (err) {
                _didIteratorError13 = true;
                _iteratorError13 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion13 && _iterator13.return) {
                    _iterator13.return();
                  }
                } finally {
                  if (_didIteratorError13) {
                    throw _iteratorError13;
                  }
                }
              }

              var missedRefs = this.popMissedReferenceStructsForObjects(processedObjects);

              var _loop = function _loop(ref) {
                var model = models.find(function (candidate) {
                  return candidate.uuid == ref.reference_uuid;
                }); // Model should 100% be defined here, but let's not be too overconfident

                if (model) {
                  var itemWaitingForTheValueInThisCurrentLoop = ref.for_item;
                  itemWaitingForTheValueInThisCurrentLoop.addItemAsRelationship(model);
                }
              };

              var _iteratorNormalCompletion14 = true;
              var _didIteratorError14 = false;
              var _iteratorError14 = undefined;

              try {
                for (var _iterator14 = missedRefs[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                  var ref = _step14.value;

                  _loop(ref);
                }
              } catch (err) {
                _didIteratorError14 = true;
                _iteratorError14 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion14 && _iterator14.return) {
                    _iterator14.return();
                  }
                } finally {
                  if (_didIteratorError14) {
                    throw _iteratorError14;
                  }
                }
              }

              this.notifySyncObserversOfModels(modelsToNotifyObserversOf, source, sourceKey);
              return models;
            }
          }, {
            key: "missedReferenceBuildKey",
            value: function missedReferenceBuildKey(referenceId, objectId) {
              return referenceId + ":" + objectId;
            }
          }, {
            key: "popMissedReferenceStructsForObjects",
            value: function popMissedReferenceStructsForObjects(objects) {
              if (!objects || objects.length == 0) {
                return [];
              }

              var results = [];
              var toDelete = [];
              var uuids = objects.map(function (item) {
                return item.uuid;
              });
              var genericUuidLength = uuids[0].length;
              var keys = Object.keys(this.missedReferences);
              var _iteratorNormalCompletion16 = true;
              var _didIteratorError16 = false;
              var _iteratorError16 = undefined;

              try {
                for (var _iterator16 = keys[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                  var candidateKey = _step16.value;
                  /*
                  We used to do string.split to get at the UUID, but surprisingly,
                  the performance of this was about 20x worse then just getting the substring.
                   let matches = candidateKey.split(":")[0] == object.uuid;
                  */

                  var matches = uuids.includes(candidateKey.substring(0, genericUuidLength));

                  if (matches) {
                    results.push(this.missedReferences[candidateKey]);
                    toDelete.push(candidateKey);
                  }
                } // remove from hash

              } catch (err) {
                _didIteratorError16 = true;
                _iteratorError16 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion16 && _iterator16.return) {
                    _iterator16.return();
                  }
                } finally {
                  if (_didIteratorError16) {
                    throw _iteratorError16;
                  }
                }
              }

              var _iteratorNormalCompletion17 = true;
              var _didIteratorError17 = false;
              var _iteratorError17 = undefined;

              try {
                for (var _iterator17 = toDelete[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                  var key = _step17.value;
                  delete this.missedReferences[key];
                }
              } catch (err) {
                _didIteratorError17 = true;
                _iteratorError17 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion17 && _iterator17.return) {
                    _iterator17.return();
                  }
                } finally {
                  if (_didIteratorError17) {
                    throw _iteratorError17;
                  }
                }
              }

              return results;
            }
          }, {
            key: "resolveReferencesForItem",
            value: function resolveReferencesForItem(item) {
              var markReferencesDirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              if (item.errorDecrypting) {
                return;
              } // console.log("resolveReferencesForItem", item, "references", item.contentObject.references);


              var contentObject = item.contentObject; // If another client removes an item's references, this client won't pick up the removal unless
              // we remove everything not present in the current list of references

              item.updateLocalRelationships();

              if (!contentObject.references) {
                return;
              }

              var references = contentObject.references.slice(); // make copy, references will be modified in array

              var referencesIds = references.map(function (ref) {
                return ref.uuid;
              });
              var includeBlanks = true;
              var referencesObjectResults = this.findItems(referencesIds, includeBlanks);
              var _iteratorNormalCompletion18 = true;
              var _didIteratorError18 = false;
              var _iteratorError18 = undefined;

              try {
                for (var _iterator18 = referencesObjectResults.entries()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                  var _ref38 = _step18.value;

                  var _ref39 = _slicedToArray(_ref38, 2);

                  var index = _ref39[0];
                  var referencedItem = _ref39[1];

                  if (referencedItem) {
                    item.addItemAsRelationship(referencedItem);

                    if (markReferencesDirty) {
                      referencedItem.setDirty(true);
                    }
                  } else {
                    var missingRefId = referencesIds[index]; // Allows mapper to check when missing reference makes it through the loop,
                    // and then runs resolveReferencesForItem again for the original item.

                    var mappingKey = this.missedReferenceBuildKey(missingRefId, item.uuid);

                    if (!this.missedReferences[mappingKey]) {
                      var missedRef = {
                        reference_uuid: missingRefId,
                        for_item: item
                      };
                      this.missedReferences[mappingKey] = missedRef;
                    }
                  }
                }
              } catch (err) {
                _didIteratorError18 = true;
                _iteratorError18 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion18 && _iterator18.return) {
                    _iterator18.return();
                  }
                } finally {
                  if (_didIteratorError18) {
                    throw _iteratorError18;
                  }
                }
              }
            }
            /* Note that this function is public, and can also be called manually (desktopManager uses it) */

          }, {
            key: "notifySyncObserversOfModels",
            value: function notifySyncObserversOfModels(models, source, sourceKey) {
              var _this9 = this; // Make sure `let` is used in the for loops instead of `var`, as we will be using a timeout below.


              var observers = this.itemSyncObservers.sort(function (a, b) {
                // sort by priority
                return a.priority < b.priority ? -1 : 1;
              });

              var _loop2 = function _loop2(observer) {
                var allRelevantItems = observer.types.includes("*") ? models : models.filter(function (item) {
                  return observer.types.includes(item.content_type);
                });
                var validItems = [],
                    deletedItems = [];
                var _iteratorNormalCompletion20 = true;
                var _didIteratorError20 = false;
                var _iteratorError20 = undefined;

                try {
                  for (var _iterator20 = allRelevantItems[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                    var item = _step20.value;

                    if (item.deleted) {
                      deletedItems.push(item);
                    } else {
                      validItems.push(item);
                    }
                  }
                } catch (err) {
                  _didIteratorError20 = true;
                  _iteratorError20 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion20 && _iterator20.return) {
                      _iterator20.return();
                    }
                  } finally {
                    if (_didIteratorError20) {
                      throw _iteratorError20;
                    }
                  }
                }

                if (allRelevantItems.length > 0) {
                  _this9._callSyncObserverCallbackWithTimeout(observer, allRelevantItems, validItems, deletedItems, source, sourceKey);
                }
              };

              var _iteratorNormalCompletion19 = true;
              var _didIteratorError19 = false;
              var _iteratorError19 = undefined;

              try {
                for (var _iterator19 = observers[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                  var observer = _step19.value;

                  _loop2(observer);
                }
              } catch (err) {
                _didIteratorError19 = true;
                _iteratorError19 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion19 && _iterator19.return) {
                    _iterator19.return();
                  }
                } finally {
                  if (_didIteratorError19) {
                    throw _iteratorError19;
                  }
                }
              }
            }
            /*
              Rather than running this inline in a for loop, which causes problems and requires all variables to be declared with `let`,
              we'll do it here so it's more explicit and less confusing.
             */

          }, {
            key: "_callSyncObserverCallbackWithTimeout",
            value: function _callSyncObserverCallbackWithTimeout(observer, allRelevantItems, validItems, deletedItems, source, sourceKey) {
              this.$timeout(function () {
                observer.callback(allRelevantItems, validItems, deletedItems, source, sourceKey);
              });
            }
          }, {
            key: "createItem",
            value: function createItem(json_obj, dontNotifyObservers) {
              var itemClass = SFModelManager.ContentTypeClassMapping && SFModelManager.ContentTypeClassMapping[json_obj.content_type];

              if (!itemClass) {
                itemClass = SFItem;
              }

              var item = new itemClass(json_obj); // Some observers would be interested to know when an an item is locally created
              // If we don't send this out, these observers would have to wait until MappingSourceRemoteSaved
              // to hear about it, but sometimes, RemoveSaved is explicitly ignored by the observer to avoid
              // recursive callbacks. See componentManager's syncObserver callback.
              // dontNotifyObservers is currently only set true by modelManagers mapResponseItemsToLocalModels

              if (!dontNotifyObservers) {
                this.notifySyncObserversOfModels([item], SFModelManager.MappingSourceLocalSaved);
              }

              return item;
            }
            /*
              Be sure itemResponse is a generic Javascript object, and not an Item.
              An Item needs to collapse its properties into its content object before it can be duplicated.
              Note: the reason we need this function is specificallty for the call to resolveReferencesForItem.
              This method creates but does not add the item to the global inventory. It's used by syncManager
              to check if this prospective duplicate item is identical to another item, including the references.
             */

          }, {
            key: "createConflictedItem",
            value: function () {
              var _ref40 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee35(itemResponse) {
                var uuid, dup;
                return regeneratorRuntime.wrap(function _callee35$(_context35) {
                  while (1) {
                    switch (_context35.prev = _context35.next) {
                      case 0:
                        _context35.next = 2;
                        return SFJS.crypto.generateUUID();

                      case 2:
                        uuid = _context35.sent;
                        itemResponse = _.merge(itemResponse, {
                          uuid: uuid
                        });
                        dup = this.createItem(itemResponse, true);
                        return _context35.abrupt("return", dup);

                      case 6:
                      case "end":
                        return _context35.stop();
                    }
                  }
                }, _callee35, this);
              }));

              function createConflictedItem(_x62) {
                return _ref40.apply(this, arguments);
              }

              return createConflictedItem;
            }()
          }, {
            key: "addConflictedItem",
            value: function addConflictedItem(dup, original) {
              this.addItem(dup); // the duplicate should inherit the original's relationships

              var _iteratorNormalCompletion21 = true;
              var _didIteratorError21 = false;
              var _iteratorError21 = undefined;

              try {
                for (var _iterator21 = original.referencingObjects[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                  var referencingObject = _step21.value;
                  referencingObject.addItemAsRelationship(dup);
                  referencingObject.setDirty(true);
                }
              } catch (err) {
                _didIteratorError21 = true;
                _iteratorError21 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion21 && _iterator21.return) {
                    _iterator21.return();
                  }
                } finally {
                  if (_didIteratorError21) {
                    throw _iteratorError21;
                  }
                }
              }

              this.resolveReferencesForItem(dup);
              dup.content.conflict_of = original.uuid;
              dup.setDirty(true);
            }
          }, {
            key: "duplicateItem",
            value: function duplicateItem(item) {
              var copy = new item.constructor({
                content: item.content
              });
              copy.created_at = item.created_at;
              copy.content_type = item.content_type;
              this.addItem(copy); // the duplicate should inherit the original's relationships

              var _iteratorNormalCompletion22 = true;
              var _didIteratorError22 = false;
              var _iteratorError22 = undefined;

              try {
                for (var _iterator22 = item.referencingObjects[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                  var referencingObject = _step22.value;
                  referencingObject.addItemAsRelationship(copy);
                  referencingObject.setDirty(true);
                }
              } catch (err) {
                _didIteratorError22 = true;
                _iteratorError22 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion22 && _iterator22.return) {
                    _iterator22.return();
                  }
                } finally {
                  if (_didIteratorError22) {
                    throw _iteratorError22;
                  }
                }
              }

              this.resolveReferencesForItem(copy);
              copy.setDirty(true);
              return copy;
            }
          }, {
            key: "addItem",
            value: function addItem(item) {
              var globalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              this.addItems([item], globalOnly);
            }
          }, {
            key: "addItems",
            value: function addItems(items) {
              var _this10 = this;

              var globalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              items.forEach(function (item) {
                if (!_this10.itemsHash[item.uuid]) {
                  _this10.itemsHash[item.uuid] = item;

                  _this10.items.push(item);
                }
              });
            }
            /* Notifies observers when an item has been synced or mapped from a remote response */

          }, {
            key: "addItemSyncObserver",
            value: function addItemSyncObserver(id, types, callback) {
              this.addItemSyncObserverWithPriority({
                id: id,
                types: types,
                callback: callback,
                priority: 1
              });
            }
          }, {
            key: "addItemSyncObserverWithPriority",
            value: function addItemSyncObserverWithPriority(_ref41) {
              var id = _ref41.id,
                  priority = _ref41.priority,
                  types = _ref41.types,
                  callback = _ref41.callback;

              if (!Array.isArray(types)) {
                types = [types];
              }

              this.itemSyncObservers.push({
                id: id,
                types: types,
                priority: priority,
                callback: callback
              });
            }
          }, {
            key: "removeItemSyncObserver",
            value: function removeItemSyncObserver(id) {
              _.remove(this.itemSyncObservers, _.find(this.itemSyncObservers, {
                id: id
              }));
            }
          }, {
            key: "getDirtyItems",
            value: function getDirtyItems() {
              return this.items.filter(function (item) {
                // An item that has an error decrypting can be synced only if it is being deleted.
                // Otherwise, we don't want to send corrupt content up to the server.
                return item.dirty == true && !item.dummy && (!item.errorDecrypting || item.deleted);
              });
            }
          }, {
            key: "clearDirtyItems",
            value: function clearDirtyItems(items) {
              var _iteratorNormalCompletion23 = true;
              var _didIteratorError23 = false;
              var _iteratorError23 = undefined;

              try {
                for (var _iterator23 = items[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                  var item = _step23.value;
                  item.setDirty(false);
                }
              } catch (err) {
                _didIteratorError23 = true;
                _iteratorError23 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion23 && _iterator23.return) {
                    _iterator23.return();
                  }
                } finally {
                  if (_didIteratorError23) {
                    throw _iteratorError23;
                  }
                }
              }
            }
          }, {
            key: "setItemToBeDeleted",
            value: function setItemToBeDeleted(item) {
              item.deleted = true;

              if (!item.dummy) {
                item.setDirty(true);
              }

              this.removeAndDirtyAllRelationshipsForItem(item);
            }
          }, {
            key: "removeAndDirtyAllRelationshipsForItem",
            value: function removeAndDirtyAllRelationshipsForItem(item) {
              // Handle direct relationships
              // An item with errorDecrypting will not have valid content field
              if (!item.errorDecrypting) {
                var _iteratorNormalCompletion24 = true;
                var _didIteratorError24 = false;
                var _iteratorError24 = undefined;

                try {
                  for (var _iterator24 = item.content.references[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                    var reference = _step24.value;
                    var relationship = this.findItem(reference.uuid);

                    if (relationship) {
                      item.removeItemAsRelationship(relationship);

                      if (relationship.hasRelationshipWithItem(item)) {
                        relationship.removeItemAsRelationship(item);
                        relationship.setDirty(true);
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError24 = true;
                  _iteratorError24 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion24 && _iterator24.return) {
                      _iterator24.return();
                    }
                  } finally {
                    if (_didIteratorError24) {
                      throw _iteratorError24;
                    }
                  }
                }
              } // Handle indirect relationships


              var _iteratorNormalCompletion25 = true;
              var _didIteratorError25 = false;
              var _iteratorError25 = undefined;

              try {
                for (var _iterator25 = item.referencingObjects[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                  var object = _step25.value;
                  object.removeItemAsRelationship(item);
                  object.setDirty(true);
                }
              } catch (err) {
                _didIteratorError25 = true;
                _iteratorError25 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion25 && _iterator25.return) {
                    _iterator25.return();
                  }
                } finally {
                  if (_didIteratorError25) {
                    throw _iteratorError25;
                  }
                }
              }

              item.referencingObjects = [];
            }
            /* Used when changing encryption key */

          }, {
            key: "setAllItemsDirty",
            value: function setAllItemsDirty() {
              var dontUpdateClientDates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
              var relevantItems = this.allItems;
              var _iteratorNormalCompletion26 = true;
              var _didIteratorError26 = false;
              var _iteratorError26 = undefined;

              try {
                for (var _iterator26 = relevantItems[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
                  var item = _step26.value;
                  item.setDirty(true, dontUpdateClientDates);
                }
              } catch (err) {
                _didIteratorError26 = true;
                _iteratorError26 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion26 && _iterator26.return) {
                    _iterator26.return();
                  }
                } finally {
                  if (_didIteratorError26) {
                    throw _iteratorError26;
                  }
                }
              }
            }
          }, {
            key: "removeItemLocally",
            value: function () {
              var _ref42 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee36(item) {
                return regeneratorRuntime.wrap(function _callee36$(_context36) {
                  while (1) {
                    switch (_context36.prev = _context36.next) {
                      case 0:
                        _.remove(this.items, {
                          uuid: item.uuid
                        });

                        delete this.itemsHash[item.uuid];
                        item.isBeingRemovedLocally();
                        this.itemsPendingRemoval.push(item.uuid);

                      case 4:
                      case "end":
                        return _context36.stop();
                    }
                  }
                }, _callee36, this);
              }));

              function removeItemLocally(_x66) {
                return _ref42.apply(this, arguments);
              }

              return removeItemLocally;
            }()
            /* Searching */

          }, {
            key: "allItemsMatchingTypes",
            value: function allItemsMatchingTypes(contentTypes) {
              return this.allItems.filter(function (item) {
                return (_.includes(contentTypes, item.content_type) || _.includes(contentTypes, "*")) && !item.dummy;
              });
            }
          }, {
            key: "invalidItems",
            value: function invalidItems() {
              return this.allItems.filter(function (item) {
                return item.errorDecrypting;
              });
            }
          }, {
            key: "validItemsForContentType",
            value: function validItemsForContentType(contentType) {
              return this.allItems.filter(function (item) {
                return item.content_type == contentType && !item.errorDecrypting;
              });
            }
          }, {
            key: "findItem",
            value: function findItem(itemId) {
              return this.itemsHash[itemId];
            }
          }, {
            key: "findItems",
            value: function findItems(ids) {
              var includeBlanks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var results = [];
              var _iteratorNormalCompletion27 = true;
              var _didIteratorError27 = false;
              var _iteratorError27 = undefined;

              try {
                for (var _iterator27 = ids[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                  var id = _step27.value;
                  var item = this.itemsHash[id];

                  if (item || includeBlanks) {
                    results.push(item);
                  }
                }
              } catch (err) {
                _didIteratorError27 = true;
                _iteratorError27 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion27 && _iterator27.return) {
                    _iterator27.return();
                  }
                } finally {
                  if (_didIteratorError27) {
                    throw _iteratorError27;
                  }
                }
              }

              return results;
            }
          }, {
            key: "itemsMatchingPredicate",
            value: function itemsMatchingPredicate(predicate) {
              return this.itemsMatchingPredicates([predicate]);
            }
          }, {
            key: "itemsMatchingPredicates",
            value: function itemsMatchingPredicates(predicates) {
              return this.filterItemsWithPredicates(this.allItems, predicates);
            }
          }, {
            key: "filterItemsWithPredicates",
            value: function filterItemsWithPredicates(items, predicates) {
              var results = items.filter(function (item) {
                var _iteratorNormalCompletion28 = true;
                var _didIteratorError28 = false;
                var _iteratorError28 = undefined;

                try {
                  for (var _iterator28 = predicates[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                    var predicate = _step28.value;

                    if (!item.satisfiesPredicate(predicate)) {
                      return false;
                    }
                  }
                } catch (err) {
                  _didIteratorError28 = true;
                  _iteratorError28 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion28 && _iterator28.return) {
                      _iterator28.return();
                    }
                  } finally {
                    if (_didIteratorError28) {
                      throw _iteratorError28;
                    }
                  }
                }

                return true;
              });
              return results;
            }
            /*
            Archives
            */

          }, {
            key: "importItems",
            value: function () {
              var _ref43 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee37(externalItems) {
                var itemsToBeMapped, _iteratorNormalCompletion29, _didIteratorError29, _iteratorError29, _iterator29, _step29, itemData, existing, dup, items, _iteratorNormalCompletion30, _didIteratorError30, _iteratorError30, _iterator30, _step30, item;

                return regeneratorRuntime.wrap(function _callee37$(_context37) {
                  while (1) {
                    switch (_context37.prev = _context37.next) {
                      case 0:
                        itemsToBeMapped = [];
                        _iteratorNormalCompletion29 = true;
                        _didIteratorError29 = false;
                        _iteratorError29 = undefined;
                        _context37.prev = 4;
                        _iterator29 = externalItems[Symbol.iterator]();

                      case 6:
                        if (_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done) {
                          _context37.next = 21;
                          break;
                        }

                        itemData = _step29.value;
                        existing = this.findItem(itemData.uuid);

                        if (!(existing && !existing.errorDecrypting)) {
                          _context37.next = 16;
                          break;
                        }

                        _context37.next = 12;
                        return this.createConflictedItem(itemData);

                      case 12:
                        dup = _context37.sent;

                        if (!itemData.deleted && !existing.isItemContentEqualWith(dup)) {
                          // Data differs
                          this.addConflictedItem(dup, existing);
                          itemsToBeMapped.push(dup);
                        }

                        _context37.next = 18;
                        break;

                      case 16:
                        // it doesn't exist, push it into items to be mapped
                        itemsToBeMapped.push(itemData);

                        if (existing && existing.errorDecrypting) {
                          existing.errorDecrypting = false;
                        }

                      case 18:
                        _iteratorNormalCompletion29 = true;
                        _context37.next = 6;
                        break;

                      case 21:
                        _context37.next = 27;
                        break;

                      case 23:
                        _context37.prev = 23;
                        _context37.t0 = _context37["catch"](4);
                        _didIteratorError29 = true;
                        _iteratorError29 = _context37.t0;

                      case 27:
                        _context37.prev = 27;
                        _context37.prev = 28;

                        if (!_iteratorNormalCompletion29 && _iterator29.return) {
                          _iterator29.return();
                        }

                      case 30:
                        _context37.prev = 30;

                        if (!_didIteratorError29) {
                          _context37.next = 33;
                          break;
                        }

                        throw _iteratorError29;

                      case 33:
                        return _context37.finish(30);

                      case 34:
                        return _context37.finish(27);

                      case 35:
                        items = this.mapResponseItemsToLocalModels(itemsToBeMapped, SFModelManager.MappingSourceFileImport);
                        _iteratorNormalCompletion30 = true;
                        _didIteratorError30 = false;
                        _iteratorError30 = undefined;
                        _context37.prev = 39;

                        for (_iterator30 = items[Symbol.iterator](); !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                          item = _step30.value;
                          item.setDirty(true, true);
                          item.deleted = false;
                        }

                        _context37.next = 47;
                        break;

                      case 43:
                        _context37.prev = 43;
                        _context37.t1 = _context37["catch"](39);
                        _didIteratorError30 = true;
                        _iteratorError30 = _context37.t1;

                      case 47:
                        _context37.prev = 47;
                        _context37.prev = 48;

                        if (!_iteratorNormalCompletion30 && _iterator30.return) {
                          _iterator30.return();
                        }

                      case 50:
                        _context37.prev = 50;

                        if (!_didIteratorError30) {
                          _context37.next = 53;
                          break;
                        }

                        throw _iteratorError30;

                      case 53:
                        return _context37.finish(50);

                      case 54:
                        return _context37.finish(47);

                      case 55:
                        return _context37.abrupt("return", items);

                      case 56:
                      case "end":
                        return _context37.stop();
                    }
                  }
                }, _callee37, this, [[4, 23, 27, 35], [28,, 30, 34], [39, 43, 47, 55], [48,, 50, 54]]);
              }));

              function importItems(_x68) {
                return _ref43.apply(this, arguments);
              }

              return importItems;
            }()
          }, {
            key: "getAllItemsJSONData",
            value: function () {
              var _ref44 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee38(keys, authParams, returnNullIfEmpty) {
                return regeneratorRuntime.wrap(function _callee38$(_context38) {
                  while (1) {
                    switch (_context38.prev = _context38.next) {
                      case 0:
                        return _context38.abrupt("return", this.getJSONDataForItems(this.allItems, keys, authParams, returnNullIfEmpty));

                      case 1:
                      case "end":
                        return _context38.stop();
                    }
                  }
                }, _callee38, this);
              }));

              function getAllItemsJSONData(_x69, _x70, _x71) {
                return _ref44.apply(this, arguments);
              }

              return getAllItemsJSONData;
            }()
          }, {
            key: "getJSONDataForItems",
            value: function () {
              var _ref45 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee39(items, keys, authParams, returnNullIfEmpty) {
                return regeneratorRuntime.wrap(function _callee39$(_context39) {
                  while (1) {
                    switch (_context39.prev = _context39.next) {
                      case 0:
                        return _context39.abrupt("return", Promise.all(items.map(function (item) {
                          var itemParams = new SFItemParams(item, keys, authParams);
                          return itemParams.paramsForExportFile();
                        })).then(function (items) {
                          if (returnNullIfEmpty && items.length == 0) {
                            return null;
                          }

                          var data = {
                            items: items
                          };

                          if (keys) {
                            // auth params are only needed when encrypted with a standard file key
                            data["auth_params"] = authParams;
                          }

                          return JSON.stringify(data, null, 2
                          /* pretty print */
                          );
                        }));

                      case 1:
                      case "end":
                        return _context39.stop();
                    }
                  }
                }, _callee39, this);
              }));

              function getJSONDataForItems(_x72, _x73, _x74, _x75) {
                return _ref45.apply(this, arguments);
              }

              return getJSONDataForItems;
            }()
          }, {
            key: "computeDataIntegrityHash",
            value: function () {
              var _ref46 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee40() {
                var items, dates, string, hash;
                return regeneratorRuntime.wrap(function _callee40$(_context40) {
                  while (1) {
                    switch (_context40.prev = _context40.next) {
                      case 0:
                        _context40.prev = 0;
                        items = this.allNondummyItems.sort(function (a, b) {
                          return b.updated_at - a.updated_at;
                        });
                        dates = items.map(function (item) {
                          return item.updatedAtTimestamp();
                        });
                        string = dates.join(",");
                        _context40.next = 6;
                        return SFJS.crypto.sha256(string);

                      case 6:
                        hash = _context40.sent;
                        return _context40.abrupt("return", hash);

                      case 10:
                        _context40.prev = 10;
                        _context40.t0 = _context40["catch"](0);
                        console.error("Error computing data integrity hash", _context40.t0);
                        return _context40.abrupt("return", null);

                      case 14:
                      case "end":
                        return _context40.stop();
                    }
                  }
                }, _callee40, this, [[0, 10]]);
              }));

              function computeDataIntegrityHash() {
                return _ref46.apply(this, arguments);
              }

              return computeDataIntegrityHash;
            }()
          }, {
            key: "allItems",
            get: function get() {
              return this.items.slice();
            }
          }, {
            key: "allNondummyItems",
            get: function get() {
              return this.items.filter(function (item) {
                return !item.dummy;
              });
            }
          }]);

          return SFModelManager;
        }();

        ;

        var SFPrivilegesManager = exports.SFPrivilegesManager = function () {
          function SFPrivilegesManager(modelManager, syncManager, singletonManager) {
            _classCallCheck(this, SFPrivilegesManager);

            this.modelManager = modelManager;
            this.syncManager = syncManager;
            this.singletonManager = singletonManager;
            this.loadPrivileges();
            SFPrivilegesManager.CredentialAccountPassword = "CredentialAccountPassword";
            SFPrivilegesManager.CredentialLocalPasscode = "CredentialLocalPasscode";
            SFPrivilegesManager.ActionManageExtensions = "ActionManageExtensions";
            SFPrivilegesManager.ActionManageBackups = "ActionManageBackups";
            SFPrivilegesManager.ActionViewProtectedNotes = "ActionViewProtectedNotes";
            SFPrivilegesManager.ActionManagePrivileges = "ActionManagePrivileges";
            SFPrivilegesManager.ActionManagePasscode = "ActionManagePasscode";
            SFPrivilegesManager.ActionDeleteNote = "ActionDeleteNote";
            SFPrivilegesManager.SessionExpiresAtKey = "SessionExpiresAtKey";
            SFPrivilegesManager.SessionLengthKey = "SessionLengthKey";
            SFPrivilegesManager.SessionLengthNone = 0;
            SFPrivilegesManager.SessionLengthFiveMinutes = 300;
            SFPrivilegesManager.SessionLengthOneHour = 3600;
            SFPrivilegesManager.SessionLengthOneWeek = 604800;
            this.availableActions = [SFPrivilegesManager.ActionViewProtectedNotes, SFPrivilegesManager.ActionDeleteNote, SFPrivilegesManager.ActionManagePasscode, SFPrivilegesManager.ActionManageBackups, SFPrivilegesManager.ActionManageExtensions, SFPrivilegesManager.ActionManagePrivileges];
            this.availableCredentials = [SFPrivilegesManager.CredentialAccountPassword, SFPrivilegesManager.CredentialLocalPasscode];
            this.sessionLengths = [SFPrivilegesManager.SessionLengthNone, SFPrivilegesManager.SessionLengthFiveMinutes, SFPrivilegesManager.SessionLengthOneHour, SFPrivilegesManager.SessionLengthOneWeek, SFPrivilegesManager.SessionLengthIndefinite];
          }
          /*
          async delegate.isOffline()
          async delegate.hasLocalPasscode()
          async delegate.saveToStorage(key, value)
          async delegate.getFromStorage(key)
          async delegate.verifyAccountPassword
          async delegate.verifyLocalPasscode
          */


          _createClass(SFPrivilegesManager, [{
            key: "setDelegate",
            value: function setDelegate(delegate) {
              this.delegate = delegate;
            }
          }, {
            key: "getAvailableActions",
            value: function getAvailableActions() {
              return this.availableActions;
            }
          }, {
            key: "getAvailableCredentials",
            value: function getAvailableCredentials() {
              return this.availableCredentials;
            }
          }, {
            key: "netCredentialsForAction",
            value: function () {
              var _ref47 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee41(action) {
                var credentials, netCredentials, _iteratorNormalCompletion31, _didIteratorError31, _iteratorError31, _iterator31, _step31, cred, isOffline, hasLocalPasscode;

                return regeneratorRuntime.wrap(function _callee41$(_context41) {
                  while (1) {
                    switch (_context41.prev = _context41.next) {
                      case 0:
                        _context41.next = 2;
                        return this.getPrivileges();

                      case 2:
                        _context41.t0 = action;
                        credentials = _context41.sent.getCredentialsForAction(_context41.t0);
                        netCredentials = [];
                        _iteratorNormalCompletion31 = true;
                        _didIteratorError31 = false;
                        _iteratorError31 = undefined;
                        _context41.prev = 8;
                        _iterator31 = credentials[Symbol.iterator]();

                      case 10:
                        if (_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done) {
                          _context41.next = 27;
                          break;
                        }

                        cred = _step31.value;

                        if (!(cred == SFPrivilegesManager.CredentialAccountPassword)) {
                          _context41.next = 19;
                          break;
                        }

                        _context41.next = 15;
                        return this.delegate.isOffline();

                      case 15:
                        isOffline = _context41.sent;

                        if (!isOffline) {
                          netCredentials.push(cred);
                        }

                        _context41.next = 24;
                        break;

                      case 19:
                        if (!(cred == SFPrivilegesManager.CredentialLocalPasscode)) {
                          _context41.next = 24;
                          break;
                        }

                        _context41.next = 22;
                        return this.delegate.hasLocalPasscode();

                      case 22:
                        hasLocalPasscode = _context41.sent;

                        if (hasLocalPasscode) {
                          netCredentials.push(cred);
                        }

                      case 24:
                        _iteratorNormalCompletion31 = true;
                        _context41.next = 10;
                        break;

                      case 27:
                        _context41.next = 33;
                        break;

                      case 29:
                        _context41.prev = 29;
                        _context41.t1 = _context41["catch"](8);
                        _didIteratorError31 = true;
                        _iteratorError31 = _context41.t1;

                      case 33:
                        _context41.prev = 33;
                        _context41.prev = 34;

                        if (!_iteratorNormalCompletion31 && _iterator31.return) {
                          _iterator31.return();
                        }

                      case 36:
                        _context41.prev = 36;

                        if (!_didIteratorError31) {
                          _context41.next = 39;
                          break;
                        }

                        throw _iteratorError31;

                      case 39:
                        return _context41.finish(36);

                      case 40:
                        return _context41.finish(33);

                      case 41:
                        return _context41.abrupt("return", netCredentials);

                      case 42:
                      case "end":
                        return _context41.stop();
                    }
                  }
                }, _callee41, this, [[8, 29, 33, 41], [34,, 36, 40]]);
              }));

              function netCredentialsForAction(_x76) {
                return _ref47.apply(this, arguments);
              }

              return netCredentialsForAction;
            }()
          }, {
            key: "loadPrivileges",
            value: function () {
              var _ref48 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee43() {
                var _this11 = this;

                return regeneratorRuntime.wrap(function _callee43$(_context43) {
                  while (1) {
                    switch (_context43.prev = _context43.next) {
                      case 0:
                        if (!this.loadPromise) {
                          _context43.next = 2;
                          break;
                        }

                        return _context43.abrupt("return", this.loadPromise);

                      case 2:
                        this.loadPromise = new Promise(function (resolve, reject) {
                          var privsContentType = SFPrivileges.contentType();
                          var contentTypePredicate = new SFPredicate("content_type", "=", privsContentType);

                          _this11.singletonManager.registerSingleton([contentTypePredicate], function (resolvedSingleton) {
                            _this11.privileges = resolvedSingleton;
                            resolve(resolvedSingleton);
                          }, function () {
                            var _ref49 = _asyncToGenerator(
                            /*#__PURE__*/
                            regeneratorRuntime.mark(function _callee42(valueCallback) {
                              var privs;
                              return regeneratorRuntime.wrap(function _callee42$(_context42) {
                                while (1) {
                                  switch (_context42.prev = _context42.next) {
                                    case 0:
                                      // Safe to create. Create and return object.
                                      privs = new SFPrivileges({
                                        content_type: privsContentType
                                      });

                                      if (SFJS.crypto.generateUUIDSync) {
                                        _context42.next = 4;
                                        break;
                                      }

                                      _context42.next = 4;
                                      return privs.initUUID();

                                    case 4:
                                      _this11.modelManager.addItem(privs);

                                      privs.setDirty(true);

                                      _this11.syncManager.sync();

                                      valueCallback(privs);
                                      resolve(privs);

                                    case 9:
                                    case "end":
                                      return _context42.stop();
                                  }
                                }
                              }, _callee42, _this11);
                            }));

                            return function (_x77) {
                              return _ref49.apply(this, arguments);
                            };
                          }());
                        });
                        return _context43.abrupt("return", this.loadPromise);

                      case 4:
                      case "end":
                        return _context43.stop();
                    }
                  }
                }, _callee43, this);
              }));

              function loadPrivileges() {
                return _ref48.apply(this, arguments);
              }

              return loadPrivileges;
            }()
          }, {
            key: "getPrivileges",
            value: function () {
              var _ref50 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee44() {
                return regeneratorRuntime.wrap(function _callee44$(_context44) {
                  while (1) {
                    switch (_context44.prev = _context44.next) {
                      case 0:
                        if (!this.privileges) {
                          _context44.next = 4;
                          break;
                        }

                        return _context44.abrupt("return", this.privileges);

                      case 4:
                        return _context44.abrupt("return", this.loadPrivileges());

                      case 5:
                      case "end":
                        return _context44.stop();
                    }
                  }
                }, _callee44, this);
              }));

              function getPrivileges() {
                return _ref50.apply(this, arguments);
              }

              return getPrivileges;
            }()
          }, {
            key: "displayInfoForCredential",
            value: function displayInfoForCredential(credential) {
              var metadata = {};
              metadata[SFPrivilegesManager.CredentialAccountPassword] = {
                label: "Account Password",
                prompt: "Please enter your account password."
              };
              metadata[SFPrivilegesManager.CredentialLocalPasscode] = {
                label: "Local Passcode",
                prompt: "Please enter your local passcode."
              };
              return metadata[credential];
            }
          }, {
            key: "displayInfoForAction",
            value: function displayInfoForAction(action) {
              var metadata = {};
              metadata[SFPrivilegesManager.ActionManageExtensions] = {
                label: "Manage Extensions"
              };
              metadata[SFPrivilegesManager.ActionManageBackups] = {
                label: "Download/Import Backups"
              };
              metadata[SFPrivilegesManager.ActionViewProtectedNotes] = {
                label: "View Protected Notes"
              };
              metadata[SFPrivilegesManager.ActionManagePrivileges] = {
                label: "Manage Privileges"
              };
              metadata[SFPrivilegesManager.ActionManagePasscode] = {
                label: "Manage Passcode"
              };
              metadata[SFPrivilegesManager.ActionDeleteNote] = {
                label: "Delete Notes"
              };
              return metadata[action];
            }
          }, {
            key: "getSessionLengthOptions",
            value: function getSessionLengthOptions() {
              return [{
                value: SFPrivilegesManager.SessionLengthNone,
                label: "Don't Remember"
              }, {
                value: SFPrivilegesManager.SessionLengthFiveMinutes,
                label: "5 Minutes"
              }, {
                value: SFPrivilegesManager.SessionLengthOneHour,
                label: "1 Hour"
              }, {
                value: SFPrivilegesManager.SessionLengthOneWeek,
                label: "1 Week"
              }];
            }
          }, {
            key: "setSessionLength",
            value: function () {
              var _ref51 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee45(length) {
                var addToNow, expiresAt;
                return regeneratorRuntime.wrap(function _callee45$(_context45) {
                  while (1) {
                    switch (_context45.prev = _context45.next) {
                      case 0:
                        addToNow = function addToNow(seconds) {
                          var date = new Date();
                          date.setSeconds(date.getSeconds() + seconds);
                          return date;
                        };

                        expiresAt = addToNow(length);
                        return _context45.abrupt("return", Promise.all([this.delegate.saveToStorage(SFPrivilegesManager.SessionExpiresAtKey, JSON.stringify(expiresAt)), this.delegate.saveToStorage(SFPrivilegesManager.SessionLengthKey, JSON.stringify(length))]));

                      case 3:
                      case "end":
                        return _context45.stop();
                    }
                  }
                }, _callee45, this);
              }));

              function setSessionLength(_x78) {
                return _ref51.apply(this, arguments);
              }

              return setSessionLength;
            }()
          }, {
            key: "clearSession",
            value: function () {
              var _ref52 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee46() {
                return regeneratorRuntime.wrap(function _callee46$(_context46) {
                  while (1) {
                    switch (_context46.prev = _context46.next) {
                      case 0:
                        return _context46.abrupt("return", this.setSessionLength(SFPrivilegesManager.SessionLengthNone));

                      case 1:
                      case "end":
                        return _context46.stop();
                    }
                  }
                }, _callee46, this);
              }));

              function clearSession() {
                return _ref52.apply(this, arguments);
              }

              return clearSession;
            }()
          }, {
            key: "getSelectedSessionLength",
            value: function () {
              var _ref53 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee47() {
                var length;
                return regeneratorRuntime.wrap(function _callee47$(_context47) {
                  while (1) {
                    switch (_context47.prev = _context47.next) {
                      case 0:
                        _context47.next = 2;
                        return this.delegate.getFromStorage(SFPrivilegesManager.SessionLengthKey);

                      case 2:
                        length = _context47.sent;

                        if (!length) {
                          _context47.next = 7;
                          break;
                        }

                        return _context47.abrupt("return", JSON.parse(length));

                      case 7:
                        return _context47.abrupt("return", SFPrivilegesManager.SessionLengthNone);

                      case 8:
                      case "end":
                        return _context47.stop();
                    }
                  }
                }, _callee47, this);
              }));

              function getSelectedSessionLength() {
                return _ref53.apply(this, arguments);
              }

              return getSelectedSessionLength;
            }()
          }, {
            key: "getSessionExpirey",
            value: function () {
              var _ref54 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee48() {
                var expiresAt;
                return regeneratorRuntime.wrap(function _callee48$(_context48) {
                  while (1) {
                    switch (_context48.prev = _context48.next) {
                      case 0:
                        _context48.next = 2;
                        return this.delegate.getFromStorage(SFPrivilegesManager.SessionExpiresAtKey);

                      case 2:
                        expiresAt = _context48.sent;

                        if (!expiresAt) {
                          _context48.next = 7;
                          break;
                        }

                        return _context48.abrupt("return", new Date(JSON.parse(expiresAt)));

                      case 7:
                        return _context48.abrupt("return", new Date());

                      case 8:
                      case "end":
                        return _context48.stop();
                    }
                  }
                }, _callee48, this);
              }));

              function getSessionExpirey() {
                return _ref54.apply(this, arguments);
              }

              return getSessionExpirey;
            }()
          }, {
            key: "actionHasPrivilegesConfigured",
            value: function () {
              var _ref55 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee49(action) {
                return regeneratorRuntime.wrap(function _callee49$(_context49) {
                  while (1) {
                    switch (_context49.prev = _context49.next) {
                      case 0:
                        _context49.next = 2;
                        return this.netCredentialsForAction(action);

                      case 2:
                        _context49.t0 = _context49.sent.length;
                        return _context49.abrupt("return", _context49.t0 > 0);

                      case 4:
                      case "end":
                        return _context49.stop();
                    }
                  }
                }, _callee49, this);
              }));

              function actionHasPrivilegesConfigured(_x79) {
                return _ref55.apply(this, arguments);
              }

              return actionHasPrivilegesConfigured;
            }()
          }, {
            key: "actionRequiresPrivilege",
            value: function () {
              var _ref56 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee50(action) {
                var expiresAt, netCredentials;
                return regeneratorRuntime.wrap(function _callee50$(_context50) {
                  while (1) {
                    switch (_context50.prev = _context50.next) {
                      case 0:
                        _context50.next = 2;
                        return this.getSessionExpirey();

                      case 2:
                        expiresAt = _context50.sent;

                        if (!(expiresAt > new Date())) {
                          _context50.next = 5;
                          break;
                        }

                        return _context50.abrupt("return", false);

                      case 5:
                        _context50.next = 7;
                        return this.netCredentialsForAction(action);

                      case 7:
                        netCredentials = _context50.sent;
                        return _context50.abrupt("return", netCredentials.length > 0);

                      case 9:
                      case "end":
                        return _context50.stop();
                    }
                  }
                }, _callee50, this);
              }));

              function actionRequiresPrivilege(_x80) {
                return _ref56.apply(this, arguments);
              }

              return actionRequiresPrivilege;
            }()
          }, {
            key: "savePrivileges",
            value: function () {
              var _ref57 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee51() {
                var privs;
                return regeneratorRuntime.wrap(function _callee51$(_context51) {
                  while (1) {
                    switch (_context51.prev = _context51.next) {
                      case 0:
                        _context51.next = 2;
                        return this.getPrivileges();

                      case 2:
                        privs = _context51.sent;
                        privs.setDirty(true);
                        this.syncManager.sync();

                      case 5:
                      case "end":
                        return _context51.stop();
                    }
                  }
                }, _callee51, this);
              }));

              function savePrivileges() {
                return _ref57.apply(this, arguments);
              }

              return savePrivileges;
            }()
          }, {
            key: "authenticateAction",
            value: function () {
              var _ref58 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee52(action, credentialAuthMapping) {
                var requiredCredentials, successfulCredentials, failedCredentials, _iteratorNormalCompletion32, _didIteratorError32, _iteratorError32, _iterator32, _step32, requiredCredential, passesAuth;

                return regeneratorRuntime.wrap(function _callee52$(_context52) {
                  while (1) {
                    switch (_context52.prev = _context52.next) {
                      case 0:
                        _context52.next = 2;
                        return this.netCredentialsForAction(action);

                      case 2:
                        requiredCredentials = _context52.sent;
                        successfulCredentials = [], failedCredentials = [];
                        _iteratorNormalCompletion32 = true;
                        _didIteratorError32 = false;
                        _iteratorError32 = undefined;
                        _context52.prev = 7;
                        _iterator32 = requiredCredentials[Symbol.iterator]();

                      case 9:
                        if (_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done) {
                          _context52.next = 18;
                          break;
                        }

                        requiredCredential = _step32.value;
                        _context52.next = 13;
                        return this._verifyAuthenticationParameters(requiredCredential, credentialAuthMapping[requiredCredential]);

                      case 13:
                        passesAuth = _context52.sent;

                        if (passesAuth) {
                          successfulCredentials.push(requiredCredential);
                        } else {
                          failedCredentials.push(requiredCredential);
                        }

                      case 15:
                        _iteratorNormalCompletion32 = true;
                        _context52.next = 9;
                        break;

                      case 18:
                        _context52.next = 24;
                        break;

                      case 20:
                        _context52.prev = 20;
                        _context52.t0 = _context52["catch"](7);
                        _didIteratorError32 = true;
                        _iteratorError32 = _context52.t0;

                      case 24:
                        _context52.prev = 24;
                        _context52.prev = 25;

                        if (!_iteratorNormalCompletion32 && _iterator32.return) {
                          _iterator32.return();
                        }

                      case 27:
                        _context52.prev = 27;

                        if (!_didIteratorError32) {
                          _context52.next = 30;
                          break;
                        }

                        throw _iteratorError32;

                      case 30:
                        return _context52.finish(27);

                      case 31:
                        return _context52.finish(24);

                      case 32:
                        return _context52.abrupt("return", {
                          success: failedCredentials.length == 0,
                          successfulCredentials: successfulCredentials,
                          failedCredentials: failedCredentials
                        });

                      case 33:
                      case "end":
                        return _context52.stop();
                    }
                  }
                }, _callee52, this, [[7, 20, 24, 32], [25,, 27, 31]]);
              }));

              function authenticateAction(_x81, _x82) {
                return _ref58.apply(this, arguments);
              }

              return authenticateAction;
            }()
          }, {
            key: "_verifyAuthenticationParameters",
            value: function () {
              var _ref59 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee55(credential, value) {
                var _this12 = this;

                var verifyAccountPassword, verifyLocalPasscode;
                return regeneratorRuntime.wrap(function _callee55$(_context55) {
                  while (1) {
                    switch (_context55.prev = _context55.next) {
                      case 0:
                        verifyAccountPassword = function () {
                          var _ref60 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee53(password) {
                            return regeneratorRuntime.wrap(function _callee53$(_context53) {
                              while (1) {
                                switch (_context53.prev = _context53.next) {
                                  case 0:
                                    return _context53.abrupt("return", _this12.delegate.verifyAccountPassword(password));

                                  case 1:
                                  case "end":
                                    return _context53.stop();
                                }
                              }
                            }, _callee53, _this12);
                          }));

                          return function verifyAccountPassword(_x85) {
                            return _ref60.apply(this, arguments);
                          };
                        }();

                        verifyLocalPasscode = function () {
                          var _ref61 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee54(passcode) {
                            return regeneratorRuntime.wrap(function _callee54$(_context54) {
                              while (1) {
                                switch (_context54.prev = _context54.next) {
                                  case 0:
                                    return _context54.abrupt("return", _this12.delegate.verifyLocalPasscode(passcode));

                                  case 1:
                                  case "end":
                                    return _context54.stop();
                                }
                              }
                            }, _callee54, _this12);
                          }));

                          return function verifyLocalPasscode(_x86) {
                            return _ref61.apply(this, arguments);
                          };
                        }();

                        if (!(credential == SFPrivilegesManager.CredentialAccountPassword)) {
                          _context55.next = 6;
                          break;
                        }

                        return _context55.abrupt("return", verifyAccountPassword(value));

                      case 6:
                        if (!(credential == SFPrivilegesManager.CredentialLocalPasscode)) {
                          _context55.next = 8;
                          break;
                        }

                        return _context55.abrupt("return", verifyLocalPasscode(value));

                      case 8:
                      case "end":
                        return _context55.stop();
                    }
                  }
                }, _callee55, this);
              }));

              function _verifyAuthenticationParameters(_x83, _x84) {
                return _ref59.apply(this, arguments);
              }

              return _verifyAuthenticationParameters;
            }()
          }]);

          return SFPrivilegesManager;
        }();

        ;
        var SessionHistoryPersistKey = "sessionHistory_persist";
        var SessionHistoryRevisionsKey = "sessionHistory_revisions";
        var SessionHistoryAutoOptimizeKey = "sessionHistory_autoOptimize";

        var SFSessionHistoryManager = exports.SFSessionHistoryManager = function () {
          function SFSessionHistoryManager(modelManager, storageManager, keyRequestHandler, contentTypes, timeout) {
            var _this13 = this;

            _classCallCheck(this, SFSessionHistoryManager);

            this.modelManager = modelManager;
            this.storageManager = storageManager;
            this.$timeout = timeout || setTimeout.bind(window); // Required to persist the encrypted form of SFHistorySession

            this.keyRequestHandler = keyRequestHandler;
            this.loadFromDisk().then(function () {
              _this13.modelManager.addItemSyncObserver("session-history", contentTypes, function (allItems, validItems, deletedItems, source, sourceKey) {
                var _iteratorNormalCompletion33 = true;
                var _didIteratorError33 = false;
                var _iteratorError33 = undefined;

                try {
                  for (var _iterator33 = allItems[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
                    var item = _step33.value;

                    try {
                      _this13.addHistoryEntryForItem(item);
                    } catch (e) {
                      console.log("Caught exception while trying to add item history entry", e);
                    }
                  }
                } catch (err) {
                  _didIteratorError33 = true;
                  _iteratorError33 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion33 && _iterator33.return) {
                      _iterator33.return();
                    }
                  } finally {
                    if (_didIteratorError33) {
                      throw _iteratorError33;
                    }
                  }
                }
              });
            });
          }

          _createClass(SFSessionHistoryManager, [{
            key: "encryptionParams",
            value: function () {
              var _ref62 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee56() {
                return regeneratorRuntime.wrap(function _callee56$(_context56) {
                  while (1) {
                    switch (_context56.prev = _context56.next) {
                      case 0:
                        return _context56.abrupt("return", this.keyRequestHandler());

                      case 1:
                      case "end":
                        return _context56.stop();
                    }
                  }
                }, _callee56, this);
              }));

              function encryptionParams() {
                return _ref62.apply(this, arguments);
              }

              return encryptionParams;
            }()
          }, {
            key: "addHistoryEntryForItem",
            value: function addHistoryEntryForItem(item) {
              var _this14 = this;

              var persistableItemParams = {
                uuid: item.uuid,
                content_type: item.content_type,
                updated_at: item.updated_at,
                content: item.content
              };
              var entry = this.historySession.addEntryForItem(persistableItemParams);

              if (this.autoOptimize) {
                this.historySession.optimizeHistoryForItem(item);
              }

              if (entry && this.diskEnabled) {
                // Debounce, clear existing timeout
                if (this.diskTimeout) {
                  if (this.$timeout.hasOwnProperty("cancel")) {
                    this.$timeout.cancel(this.diskTimeout);
                  } else {
                    clearTimeout(this.diskTimeout);
                  }
                }

                ;
                this.diskTimeout = this.$timeout(function () {
                  _this14.saveToDisk();
                }, 2000);
              }
            }
          }, {
            key: "historyForItem",
            value: function historyForItem(item) {
              return this.historySession.historyForItem(item);
            }
          }, {
            key: "clearHistoryForItem",
            value: function () {
              var _ref63 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee57(item) {
                return regeneratorRuntime.wrap(function _callee57$(_context57) {
                  while (1) {
                    switch (_context57.prev = _context57.next) {
                      case 0:
                        this.historySession.clearItemHistory(item);
                        return _context57.abrupt("return", this.saveToDisk());

                      case 2:
                      case "end":
                        return _context57.stop();
                    }
                  }
                }, _callee57, this);
              }));

              function clearHistoryForItem(_x87) {
                return _ref63.apply(this, arguments);
              }

              return clearHistoryForItem;
            }()
          }, {
            key: "clearAllHistory",
            value: function () {
              var _ref64 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee58() {
                return regeneratorRuntime.wrap(function _callee58$(_context58) {
                  while (1) {
                    switch (_context58.prev = _context58.next) {
                      case 0:
                        this.historySession.clearAllHistory();
                        return _context58.abrupt("return", this.storageManager.removeItem(SessionHistoryRevisionsKey));

                      case 2:
                      case "end":
                        return _context58.stop();
                    }
                  }
                }, _callee58, this);
              }));

              function clearAllHistory() {
                return _ref64.apply(this, arguments);
              }

              return clearAllHistory;
            }()
          }, {
            key: "toggleDiskSaving",
            value: function () {
              var _ref65 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee59() {
                return regeneratorRuntime.wrap(function _callee59$(_context59) {
                  while (1) {
                    switch (_context59.prev = _context59.next) {
                      case 0:
                        this.diskEnabled = !this.diskEnabled;

                        if (!this.diskEnabled) {
                          _context59.next = 6;
                          break;
                        }

                        this.storageManager.setItem(SessionHistoryPersistKey, JSON.stringify(true));
                        this.saveToDisk();
                        _context59.next = 8;
                        break;

                      case 6:
                        this.storageManager.setItem(SessionHistoryPersistKey, JSON.stringify(false));
                        return _context59.abrupt("return", this.storageManager.removeItem(SessionHistoryRevisionsKey));

                      case 8:
                      case "end":
                        return _context59.stop();
                    }
                  }
                }, _callee59, this);
              }));

              function toggleDiskSaving() {
                return _ref65.apply(this, arguments);
              }

              return toggleDiskSaving;
            }()
          }, {
            key: "saveToDisk",
            value: function () {
              var _ref66 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee60() {
                var _this15 = this;

                var encryptionParams, itemParams;
                return regeneratorRuntime.wrap(function _callee60$(_context60) {
                  while (1) {
                    switch (_context60.prev = _context60.next) {
                      case 0:
                        if (this.diskEnabled) {
                          _context60.next = 2;
                          break;
                        }

                        return _context60.abrupt("return");

                      case 2:
                        _context60.next = 4;
                        return this.encryptionParams();

                      case 4:
                        encryptionParams = _context60.sent;
                        itemParams = new SFItemParams(this.historySession, encryptionParams.keys, encryptionParams.auth_params);
                        itemParams.paramsForSync().then(function (syncParams) {
                          // console.log("Saving to disk", syncParams);
                          _this15.storageManager.setItem(SessionHistoryRevisionsKey, JSON.stringify(syncParams));
                        });

                      case 7:
                      case "end":
                        return _context60.stop();
                    }
                  }
                }, _callee60, this);
              }));

              function saveToDisk() {
                return _ref66.apply(this, arguments);
              }

              return saveToDisk;
            }()
          }, {
            key: "loadFromDisk",
            value: function () {
              var _ref67 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee61() {
                var diskValue, historyValue, encryptionParams, historySession, autoOptimizeValue;
                return regeneratorRuntime.wrap(function _callee61$(_context61) {
                  while (1) {
                    switch (_context61.prev = _context61.next) {
                      case 0:
                        _context61.next = 2;
                        return this.storageManager.getItem(SessionHistoryPersistKey);

                      case 2:
                        diskValue = _context61.sent;

                        if (diskValue) {
                          this.diskEnabled = JSON.parse(diskValue);
                        }

                        _context61.next = 6;
                        return this.storageManager.getItem(SessionHistoryRevisionsKey);

                      case 6:
                        historyValue = _context61.sent;

                        if (!historyValue) {
                          _context61.next = 18;
                          break;
                        }

                        historyValue = JSON.parse(historyValue);
                        _context61.next = 11;
                        return this.encryptionParams();

                      case 11:
                        encryptionParams = _context61.sent;
                        _context61.next = 14;
                        return SFJS.itemTransformer.decryptItem(historyValue, encryptionParams.keys);

                      case 14:
                        historySession = new SFHistorySession(historyValue);
                        this.historySession = historySession;
                        _context61.next = 19;
                        break;

                      case 18:
                        this.historySession = new SFHistorySession();

                      case 19:
                        _context61.next = 21;
                        return this.storageManager.getItem(SessionHistoryAutoOptimizeKey);

                      case 21:
                        autoOptimizeValue = _context61.sent;

                        if (autoOptimizeValue) {
                          this.autoOptimize = JSON.parse(autoOptimizeValue);
                        } else {
                          // default value is true
                          this.autoOptimize = true;
                        }

                      case 23:
                      case "end":
                        return _context61.stop();
                    }
                  }
                }, _callee61, this);
              }));

              function loadFromDisk() {
                return _ref67.apply(this, arguments);
              }

              return loadFromDisk;
            }()
          }, {
            key: "toggleAutoOptimize",
            value: function () {
              var _ref68 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee62() {
                return regeneratorRuntime.wrap(function _callee62$(_context62) {
                  while (1) {
                    switch (_context62.prev = _context62.next) {
                      case 0:
                        this.autoOptimize = !this.autoOptimize;

                        if (this.autoOptimize) {
                          this.storageManager.setItem(SessionHistoryAutoOptimizeKey, JSON.stringify(true));
                        } else {
                          this.storageManager.setItem(SessionHistoryAutoOptimizeKey, JSON.stringify(false));
                        }

                      case 2:
                      case "end":
                        return _context62.stop();
                    }
                  }
                }, _callee62, this);
              }));

              function toggleAutoOptimize() {
                return _ref68.apply(this, arguments);
              }

              return toggleAutoOptimize;
            }()
          }]);

          return SFSessionHistoryManager;
        }();

        ;
        /*
         The SingletonManager allows controllers to register an item as a singleton, which means only one instance of that model
         should exist, both on the server and on the client. When the SingletonManager detects multiple items matching the singleton predicate,
         the oldest ones will be deleted, leaving the newest ones. (See 4/28/18 update. We now choose the earliest created one as the winner.).
          (This no longer fully applies, See 4/28/18 update.) We will treat the model most recently arrived from the server as the most recent one. The reason for this is,
         if you're offline, a singleton can be created, as in the case of UserPreferneces. Then when you sign in, you'll retrieve your actual user preferences.
         In that case, even though the offline singleton has a more recent updated_at, the server retreived value is the one we care more about.
          4/28/18: I'm seeing this issue: if you have the app open in one window, then in another window sign in, and during sign in,
         click Refresh (or autorefresh occurs) in the original signed in window, then you will happen to receive from the server the newly created
         Extensions singleton, and it will be mistaken (it just looks like a regular retrieved item, since nothing is in saved) for a fresh, latest copy, and replace the current instance.
         This has happened to me and many users.
         A puzzling issue, but what if instead of resolving singletons by choosing the one most recently modified, we choose the one with the earliest create date?
         This way, we don't care when it was modified, but we always, always choose the item that was created first. This way, we always deal with the same item.
        */

        var SFSingletonManager = exports.SFSingletonManager = function () {
          function SFSingletonManager(modelManager, syncManager) {
            var _this16 = this;

            _classCallCheck(this, SFSingletonManager);

            this.syncManager = syncManager;
            this.modelManager = modelManager;
            this.singletonHandlers = []; // We use sync observer instead of syncEvent `local-data-incremental-load`, because we want singletons
            // to resolve with the first priority, because they generally dictate app state.
            // If we used local-data-incremental-load, and 1 item was important singleton and 99 were heavy components,
            // then given the random nature of notifiying observers, the heavy components would spend a lot of time loading first,
            // here, we priortize ours loading as most important

            modelManager.addItemSyncObserverWithPriority({
              id: "sf-singleton-manager",
              types: "*",
              priority: -1,
              callback: function callback() {
                _this16.resolveSingletons(modelManager.allNondummyItems, null, true);
              }
            });
            syncManager.addEventHandler(function (syncEvent, data) {
              if (syncEvent == "local-data-loaded") {
                _this16.resolveSingletons(modelManager.allNondummyItems, null, true);

                _this16.initialDataLoaded = true;
              } else if (syncEvent == "sync:completed") {
                // Wait for initial data load before handling any sync. If we don't want for initial data load,
                // then the singleton resolver won't have the proper items to work with to determine whether to resolve or create.
                if (!_this16.initialDataLoaded) {
                  return;
                } // The reason we also need to consider savedItems in consolidating singletons is in case of sync conflicts,
                // a new item can be created, but is never processed through "retrievedItems" since it is only created locally then saved.
                // HOWEVER, by considering savedItems, we are now ruining everything, especially during sign in. A singleton can be created
                // offline, and upon sign in, will sync all items to the server, and by combining retrievedItems & savedItems, and only choosing
                // the latest, you are now resolving to the most recent one, which is in the savedItems list and not retrieved items, defeating
                // the whole purpose of this thing.
                // Updated solution: resolveSingletons will now evaluate both of these arrays separately.


                _this16.resolveSingletons(data.retrievedItems, data.savedItems);
              }
            });
            /*
              If an item alternates its uuid on registration, singletonHandlers might need to update
              their local reference to the object, since the object reference will change on uuid alternation
            */

            modelManager.addModelUuidChangeObserver("singleton-manager", function (oldModel, newModel) {
              var _iteratorNormalCompletion34 = true;
              var _didIteratorError34 = false;
              var _iteratorError34 = undefined;

              try {
                for (var _iterator34 = _this16.singletonHandlers[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
                  var handler = _step34.value;

                  if (handler.singleton && SFPredicate.ItemSatisfiesPredicates(newModel, handler.predicates)) {
                    // Reference is now invalid, calling resolveSingleton should update it
                    handler.singleton = null;

                    _this16.resolveSingletons([newModel]);
                  }
                }
              } catch (err) {
                _didIteratorError34 = true;
                _iteratorError34 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion34 && _iterator34.return) {
                    _iterator34.return();
                  }
                } finally {
                  if (_didIteratorError34) {
                    throw _iteratorError34;
                  }
                }
              }
            });
          }

          _createClass(SFSingletonManager, [{
            key: "registerSingleton",
            value: function registerSingleton(predicates, resolveCallback, createBlock) {
              /*
              predicate: a key/value pair that specifies properties that should match in order for an item to be considered a predicate
              resolveCallback: called when one or more items are deleted and a new item becomes the reigning singleton
              createBlock: called when a sync is complete and no items are found. The createBlock should create the item and return it.
              */
              this.singletonHandlers.push({
                predicates: predicates,
                resolutionCallback: resolveCallback,
                createBlock: createBlock
              });
            }
          }, {
            key: "resolveSingletons",
            value: function resolveSingletons(retrievedItems, savedItems, initialLoad) {
              var _this17 = this;

              retrievedItems = retrievedItems || [];
              savedItems = savedItems || [];

              var _loop3 = function _loop3(singletonHandler) {
                var predicates = singletonHandler.predicates.slice();

                var retrievedSingletonItems = _this17.modelManager.filterItemsWithPredicates(retrievedItems, predicates);

                var handleCreation = function handleCreation() {
                  if (singletonHandler.createBlock) {
                    singletonHandler.pendingCreateBlockCallback = true;
                    singletonHandler.createBlock(function (created) {
                      singletonHandler.singleton = created;
                      singletonHandler.pendingCreateBlockCallback = false;
                      singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(created);
                    });
                  }
                }; // We only want to consider saved items count to see if it's more than 0, and do nothing else with it.
                // This way we know there was some action and things need to be resolved. The saved items will come up
                // in filterItemsWithPredicate(this.modelManager.allNondummyItems) and be deleted anyway


                var savedSingletonItemsCount = _this17.modelManager.filterItemsWithPredicates(savedItems, predicates).length;

                if (retrievedSingletonItems.length > 0 || savedSingletonItemsCount > 0) {
                  /*
                    Check local inventory and make sure only 1 similar item exists. If more than 1, delete newest
                    Note that this local inventory will also contain whatever is in retrievedItems.
                  */
                  var allExtantItemsMatchingPredicate = _this17.modelManager.itemsMatchingPredicates(predicates);
                  /*
                    Delete all but the earliest created
                  */


                  if (allExtantItemsMatchingPredicate.length >= 2) {
                    var sorted = allExtantItemsMatchingPredicate.sort(function (a, b) {
                      /*
                        If compareFunction(a, b) is less than 0, sort a to an index lower than b, i.e. a comes first.
                        If compareFunction(a, b) is greater than 0, sort b to an index lower than a, i.e. b comes first.
                      */
                      if (a.errorDecrypting) {
                        return 1;
                      }

                      if (b.errorDecrypting) {
                        return -1;
                      }

                      return a.created_at < b.created_at ? -1 : 1;
                    }); // The item that will be chosen to be kept

                    var winningItem = sorted[0]; // Items that will be deleted
                    // Delete everything but the first one

                    var toDelete = sorted.slice(1, sorted.length);
                    var _iteratorNormalCompletion36 = true;
                    var _didIteratorError36 = false;
                    var _iteratorError36 = undefined;

                    try {
                      for (var _iterator36 = toDelete[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
                        var d = _step36.value;

                        _this17.modelManager.setItemToBeDeleted(d);
                      }
                    } catch (err) {
                      _didIteratorError36 = true;
                      _iteratorError36 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion36 && _iterator36.return) {
                          _iterator36.return();
                        }
                      } finally {
                        if (_didIteratorError36) {
                          throw _iteratorError36;
                        }
                      }
                    }

                    _this17.syncManager.sync(); // Send remaining item to callback


                    singletonHandler.singleton = winningItem;
                    singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(winningItem);
                  } else if (allExtantItemsMatchingPredicate.length == 1) {
                    var singleton = allExtantItemsMatchingPredicate[0];

                    if (singleton.errorDecrypting) {
                      // Delete the current singleton and create a new one
                      _this17.modelManager.setItemToBeDeleted(singleton);

                      handleCreation();
                    } else if (!singletonHandler.singleton || singletonHandler.singleton !== singleton) {
                      // Not yet notified interested parties of object
                      singletonHandler.singleton = singleton;
                      singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(singleton);
                    }
                  }
                } else {
                  // Retrieved items does not include any items of interest. If we don't have a singleton registered to this handler,
                  // we need to create one. Only do this on actual sync completetions and not on initial data load. Because we want
                  // to get the latest from the server before making the decision to create a new item
                  if (!singletonHandler.singleton && !initialLoad && !singletonHandler.pendingCreateBlockCallback) {
                    handleCreation();
                  }
                }
              };

              var _iteratorNormalCompletion35 = true;
              var _didIteratorError35 = false;
              var _iteratorError35 = undefined;

              try {
                for (var _iterator35 = this.singletonHandlers[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
                  var singletonHandler = _step35.value;

                  _loop3(singletonHandler);
                }
              } catch (err) {
                _didIteratorError35 = true;
                _iteratorError35 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion35 && _iterator35.return) {
                    _iterator35.return();
                  }
                } finally {
                  if (_didIteratorError35) {
                    throw _iteratorError35;
                  }
                }
              }
            }
          }]);

          return SFSingletonManager;
        }();

        ; // SFStorageManager should be subclassed, and all the methods below overwritten.

        var SFStorageManager = exports.SFStorageManager = function () {
          function SFStorageManager() {
            _classCallCheck(this, SFStorageManager);
          }

          _createClass(SFStorageManager, [{
            key: "setItem",

            /* Simple Key/Value Storage */
            value: function () {
              var _ref69 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee63(key, value) {
                return regeneratorRuntime.wrap(function _callee63$(_context63) {
                  while (1) {
                    switch (_context63.prev = _context63.next) {
                      case 0:
                      case "end":
                        return _context63.stop();
                    }
                  }
                }, _callee63, this);
              }));

              function setItem(_x88, _x89) {
                return _ref69.apply(this, arguments);
              }

              return setItem;
            }()
          }, {
            key: "getItem",
            value: function () {
              var _ref70 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee64(key) {
                return regeneratorRuntime.wrap(function _callee64$(_context64) {
                  while (1) {
                    switch (_context64.prev = _context64.next) {
                      case 0:
                      case "end":
                        return _context64.stop();
                    }
                  }
                }, _callee64, this);
              }));

              function getItem(_x90) {
                return _ref70.apply(this, arguments);
              }

              return getItem;
            }()
          }, {
            key: "removeItem",
            value: function () {
              var _ref71 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee65(key) {
                return regeneratorRuntime.wrap(function _callee65$(_context65) {
                  while (1) {
                    switch (_context65.prev = _context65.next) {
                      case 0:
                      case "end":
                        return _context65.stop();
                    }
                  }
                }, _callee65, this);
              }));

              function removeItem(_x91) {
                return _ref71.apply(this, arguments);
              }

              return removeItem;
            }()
          }, {
            key: "clear",
            value: function () {
              var _ref72 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee66() {
                return regeneratorRuntime.wrap(function _callee66$(_context66) {
                  while (1) {
                    switch (_context66.prev = _context66.next) {
                      case 0:
                      case "end":
                        return _context66.stop();
                    }
                  }
                }, _callee66, this);
              }));

              function clear() {
                return _ref72.apply(this, arguments);
              }

              return clear;
            }()
          }, {
            key: "getAllModels",

            /*
            Model Storage
            */
            value: function () {
              var _ref73 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee67() {
                return regeneratorRuntime.wrap(function _callee67$(_context67) {
                  while (1) {
                    switch (_context67.prev = _context67.next) {
                      case 0:
                      case "end":
                        return _context67.stop();
                    }
                  }
                }, _callee67, this);
              }));

              function getAllModels() {
                return _ref73.apply(this, arguments);
              }

              return getAllModels;
            }()
          }, {
            key: "saveModel",
            value: function () {
              var _ref74 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee68(item) {
                return regeneratorRuntime.wrap(function _callee68$(_context68) {
                  while (1) {
                    switch (_context68.prev = _context68.next) {
                      case 0:
                        return _context68.abrupt("return", this.saveModels([item]));

                      case 1:
                      case "end":
                        return _context68.stop();
                    }
                  }
                }, _callee68, this);
              }));

              function saveModel(_x92) {
                return _ref74.apply(this, arguments);
              }

              return saveModel;
            }()
          }, {
            key: "saveModels",
            value: function () {
              var _ref75 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee69(items) {
                return regeneratorRuntime.wrap(function _callee69$(_context69) {
                  while (1) {
                    switch (_context69.prev = _context69.next) {
                      case 0:
                      case "end":
                        return _context69.stop();
                    }
                  }
                }, _callee69, this);
              }));

              function saveModels(_x93) {
                return _ref75.apply(this, arguments);
              }

              return saveModels;
            }()
          }, {
            key: "deleteModel",
            value: function () {
              var _ref76 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee70(item) {
                return regeneratorRuntime.wrap(function _callee70$(_context70) {
                  while (1) {
                    switch (_context70.prev = _context70.next) {
                      case 0:
                      case "end":
                        return _context70.stop();
                    }
                  }
                }, _callee70, this);
              }));

              function deleteModel(_x94) {
                return _ref76.apply(this, arguments);
              }

              return deleteModel;
            }()
          }, {
            key: "clearAllModels",
            value: function () {
              var _ref77 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee71() {
                return regeneratorRuntime.wrap(function _callee71$(_context71) {
                  while (1) {
                    switch (_context71.prev = _context71.next) {
                      case 0:
                      case "end":
                        return _context71.stop();
                    }
                  }
                }, _callee71, this);
              }));

              function clearAllModels() {
                return _ref77.apply(this, arguments);
              }

              return clearAllModels;
            }()
          }, {
            key: "clearAllData",

            /* General */
            value: function () {
              var _ref78 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee72() {
                return regeneratorRuntime.wrap(function _callee72$(_context72) {
                  while (1) {
                    switch (_context72.prev = _context72.next) {
                      case 0:
                        return _context72.abrupt("return", Promise.all([this.clear(), this.clearAllModels()]));

                      case 1:
                      case "end":
                        return _context72.stop();
                    }
                  }
                }, _callee72, this);
              }));

              function clearAllData() {
                return _ref78.apply(this, arguments);
              }

              return clearAllData;
            }()
          }]);

          return SFStorageManager;
        }();

        ;

        var SFSyncManager = exports.SFSyncManager = function () {
          function SFSyncManager(modelManager, storageManager, httpManager, timeout, interval) {
            _classCallCheck(this, SFSyncManager);

            SFSyncManager.KeyRequestLoadLocal = "KeyRequestLoadLocal";
            SFSyncManager.KeyRequestSaveLocal = "KeyRequestSaveLocal";
            SFSyncManager.KeyRequestLoadSaveAccount = "KeyRequestLoadSaveAccount";
            this.httpManager = httpManager;
            this.modelManager = modelManager;
            this.storageManager = storageManager; // Allows you to et your own interval/timeout function (i.e if you're using angular and want to use $timeout)

            this.$interval = interval || setInterval.bind(window);
            this.$timeout = timeout || setTimeout.bind(window);
            this.syncStatus = {};
            this.syncStatusObservers = [];
            this.eventHandlers = [];
            this.PerSyncItemUploadLimit = 100; // The number of changed items that constitute a major change
            // This is used by the desktop app to create backups

            this.MajorDataChangeThreshold = 15; // Sync integrity checking
            // If X consective sync requests return mismatching hashes, then we officially enter out-of-sync.

            this.MaxDiscordanceBeforeOutOfSync = 5; // How many consective sync results have had mismatching hashes. This value can never exceed this.MaxDiscordanceBeforeOutOfSync.

            this.syncDiscordance = 0;
            this.outOfSync = false;
          }

          _createClass(SFSyncManager, [{
            key: "handleServerIntegrityHash",
            value: function () {
              var _ref79 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee73(serverHash) {
                var localHash;
                return regeneratorRuntime.wrap(function _callee73$(_context73) {
                  while (1) {
                    switch (_context73.prev = _context73.next) {
                      case 0:
                        if (!(!serverHash || serverHash.length == 0)) {
                          _context73.next = 2;
                          break;
                        }

                        return _context73.abrupt("return", true);

                      case 2:
                        _context73.next = 4;
                        return this.modelManager.computeDataIntegrityHash();

                      case 4:
                        localHash = _context73.sent;

                        if (localHash) {
                          _context73.next = 7;
                          break;
                        }

                        return _context73.abrupt("return", true);

                      case 7:
                        if (!(localHash !== serverHash)) {
                          _context73.next = 13;
                          break;
                        }

                        this.syncDiscordance++;

                        if (this.syncDiscordance >= this.MaxDiscordanceBeforeOutOfSync) {
                          if (!this.outOfSync) {
                            this.outOfSync = true;
                            this.notifyEvent("enter-out-of-sync");
                          }
                        }

                        return _context73.abrupt("return", false);

                      case 13:
                        // Integrity matches
                        if (this.outOfSync) {
                          this.outOfSync = false;
                          this.notifyEvent("exit-out-of-sync");
                        }

                        this.syncDiscordance = 0;
                        return _context73.abrupt("return", true);

                      case 16:
                      case "end":
                        return _context73.stop();
                    }
                  }
                }, _callee73, this);
              }));

              function handleServerIntegrityHash(_x95) {
                return _ref79.apply(this, arguments);
              }

              return handleServerIntegrityHash;
            }()
          }, {
            key: "isOutOfSync",
            value: function isOutOfSync() {
              // Once we are outOfSync, it's up to the client to display UI to the user to instruct them
              // to take action. The client should present a reconciliation wizard.
              return this.outOfSync;
            }
          }, {
            key: "getServerURL",
            value: function () {
              var _ref80 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee74() {
                return regeneratorRuntime.wrap(function _callee74$(_context74) {
                  while (1) {
                    switch (_context74.prev = _context74.next) {
                      case 0:
                        _context74.next = 2;
                        return this.storageManager.getItem("server");

                      case 2:
                        _context74.t0 = _context74.sent;

                        if (_context74.t0) {
                          _context74.next = 5;
                          break;
                        }

                        _context74.t0 = window._default_sf_server;

                      case 5:
                        return _context74.abrupt("return", _context74.t0);

                      case 6:
                      case "end":
                        return _context74.stop();
                    }
                  }
                }, _callee74, this);
              }));

              function getServerURL() {
                return _ref80.apply(this, arguments);
              }

              return getServerURL;
            }()
          }, {
            key: "getSyncURL",
            value: function () {
              var _ref81 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee75() {
                return regeneratorRuntime.wrap(function _callee75$(_context75) {
                  while (1) {
                    switch (_context75.prev = _context75.next) {
                      case 0:
                        _context75.next = 2;
                        return this.getServerURL();

                      case 2:
                        _context75.t0 = _context75.sent;
                        return _context75.abrupt("return", _context75.t0 + "/items/sync");

                      case 4:
                      case "end":
                        return _context75.stop();
                    }
                  }
                }, _callee75, this);
              }));

              function getSyncURL() {
                return _ref81.apply(this, arguments);
              }

              return getSyncURL;
            }()
          }, {
            key: "registerSyncStatusObserver",
            value: function registerSyncStatusObserver(callback) {
              var observer = {
                key: new Date(),
                callback: callback
              };
              this.syncStatusObservers.push(observer);
              return observer;
            }
          }, {
            key: "removeSyncStatusObserver",
            value: function removeSyncStatusObserver(observer) {
              _.pull(this.syncStatusObservers, observer);
            }
          }, {
            key: "syncStatusDidChange",
            value: function syncStatusDidChange() {
              var _this18 = this;

              this.syncStatusObservers.forEach(function (observer) {
                observer.callback(_this18.syncStatus);
              });
            }
          }, {
            key: "addEventHandler",
            value: function addEventHandler(handler) {
              /*
              Possible Events:
              sync:completed
              sync:taking-too-long
              sync:updated_token
              sync:error
              major-data-change
              local-data-loaded
              sync-session-invalid
              sync-exception
               */
              this.eventHandlers.push(handler);
              return handler;
            }
          }, {
            key: "removeEventHandler",
            value: function removeEventHandler(handler) {
              _.pull(this.eventHandlers, handler);
            }
          }, {
            key: "notifyEvent",
            value: function notifyEvent(syncEvent, data) {
              var _iteratorNormalCompletion37 = true;
              var _didIteratorError37 = false;
              var _iteratorError37 = undefined;

              try {
                for (var _iterator37 = this.eventHandlers[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
                  var handler = _step37.value;
                  handler(syncEvent, data || {});
                }
              } catch (err) {
                _didIteratorError37 = true;
                _iteratorError37 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion37 && _iterator37.return) {
                    _iterator37.return();
                  }
                } finally {
                  if (_didIteratorError37) {
                    throw _iteratorError37;
                  }
                }
              }
            }
          }, {
            key: "setKeyRequestHandler",
            value: function setKeyRequestHandler(handler) {
              this.keyRequestHandler = handler;
            }
          }, {
            key: "getActiveKeyInfo",
            value: function () {
              var _ref82 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee76(request) {
                return regeneratorRuntime.wrap(function _callee76$(_context76) {
                  while (1) {
                    switch (_context76.prev = _context76.next) {
                      case 0:
                        return _context76.abrupt("return", this.keyRequestHandler(request));

                      case 1:
                      case "end":
                        return _context76.stop();
                    }
                  }
                }, _callee76, this);
              }));

              function getActiveKeyInfo(_x96) {
                return _ref82.apply(this, arguments);
              }

              return getActiveKeyInfo;
            }()
          }, {
            key: "initialDataLoaded",
            value: function initialDataLoaded() {
              return this._initialDataLoaded;
            }
          }, {
            key: "loadLocalItems",
            value: function () {
              var _ref83 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee78(incrementalCallback) {
                var _this19 = this;

                var batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
                return regeneratorRuntime.wrap(function _callee78$(_context78) {
                  while (1) {
                    switch (_context78.prev = _context78.next) {
                      case 0:
                        return _context78.abrupt("return", this.storageManager.getAllModels().then(function (items) {
                          // put most recently updated at beginning, sorted by priority
                          items = items.sort(function (a, b) {
                            var dateResult = new Date(b.updated_at) - new Date(a.updated_at);
                            var priorityList = _this19.contentTypeLoadPriority;
                            var aPriority = 0,
                                bPriority = 0;

                            if (priorityList) {
                              aPriority = priorityList.indexOf(a.content_type);
                              bPriority = priorityList.indexOf(b.content_type);

                              if (aPriority == -1) {
                                // Not found in list, not prioritized. Set it to max value
                                aPriority = priorityList.length;
                              }

                              if (bPriority == -1) {
                                // Not found in list, not prioritized. Set it to max value
                                bPriority = priorityList.length;
                              }
                            }

                            if (aPriority == bPriority) {
                              return dateResult;
                            }

                            if (aPriority < bPriority) {
                              return -1;
                            } else {
                              return 1;
                            } // aPriority < bPriority means a should come first


                            return aPriority < bPriority ? -1 : 1;
                          }); // break it up into chunks to make interface more responsive for large item counts

                          var total = items.length;
                          var current = 0;
                          var processed = [];

                          var decryptNext = function () {
                            var _ref84 = _asyncToGenerator(
                            /*#__PURE__*/
                            regeneratorRuntime.mark(function _callee77() {
                              var subitems, processedSubitems;
                              return regeneratorRuntime.wrap(function _callee77$(_context77) {
                                while (1) {
                                  switch (_context77.prev = _context77.next) {
                                    case 0:
                                      subitems = items.slice(current, current + batchSize);
                                      _context77.next = 3;
                                      return _this19.handleItemsResponse(subitems, null, SFModelManager.MappingSourceLocalRetrieved, SFSyncManager.KeyRequestLoadLocal);

                                    case 3:
                                      processedSubitems = _context77.sent;
                                      processed.push(processedSubitems);
                                      current += subitems.length;

                                      if (!(current < total)) {
                                        _context77.next = 10;
                                        break;
                                      }

                                      return _context77.abrupt("return", new Promise(function (innerResolve, innerReject) {
                                        _this19.$timeout(function () {
                                          _this19.notifyEvent("local-data-incremental-load");

                                          incrementalCallback && incrementalCallback(current, total);
                                          decryptNext().then(innerResolve);
                                        });
                                      }));

                                    case 10:
                                      // Completed
                                      _this19.notifyEvent("local-data-loaded");

                                      _this19._initialDataLoaded = true;

                                    case 12:
                                    case "end":
                                      return _context77.stop();
                                  }
                                }
                              }, _callee77, _this19);
                            }));

                            return function decryptNext() {
                              return _ref84.apply(this, arguments);
                            };
                          }();

                          return decryptNext();
                        }));

                      case 1:
                      case "end":
                        return _context78.stop();
                    }
                  }
                }, _callee78, this);
              }));

              function loadLocalItems(_x98) {
                return _ref83.apply(this, arguments);
              }

              return loadLocalItems;
            }()
          }, {
            key: "writeItemsToLocalStorage",
            value: function () {
              var _ref85 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee81(items, offlineOnly) {
                var _this20 = this;

                return regeneratorRuntime.wrap(function _callee81$(_context81) {
                  while (1) {
                    switch (_context81.prev = _context81.next) {
                      case 0:
                        return _context81.abrupt("return", new Promise(function () {
                          var _ref86 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee80(resolve, reject) {
                            var info;
                            return regeneratorRuntime.wrap(function _callee80$(_context80) {
                              while (1) {
                                switch (_context80.prev = _context80.next) {
                                  case 0:
                                    if (!(items.length == 0)) {
                                      _context80.next = 3;
                                      break;
                                    }

                                    resolve();
                                    return _context80.abrupt("return");

                                  case 3:
                                    _context80.next = 5;
                                    return _this20.getActiveKeyInfo(SFSyncManager.KeyRequestSaveLocal);

                                  case 5:
                                    info = _context80.sent;
                                    Promise.all(items.map(function () {
                                      var _ref87 = _asyncToGenerator(
                                      /*#__PURE__*/
                                      regeneratorRuntime.mark(function _callee79(item) {
                                        var itemParams;
                                        return regeneratorRuntime.wrap(function _callee79$(_context79) {
                                          while (1) {
                                            switch (_context79.prev = _context79.next) {
                                              case 0:
                                                itemParams = new SFItemParams(item, info.keys, info.auth_params);
                                                _context79.next = 3;
                                                return itemParams.paramsForLocalStorage();

                                              case 3:
                                                itemParams = _context79.sent;

                                                if (offlineOnly) {
                                                  delete itemParams.dirty;
                                                }

                                                return _context79.abrupt("return", itemParams);

                                              case 6:
                                              case "end":
                                                return _context79.stop();
                                            }
                                          }
                                        }, _callee79, _this20);
                                      }));

                                      return function (_x103) {
                                        return _ref87.apply(this, arguments);
                                      };
                                    }())).then(function (params) {
                                      _this20.storageManager.saveModels(params).then(function () {
                                        // on success
                                        if (_this20.syncStatus.localError) {
                                          _this20.syncStatus.localError = null;

                                          _this20.syncStatusDidChange();
                                        }

                                        resolve();
                                      }).catch(function (error) {
                                        // on error
                                        console.error("Error writing items", error);
                                        _this20.syncStatus.localError = error;

                                        _this20.syncStatusDidChange();

                                        reject();
                                      });
                                    }).catch(function (e) {
                                      reject(e);
                                    });

                                  case 7:
                                  case "end":
                                    return _context80.stop();
                                }
                              }
                            }, _callee80, _this20);
                          }));

                          return function (_x101, _x102) {
                            return _ref86.apply(this, arguments);
                          };
                        }()));

                      case 1:
                      case "end":
                        return _context81.stop();
                    }
                  }
                }, _callee81, this);
              }));

              function writeItemsToLocalStorage(_x99, _x100) {
                return _ref85.apply(this, arguments);
              }

              return writeItemsToLocalStorage;
            }()
          }, {
            key: "syncOffline",
            value: function () {
              var _ref88 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee82(items) {
                var _this21 = this;

                var _iteratorNormalCompletion38, _didIteratorError38, _iteratorError38, _iterator38, _step38, item;

                return regeneratorRuntime.wrap(function _callee82$(_context82) {
                  while (1) {
                    switch (_context82.prev = _context82.next) {
                      case 0:
                        // Update all items updated_at to now
                        _iteratorNormalCompletion38 = true;
                        _didIteratorError38 = false;
                        _iteratorError38 = undefined;
                        _context82.prev = 3;

                        for (_iterator38 = items[Symbol.iterator](); !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
                          item = _step38.value;
                          item.updated_at = new Date();
                        }

                        _context82.next = 11;
                        break;

                      case 7:
                        _context82.prev = 7;
                        _context82.t0 = _context82["catch"](3);
                        _didIteratorError38 = true;
                        _iteratorError38 = _context82.t0;

                      case 11:
                        _context82.prev = 11;
                        _context82.prev = 12;

                        if (!_iteratorNormalCompletion38 && _iterator38.return) {
                          _iterator38.return();
                        }

                      case 14:
                        _context82.prev = 14;

                        if (!_didIteratorError38) {
                          _context82.next = 17;
                          break;
                        }

                        throw _iteratorError38;

                      case 17:
                        return _context82.finish(14);

                      case 18:
                        return _context82.finish(11);

                      case 19:
                        return _context82.abrupt("return", this.writeItemsToLocalStorage(items, true).then(function (responseItems) {
                          // delete anything needing to be deleted
                          var _iteratorNormalCompletion39 = true;
                          var _didIteratorError39 = false;
                          var _iteratorError39 = undefined;

                          try {
                            for (var _iterator39 = items[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
                              var _item = _step39.value;

                              if (_item.deleted) {
                                _this21.modelManager.removeItemLocally(_item);
                              }
                            }
                          } catch (err) {
                            _didIteratorError39 = true;
                            _iteratorError39 = err;
                          } finally {
                            try {
                              if (!_iteratorNormalCompletion39 && _iterator39.return) {
                                _iterator39.return();
                              }
                            } finally {
                              if (_didIteratorError39) {
                                throw _iteratorError39;
                              }
                            }
                          }

                          _this21.notifyEvent("sync:completed", {
                            savedItems: items
                          }); // Required in order for modelManager to notify sync observers


                          _this21.modelManager.didSyncModelsOffline(items);

                          return {
                            saved_items: items
                          };
                        }));

                      case 20:
                      case "end":
                        return _context82.stop();
                    }
                  }
                }, _callee82, this, [[3, 7, 11, 19], [12,, 14, 18]]);
              }));

              function syncOffline(_x104) {
                return _ref88.apply(this, arguments);
              }

              return syncOffline;
            }()
            /*
              In the case of signing in and merging local data, we alternative UUIDs
              to avoid overwriting data a user may retrieve that has the same UUID.
              Alternating here forces us to to create duplicates of the items instead.
             */

          }, {
            key: "markAllItemsDirtyAndSaveOffline",
            value: function () {
              var _ref89 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee83(alternateUUIDs) {
                var originalItems, _iteratorNormalCompletion40, _didIteratorError40, _iteratorError40, _iterator40, _step40, item, allItems, _iteratorNormalCompletion41, _didIteratorError41, _iteratorError41, _iterator41, _step41, _item2;

                return regeneratorRuntime.wrap(function _callee83$(_context83) {
                  while (1) {
                    switch (_context83.prev = _context83.next) {
                      case 0:
                        // use a copy, as alternating uuid will affect array
                        originalItems = this.modelManager.allNondummyItems.filter(function (item) {
                          return !item.errorDecrypting;
                        }).slice();

                        if (!alternateUUIDs) {
                          _context83.next = 28;
                          break;
                        }

                        _iteratorNormalCompletion40 = true;
                        _didIteratorError40 = false;
                        _iteratorError40 = undefined;
                        _context83.prev = 5;
                        _iterator40 = originalItems[Symbol.iterator]();

                      case 7:
                        if (_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done) {
                          _context83.next = 14;
                          break;
                        }

                        item = _step40.value;
                        _context83.next = 11;
                        return this.modelManager.alternateUUIDForItem(item);

                      case 11:
                        _iteratorNormalCompletion40 = true;
                        _context83.next = 7;
                        break;

                      case 14:
                        _context83.next = 20;
                        break;

                      case 16:
                        _context83.prev = 16;
                        _context83.t0 = _context83["catch"](5);
                        _didIteratorError40 = true;
                        _iteratorError40 = _context83.t0;

                      case 20:
                        _context83.prev = 20;
                        _context83.prev = 21;

                        if (!_iteratorNormalCompletion40 && _iterator40.return) {
                          _iterator40.return();
                        }

                      case 23:
                        _context83.prev = 23;

                        if (!_didIteratorError40) {
                          _context83.next = 26;
                          break;
                        }

                        throw _iteratorError40;

                      case 26:
                        return _context83.finish(23);

                      case 27:
                        return _context83.finish(20);

                      case 28:
                        allItems = this.modelManager.allNondummyItems;
                        _iteratorNormalCompletion41 = true;
                        _didIteratorError41 = false;
                        _iteratorError41 = undefined;
                        _context83.prev = 32;

                        for (_iterator41 = allItems[Symbol.iterator](); !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
                          _item2 = _step41.value;

                          _item2.setDirty(true);
                        }

                        _context83.next = 40;
                        break;

                      case 36:
                        _context83.prev = 36;
                        _context83.t1 = _context83["catch"](32);
                        _didIteratorError41 = true;
                        _iteratorError41 = _context83.t1;

                      case 40:
                        _context83.prev = 40;
                        _context83.prev = 41;

                        if (!_iteratorNormalCompletion41 && _iterator41.return) {
                          _iterator41.return();
                        }

                      case 43:
                        _context83.prev = 43;

                        if (!_didIteratorError41) {
                          _context83.next = 46;
                          break;
                        }

                        throw _iteratorError41;

                      case 46:
                        return _context83.finish(43);

                      case 47:
                        return _context83.finish(40);

                      case 48:
                        return _context83.abrupt("return", this.writeItemsToLocalStorage(allItems, false));

                      case 49:
                      case "end":
                        return _context83.stop();
                    }
                  }
                }, _callee83, this, [[5, 16, 20, 28], [21,, 23, 27], [32, 36, 40, 48], [41,, 43, 47]]);
              }));

              function markAllItemsDirtyAndSaveOffline(_x105) {
                return _ref89.apply(this, arguments);
              }

              return markAllItemsDirtyAndSaveOffline;
            }()
          }, {
            key: "setSyncToken",
            value: function () {
              var _ref90 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee84(token) {
                return regeneratorRuntime.wrap(function _callee84$(_context84) {
                  while (1) {
                    switch (_context84.prev = _context84.next) {
                      case 0:
                        this._syncToken = token;
                        _context84.next = 3;
                        return this.storageManager.setItem("syncToken", token);

                      case 3:
                      case "end":
                        return _context84.stop();
                    }
                  }
                }, _callee84, this);
              }));

              function setSyncToken(_x106) {
                return _ref90.apply(this, arguments);
              }

              return setSyncToken;
            }()
          }, {
            key: "getSyncToken",
            value: function () {
              var _ref91 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee85() {
                return regeneratorRuntime.wrap(function _callee85$(_context85) {
                  while (1) {
                    switch (_context85.prev = _context85.next) {
                      case 0:
                        if (this._syncToken) {
                          _context85.next = 4;
                          break;
                        }

                        _context85.next = 3;
                        return this.storageManager.getItem("syncToken");

                      case 3:
                        this._syncToken = _context85.sent;

                      case 4:
                        return _context85.abrupt("return", this._syncToken);

                      case 5:
                      case "end":
                        return _context85.stop();
                    }
                  }
                }, _callee85, this);
              }));

              function getSyncToken() {
                return _ref91.apply(this, arguments);
              }

              return getSyncToken;
            }()
          }, {
            key: "setCursorToken",
            value: function () {
              var _ref92 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee86(token) {
                return regeneratorRuntime.wrap(function _callee86$(_context86) {
                  while (1) {
                    switch (_context86.prev = _context86.next) {
                      case 0:
                        this._cursorToken = token;

                        if (!token) {
                          _context86.next = 6;
                          break;
                        }

                        _context86.next = 4;
                        return this.storageManager.setItem("cursorToken", token);

                      case 4:
                        _context86.next = 8;
                        break;

                      case 6:
                        _context86.next = 8;
                        return this.storageManager.removeItem("cursorToken");

                      case 8:
                      case "end":
                        return _context86.stop();
                    }
                  }
                }, _callee86, this);
              }));

              function setCursorToken(_x107) {
                return _ref92.apply(this, arguments);
              }

              return setCursorToken;
            }()
          }, {
            key: "getCursorToken",
            value: function () {
              var _ref93 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee87() {
                return regeneratorRuntime.wrap(function _callee87$(_context87) {
                  while (1) {
                    switch (_context87.prev = _context87.next) {
                      case 0:
                        if (this._cursorToken) {
                          _context87.next = 4;
                          break;
                        }

                        _context87.next = 3;
                        return this.storageManager.getItem("cursorToken");

                      case 3:
                        this._cursorToken = _context87.sent;

                      case 4:
                        return _context87.abrupt("return", this._cursorToken);

                      case 5:
                      case "end":
                        return _context87.stop();
                    }
                  }
                }, _callee87, this);
              }));

              function getCursorToken() {
                return _ref93.apply(this, arguments);
              }

              return getCursorToken;
            }()
          }, {
            key: "clearQueuedCallbacks",
            value: function clearQueuedCallbacks() {
              this._queuedCallbacks = [];
            }
          }, {
            key: "callQueuedCallbacks",
            value: function callQueuedCallbacks(response) {
              var allCallbacks = this.queuedCallbacks;

              if (allCallbacks.length) {
                var _iteratorNormalCompletion42 = true;
                var _didIteratorError42 = false;
                var _iteratorError42 = undefined;

                try {
                  for (var _iterator42 = allCallbacks[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
                    var eachCallback = _step42.value;
                    eachCallback(response);
                  }
                } catch (err) {
                  _didIteratorError42 = true;
                  _iteratorError42 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion42 && _iterator42.return) {
                      _iterator42.return();
                    }
                  } finally {
                    if (_didIteratorError42) {
                      throw _iteratorError42;
                    }
                  }
                }

                this.clearQueuedCallbacks();
              }
            }
          }, {
            key: "beginCheckingIfSyncIsTakingTooLong",
            value: function beginCheckingIfSyncIsTakingTooLong() {
              if (this.syncStatus.checker) {
                this.stopCheckingIfSyncIsTakingTooLong();
              }

              this.syncStatus.checker = this.$interval(function () {
                // check to see if the ongoing sync is taking too long, alert the user
                var secondsPassed = (new Date() - this.syncStatus.syncStart) / 1000;
                var warningThreshold = 5.0; // seconds

                if (secondsPassed > warningThreshold) {
                  this.notifyEvent("sync:taking-too-long");
                  this.stopCheckingIfSyncIsTakingTooLong();
                }
              }.bind(this), 500);
            }
          }, {
            key: "stopCheckingIfSyncIsTakingTooLong",
            value: function stopCheckingIfSyncIsTakingTooLong() {
              if (this.$interval.hasOwnProperty("cancel")) {
                this.$interval.cancel(this.syncStatus.checker);
              } else {
                clearInterval(this.syncStatus.checker);
              }

              this.syncStatus.checker = null;
            }
          }, {
            key: "lockSyncing",
            value: function lockSyncing() {
              this.syncLocked = true;
            }
          }, {
            key: "unlockSyncing",
            value: function unlockSyncing() {
              this.syncLocked = false;
            }
          }, {
            key: "sync",
            value: function () {
              var _ref94 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee89() {
                var _this22 = this;

                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                return regeneratorRuntime.wrap(function _callee89$(_context89) {
                  while (1) {
                    switch (_context89.prev = _context89.next) {
                      case 0:
                        return _context89.abrupt("return", new Promise(function () {
                          var _ref95 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee88(resolve, reject) {
                            var allDirtyItems, dirtyItemsNotYetSaved, info, isContinuationSync, submitLimit, subItems, params, _iteratorNormalCompletion43, _didIteratorError43, _iteratorError43, _iterator43, _step43, item;

                            return regeneratorRuntime.wrap(function _callee88$(_context88) {
                              while (1) {
                                switch (_context88.prev = _context88.next) {
                                  case 0:
                                    if (!_this22.syncLocked) {
                                      _context88.next = 4;
                                      break;
                                    }

                                    console.log("Sync Locked, Returning;");
                                    resolve();
                                    return _context88.abrupt("return");

                                  case 4:
                                    if (!options) options = {};
                                    allDirtyItems = _this22.modelManager.getDirtyItems();
                                    /*
                                      When it comes to saving to disk before the sync request (both in syncOpInProgress and preSyncSave),
                                      you only want to save items that have a dirty count > 0. That's because, if for example, you're syncing
                                      2000 items, and every sync request handles only 150 items at a time, then every sync request will
                                      be writing the same thousand items to storage every time. Writing a thousand items to storage can take 10s.
                                      So, save to local storage only items with dirtyCount > 0, then, after saving, set dirtyCount to 0.
                                      This way, if an item changes again, it will be saved next sync.
                                    */

                                    dirtyItemsNotYetSaved = allDirtyItems.filter(function (candidate) {
                                      if (candidate.dirtyCount > 0) {
                                        candidate.dirtyCount = 0;
                                        return true;
                                      } else {
                                        return false;
                                      }
                                    }); // When a user hits the physical refresh button, we want to force refresh, in case
                                    // the sync engine is stuck in some inProgress loop.

                                    if (!(_this22.syncStatus.syncOpInProgress && !options.force)) {
                                      _context88.next = 14;
                                      break;
                                    }

                                    _this22.repeatOnCompletion = true;

                                    _this22.queuedCallbacks.push(resolve);

                                    _context88.next = 12;
                                    return _this22.writeItemsToLocalStorage(dirtyItemsNotYetSaved, false);

                                  case 12:
                                    console.log("Sync op in progress; returning.");
                                    return _context88.abrupt("return");

                                  case 14:
                                    _context88.next = 16;
                                    return _this22.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);

                                  case 16:
                                    info = _context88.sent;

                                    if (!info.offline) {
                                      _context88.next = 20;
                                      break;
                                    }

                                    _this22.syncOffline(allDirtyItems).then(function (response) {
                                      _this22.modelManager.clearDirtyItems(allDirtyItems);

                                      resolve(response);
                                    }).catch(function (e) {
                                      _this22.notifyEvent("sync-exception", e);
                                    });

                                    return _context88.abrupt("return");

                                  case 20:
                                    isContinuationSync = _this22.syncStatus.needsMoreSync;
                                    _this22.syncStatus.syncOpInProgress = true;
                                    _this22.syncStatus.syncStart = new Date();

                                    _this22.beginCheckingIfSyncIsTakingTooLong();

                                    submitLimit = _this22.PerSyncItemUploadLimit;
                                    subItems = allDirtyItems.slice(0, submitLimit);

                                    if (subItems.length < allDirtyItems.length) {
                                      // more items left to be synced, repeat
                                      _this22.syncStatus.needsMoreSync = true;
                                    } else {
                                      _this22.syncStatus.needsMoreSync = false;
                                    }

                                    if (!isContinuationSync) {
                                      _this22.syncStatus.total = allDirtyItems.length;
                                      _this22.syncStatus.current = 0;
                                    } // If items are marked as dirty during a long running sync request, total isn't updated
                                    // This happens mostly in the case of large imports and sync conflicts where duplicated items are created


                                    if (_this22.syncStatus.current > _this22.syncStatus.total) {
                                      _this22.syncStatus.total = _this22.syncStatus.current;
                                    }

                                    _this22.syncStatusDidChange(); // Perform save after you've updated all status signals above. Presync save can take several seconds in some cases.
                                    // Write to local storage before beginning sync.
                                    // This way, if they close the browser before the sync request completes, local changes will not be lost


                                    _context88.next = 32;
                                    return _this22.writeItemsToLocalStorage(dirtyItemsNotYetSaved, false);

                                  case 32:
                                    if (options.onPreSyncSave) {
                                      options.onPreSyncSave();
                                    } // when doing a sync request that returns items greater than the limit, and thus subsequent syncs are required,
                                    // we want to keep track of all retreived items, then save to local storage only once all items have been retrieved,
                                    // so that relationships remain intact
                                    // Update 12/18: I don't think we need to do this anymore, since relationships will now retroactively resolve their relationships,
                                    // if an item they were looking for hasn't been pulled in yet.


                                    if (!_this22.allRetreivedItems) {
                                      _this22.allRetreivedItems = [];
                                    } // We also want to do this for savedItems


                                    if (!_this22.allSavedItems) {
                                      _this22.allSavedItems = [];
                                    }

                                    params = {};
                                    params.limit = 150;

                                    if (options.performIntegrityCheck) {
                                      params.compute_integrity = true;
                                    }

                                    _context88.prev = 38;
                                    _context88.next = 41;
                                    return Promise.all(subItems.map(function (item) {
                                      var itemParams = new SFItemParams(item, info.keys, info.auth_params);
                                      itemParams.additionalFields = options.additionalFields;
                                      return itemParams.paramsForSync();
                                    })).then(function (itemsParams) {
                                      params.items = itemsParams;
                                    });

                                  case 41:
                                    _context88.next = 46;
                                    break;

                                  case 43:
                                    _context88.prev = 43;
                                    _context88.t0 = _context88["catch"](38);

                                    _this22.notifyEvent("sync-exception", _context88.t0);

                                  case 46:
                                    _iteratorNormalCompletion43 = true;
                                    _didIteratorError43 = false;
                                    _iteratorError43 = undefined;
                                    _context88.prev = 49;

                                    for (_iterator43 = subItems[Symbol.iterator](); !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
                                      item = _step43.value; // Reset dirty counter to 0, since we're about to sync it.
                                      // This means anyone marking the item as dirty after this will cause it so sync again and not be cleared on sync completion.

                                      item.dirtyCount = 0;
                                    }

                                    _context88.next = 57;
                                    break;

                                  case 53:
                                    _context88.prev = 53;
                                    _context88.t1 = _context88["catch"](49);
                                    _didIteratorError43 = true;
                                    _iteratorError43 = _context88.t1;

                                  case 57:
                                    _context88.prev = 57;
                                    _context88.prev = 58;

                                    if (!_iteratorNormalCompletion43 && _iterator43.return) {
                                      _iterator43.return();
                                    }

                                  case 60:
                                    _context88.prev = 60;

                                    if (!_didIteratorError43) {
                                      _context88.next = 63;
                                      break;
                                    }

                                    throw _iteratorError43;

                                  case 63:
                                    return _context88.finish(60);

                                  case 64:
                                    return _context88.finish(57);

                                  case 65:
                                    _context88.next = 67;
                                    return _this22.getSyncToken();

                                  case 67:
                                    params.sync_token = _context88.sent;
                                    _context88.next = 70;
                                    return _this22.getCursorToken();

                                  case 70:
                                    params.cursor_token = _context88.sent;
                                    _context88.prev = 71;
                                    _context88.t2 = _this22.httpManager;
                                    _context88.next = 75;
                                    return _this22.getSyncURL();

                                  case 75:
                                    _context88.t3 = _context88.sent;
                                    _context88.t4 = params;

                                    _context88.t5 = function (response) {
                                      _this22.handleSyncSuccess(subItems, response, options).then(function () {
                                        resolve(response);
                                      }).catch(function (e) {
                                        console.log("Caught sync success exception:", e);

                                        _this22.handleSyncError(null, null, allDirtyItems).then(function (errorResponse) {
                                          resolve(errorResponse);
                                        });
                                      });
                                    };

                                    _context88.t6 = function (response, statusCode) {
                                      _this22.handleSyncError(response, statusCode, allDirtyItems).then(function (errorResponse) {
                                        resolve(errorResponse);
                                      });
                                    };

                                    _context88.t2.postAbsolute.call(_context88.t2, _context88.t3, _context88.t4, _context88.t5, _context88.t6);

                                    _context88.next = 85;
                                    break;

                                  case 82:
                                    _context88.prev = 82;
                                    _context88.t7 = _context88["catch"](71);
                                    console.log("Sync exception caught:", _context88.t7);

                                  case 85:
                                  case "end":
                                    return _context88.stop();
                                }
                              }
                            }, _callee88, _this22, [[38, 43], [49, 53, 57, 65], [58,, 60, 64], [71, 82]]);
                          }));

                          return function (_x109, _x110) {
                            return _ref95.apply(this, arguments);
                          };
                        }()));

                      case 1:
                      case "end":
                        return _context89.stop();
                    }
                  }
                }, _callee89, this);
              }));

              function sync() {
                return _ref94.apply(this, arguments);
              }

              return sync;
            }()
          }, {
            key: "handleSyncSuccess",
            value: function () {
              var _ref96 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee90(syncedItems, response, options) {
                var _this23 = this;

                var itemsToClearAsDirty, _iteratorNormalCompletion44, _didIteratorError44, _iteratorError44, _iterator44, _step44, item, allSavedUUIDs, retrieved, omitFields, saved, unsaved, matches, cursorToken;

                return regeneratorRuntime.wrap(function _callee90$(_context90) {
                  while (1) {
                    switch (_context90.prev = _context90.next) {
                      case 0:
                        // Check to make sure any subItem hasn't been marked as dirty again while a sync was ongoing
                        itemsToClearAsDirty = [];
                        _iteratorNormalCompletion44 = true;
                        _didIteratorError44 = false;
                        _iteratorError44 = undefined;
                        _context90.prev = 4;

                        for (_iterator44 = syncedItems[Symbol.iterator](); !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
                          item = _step44.value;

                          if (item.dirtyCount == 0) {
                            // Safe to clear as dirty
                            itemsToClearAsDirty.push(item);
                          }
                        }

                        _context90.next = 12;
                        break;

                      case 8:
                        _context90.prev = 8;
                        _context90.t0 = _context90["catch"](4);
                        _didIteratorError44 = true;
                        _iteratorError44 = _context90.t0;

                      case 12:
                        _context90.prev = 12;
                        _context90.prev = 13;

                        if (!_iteratorNormalCompletion44 && _iterator44.return) {
                          _iterator44.return();
                        }

                      case 15:
                        _context90.prev = 15;

                        if (!_didIteratorError44) {
                          _context90.next = 18;
                          break;
                        }

                        throw _iteratorError44;

                      case 18:
                        return _context90.finish(15);

                      case 19:
                        return _context90.finish(12);

                      case 20:
                        this.modelManager.clearDirtyItems(itemsToClearAsDirty);
                        this.syncStatus.error = null; // Filter retrieved_items to remove any items that may be in saved_items for this complete sync operation
                        // When signing in, and a user requires many round trips to complete entire retrieval of data, an item may be saved
                        // on the first trip, then on subsequent trips using cursor_token, this same item may be returned, since it's date is
                        // greater than cursor_token. We keep track of all saved items in whole sync operation with this.allSavedItems
                        // We need this because singletonManager looks at retrievedItems as higher precendence than savedItems, but if it comes in both
                        // then that's problematic.

                        allSavedUUIDs = this.allSavedItems.map(function (item) {
                          return item.uuid;
                        });
                        response.retrieved_items = response.retrieved_items.filter(function (candidate) {
                          return !allSavedUUIDs.includes(candidate.uuid);
                        }); // Map retrieved items to local data
                        // Note that deleted items will not be returned

                        _context90.next = 26;
                        return this.handleItemsResponse(response.retrieved_items, null, SFModelManager.MappingSourceRemoteRetrieved, SFSyncManager.KeyRequestLoadSaveAccount);

                      case 26:
                        retrieved = _context90.sent; // Append items to master list of retrieved items for this ongoing sync operation

                        this.allRetreivedItems = this.allRetreivedItems.concat(retrieved);
                        this.syncStatus.retrievedCount = this.allRetreivedItems.length; // Merge only metadata for saved items
                        // we write saved items to disk now because it clears their dirty status then saves
                        // if we saved items before completion, we had have to save them as dirty and save them again on success as clean

                        omitFields = ["content", "auth_hash"]; // Map saved items to local data

                        _context90.next = 32;
                        return this.handleItemsResponse(response.saved_items, omitFields, SFModelManager.MappingSourceRemoteSaved, SFSyncManager.KeyRequestLoadSaveAccount);

                      case 32:
                        saved = _context90.sent; // Append items to master list of saved items for this ongoing sync operation

                        this.allSavedItems = this.allSavedItems.concat(saved); // Create copies of items or alternate their uuids if neccessary

                        unsaved = response.unsaved; // don't `await`. This function calls sync, so if you wait, it will call sync without having completed the sync we're in.
                        // On second thought, calling await will only await the local conflict resolution and not await the sync call.
                        // We do need to wait here for sync duplication to finish. If we don't, there seems to be an issue where if you import a large
                        // backup with uuid-conflcits (from another account), you'll see very confused duplication.

                        _context90.next = 37;
                        return this.handleUnsavedItemsResponse(unsaved);

                      case 37:
                        _context90.next = 39;
                        return this.writeItemsToLocalStorage(saved, false);

                      case 39:
                        _context90.next = 41;
                        return this.writeItemsToLocalStorage(retrieved, false);

                      case 41:
                        this.syncStatus.syncOpInProgress = false;
                        this.syncStatus.current += syncedItems.length;
                        this.syncStatusDidChange(); // set the sync token at the end, so that if any errors happen above, you can resync

                        this.setSyncToken(response.sync_token);
                        this.setCursorToken(response.cursor_token);
                        this.stopCheckingIfSyncIsTakingTooLong(); // if a cursor token is available, dont perform integrity calculation,
                        // as content is still on the server waiting to be downloaded

                        if (!(response.integrity_hash && !response.cursor_token)) {
                          _context90.next = 52;
                          break;
                        }

                        _context90.next = 50;
                        return this.handleServerIntegrityHash(response.integrity_hash);

                      case 50:
                        matches = _context90.sent;

                        if (!matches) {
                          // If the server hash doesn't match our local hash, we want to continue syncing until we reach
                          // the max discordance threshold
                          if (this.syncDiscordance < this.MaxDiscordanceBeforeOutOfSync) {
                            this.repeatOnCompletion = true;
                          }
                        }

                      case 52:
                        _context90.next = 54;
                        return this.getCursorToken();

                      case 54:
                        cursorToken = _context90.sent;

                        if (!(cursorToken || this.syncStatus.needsMoreSync)) {
                          _context90.next = 59;
                          break;
                        }

                        return _context90.abrupt("return", new Promise(function (resolve, reject) {
                          setTimeout(function () {
                            this.sync(options).then(resolve);
                          }.bind(_this23), 10); // wait 10ms to allow UI to update
                        }));

                      case 59:
                        if (!this.repeatOnCompletion) {
                          _context90.next = 64;
                          break;
                        }

                        this.repeatOnCompletion = false;
                        return _context90.abrupt("return", new Promise(function (resolve, reject) {
                          setTimeout(function () {
                            this.sync(options).then(resolve);
                          }.bind(_this23), 10); // wait 10ms to allow UI to update
                        }));

                      case 64:
                        /*
                        // await this.writeItemsToLocalStorage(this.allRetreivedItems, false);
                          We used to do this, but the problem is, if you're saving 2000 items at the end of a sign in,
                          then refresh or close the page, the items will not be saved, and the sync token will be the lastest.
                          So the data won't be downloaded again. Instead, we'll save retrieved as they come.
                        */
                        this.syncStatus.retrievedCount = 0;
                        this.syncStatusDidChange();

                        if (this.allRetreivedItems.length >= this.majorDataChangeThreshold || saved.length >= this.majorDataChangeThreshold || unsaved.length >= this.majorDataChangeThreshold) {
                          this.notifyEvent("major-data-change");
                        }

                        this.callQueuedCallbacks(response);
                        this.notifyEvent("sync:completed", {
                          retrievedItems: this.allRetreivedItems,
                          savedItems: this.allSavedItems,
                          unsavedItems: unsaved
                        });
                        this.allRetreivedItems = [];
                        this.allSavedItems = [];
                        return _context90.abrupt("return", response);

                      case 72:
                      case "end":
                        return _context90.stop();
                    }
                  }
                }, _callee90, this, [[4, 8, 12, 20], [13,, 15, 19]]);
              }));

              function handleSyncSuccess(_x111, _x112, _x113) {
                return _ref96.apply(this, arguments);
              }

              return handleSyncSuccess;
            }()
          }, {
            key: "handleSyncError",
            value: function () {
              var _ref97 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee91(response, statusCode, allDirtyItems) {
                return regeneratorRuntime.wrap(function _callee91$(_context91) {
                  while (1) {
                    switch (_context91.prev = _context91.next) {
                      case 0:
                        console.log("Sync error: ", response);

                        if (statusCode == 401) {
                          this.notifyEvent("sync-session-invalid");
                        }

                        if (!response) {
                          response = {
                            error: {
                              message: "Could not connect to server."
                            }
                          };
                        } else if (typeof response == 'string') {
                          response = {
                            error: {
                              message: response
                            }
                          };
                        }

                        this.syncStatus.syncOpInProgress = false;
                        this.syncStatus.error = response.error;
                        this.syncStatusDidChange();
                        this.writeItemsToLocalStorage(allDirtyItems, false);
                        this.modelManager.didSyncModelsOffline(allDirtyItems);
                        this.stopCheckingIfSyncIsTakingTooLong();
                        this.notifyEvent("sync:error", response.error);
                        this.callQueuedCallbacks({
                          error: "Sync error"
                        });
                        return _context91.abrupt("return", response);

                      case 12:
                      case "end":
                        return _context91.stop();
                    }
                  }
                }, _callee91, this);
              }));

              function handleSyncError(_x114, _x115, _x116) {
                return _ref97.apply(this, arguments);
              }

              return handleSyncError;
            }()
          }, {
            key: "handleItemsResponse",
            value: function () {
              var _ref98 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee92(responseItems, omitFields, source, keyRequest) {
                var keys, items, itemsWithErrorStatusChange;
                return regeneratorRuntime.wrap(function _callee92$(_context92) {
                  while (1) {
                    switch (_context92.prev = _context92.next) {
                      case 0:
                        _context92.next = 2;
                        return this.getActiveKeyInfo(keyRequest);

                      case 2:
                        keys = _context92.sent.keys;
                        _context92.next = 5;
                        return SFJS.itemTransformer.decryptMultipleItems(responseItems, keys);

                      case 5:
                        items = this.modelManager.mapResponseItemsToLocalModelsOmittingFields(responseItems, omitFields, source); // During the decryption process, items may be marked as "errorDecrypting". If so, we want to be sure
                        // to persist this new state by writing these items back to local storage. When an item's "errorDecrypting"
                        // flag is changed, its "errorDecryptingValueChanged" flag will be set, so we can find these items by filtering (then unsetting) below:

                        itemsWithErrorStatusChange = items.filter(function (item) {
                          var valueChanged = item.errorDecryptingValueChanged; // unset after consuming value

                          item.errorDecryptingValueChanged = false;
                          return valueChanged;
                        });

                        if (itemsWithErrorStatusChange.length > 0) {
                          this.writeItemsToLocalStorage(itemsWithErrorStatusChange, false);
                        }

                        return _context92.abrupt("return", items);

                      case 9:
                      case "end":
                        return _context92.stop();
                    }
                  }
                }, _callee92, this);
              }));

              function handleItemsResponse(_x117, _x118, _x119, _x120) {
                return _ref98.apply(this, arguments);
              }

              return handleItemsResponse;
            }()
          }, {
            key: "refreshErroredItems",
            value: function () {
              var _ref99 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee93() {
                var erroredItems;
                return regeneratorRuntime.wrap(function _callee93$(_context93) {
                  while (1) {
                    switch (_context93.prev = _context93.next) {
                      case 0:
                        erroredItems = this.modelManager.allNondummyItems.filter(function (item) {
                          return item.errorDecrypting == true;
                        });

                        if (!(erroredItems.length > 0)) {
                          _context93.next = 3;
                          break;
                        }

                        return _context93.abrupt("return", this.handleItemsResponse(erroredItems, null, SFModelManager.MappingSourceLocalRetrieved, SFSyncManager.KeyRequestLoadSaveAccount));

                      case 3:
                      case "end":
                        return _context93.stop();
                    }
                  }
                }, _callee93, this);
              }));

              function refreshErroredItems() {
                return _ref99.apply(this, arguments);
              }

              return refreshErroredItems;
            }()
          }, {
            key: "handleUnsavedItemsResponse",
            value: function () {
              var _ref100 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee94(unsaved) {
                var _iteratorNormalCompletion45, _didIteratorError45, _iteratorError45, _iterator45, _step45, mapping, itemResponse, item, error, dup;

                return regeneratorRuntime.wrap(function _callee94$(_context94) {
                  while (1) {
                    switch (_context94.prev = _context94.next) {
                      case 0:
                        if (!(unsaved.length == 0)) {
                          _context94.next = 2;
                          break;
                        }

                        return _context94.abrupt("return");

                      case 2:
                        console.log("Handle Conflicted Items:", unsaved);
                        _iteratorNormalCompletion45 = true;
                        _didIteratorError45 = false;
                        _iteratorError45 = undefined;
                        _context94.prev = 6;
                        _iterator45 = unsaved[Symbol.iterator]();

                      case 8:
                        if (_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done) {
                          _context94.next = 35;
                          break;
                        }

                        mapping = _step45.value;
                        itemResponse = mapping.item;
                        _context94.t0 = SFJS.itemTransformer;
                        _context94.t1 = [itemResponse];
                        _context94.next = 15;
                        return this.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);

                      case 15:
                        _context94.t2 = _context94.sent.keys;
                        _context94.next = 18;
                        return _context94.t0.decryptMultipleItems.call(_context94.t0, _context94.t1, _context94.t2);

                      case 18:
                        item = this.modelManager.findItem(itemResponse.uuid); // Could be deleted

                        if (item) {
                          _context94.next = 21;
                          break;
                        }

                        return _context94.abrupt("continue", 32);

                      case 21:
                        error = mapping.error;

                        if (!(error.tag === "uuid_conflict")) {
                          _context94.next = 27;
                          break;
                        }

                        _context94.next = 25;
                        return this.modelManager.alternateUUIDForItem(item);

                      case 25:
                        _context94.next = 32;
                        break;

                      case 27:
                        if (!(error.tag === "sync_conflict")) {
                          _context94.next = 32;
                          break;
                        }

                        _context94.next = 30;
                        return this.modelManager.createConflictedItem(itemResponse);

                      case 30:
                        dup = _context94.sent;

                        if (!itemResponse.deleted && !item.isItemContentEqualWith(dup)) {
                          this.modelManager.addConflictedItem(dup, item);
                        }

                      case 32:
                        _iteratorNormalCompletion45 = true;
                        _context94.next = 8;
                        break;

                      case 35:
                        _context94.next = 41;
                        break;

                      case 37:
                        _context94.prev = 37;
                        _context94.t3 = _context94["catch"](6);
                        _didIteratorError45 = true;
                        _iteratorError45 = _context94.t3;

                      case 41:
                        _context94.prev = 41;
                        _context94.prev = 42;

                        if (!_iteratorNormalCompletion45 && _iterator45.return) {
                          _iterator45.return();
                        }

                      case 44:
                        _context94.prev = 44;

                        if (!_didIteratorError45) {
                          _context94.next = 47;
                          break;
                        }

                        throw _iteratorError45;

                      case 47:
                        return _context94.finish(44);

                      case 48:
                        return _context94.finish(41);

                      case 49:
                        // This will immediately result in "Sync op in progress" and sync will be queued.
                        // That's ok. You actually want a sync op in progress so that the new items are saved to disk right away.
                        // If you add a timeout here of 100ms, you'll avoid sync op in progress, but it will be a few ms before the items
                        // are saved to disk, meaning that the user may see All changes saved a few ms before changes are saved to disk.
                        // You could also just write to disk manually here, but syncing here is 100% sure to trigger sync op in progress as that's
                        // where it's being called from.
                        this.sync(null, {
                          additionalFields: ["created_at", "updated_at"]
                        });

                      case 50:
                      case "end":
                        return _context94.stop();
                    }
                  }
                }, _callee94, this, [[6, 37, 41, 49], [42,, 44, 48]]);
              }));

              function handleUnsavedItemsResponse(_x121) {
                return _ref100.apply(this, arguments);
              }

              return handleUnsavedItemsResponse;
            }()
            /*
              Executes a sync request with a blank sync token and high download limit. It will download all items,
              but won't do anything with them other than decrypting, creating respective objects, and returning them to caller. (it does not map them nor establish their relationships)
              The use case came primarly for clients who had ignored a certain content_type in sync, but later issued an update
              indicated they actually did want to start handling that content type. In that case, they would need to download all items
              freshly from the server.
            */

          }, {
            key: "stateless_downloadAllItems",
            value: function stateless_downloadAllItems() {
              var _this24 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return new Promise(function () {
                var _ref101 = _asyncToGenerator(
                /*#__PURE__*/
                regeneratorRuntime.mark(function _callee96(resolve, reject) {
                  var params;
                  return regeneratorRuntime.wrap(function _callee96$(_context96) {
                    while (1) {
                      switch (_context96.prev = _context96.next) {
                        case 0:
                          params = {
                            limit: options.limit || 500,
                            sync_token: options.syncToken,
                            cursor_token: options.cursorToken,
                            content_type: options.contentType,
                            event: options.event
                          };
                          _context96.prev = 1;
                          _context96.t0 = _this24.httpManager;
                          _context96.next = 5;
                          return _this24.getSyncURL();

                        case 5:
                          _context96.t1 = _context96.sent;
                          _context96.t2 = params;

                          _context96.t3 = function () {
                            var _ref102 = _asyncToGenerator(
                            /*#__PURE__*/
                            regeneratorRuntime.mark(function _callee95(response) {
                              var incomingItems, keys;
                              return regeneratorRuntime.wrap(function _callee95$(_context95) {
                                while (1) {
                                  switch (_context95.prev = _context95.next) {
                                    case 0:
                                      if (!options.retrievedItems) {
                                        options.retrievedItems = [];
                                      }

                                      incomingItems = response.retrieved_items;
                                      _context95.next = 4;
                                      return _this24.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);

                                    case 4:
                                      keys = _context95.sent.keys;
                                      _context95.next = 7;
                                      return SFJS.itemTransformer.decryptMultipleItems(incomingItems, keys);

                                    case 7:
                                      options.retrievedItems = options.retrievedItems.concat(incomingItems.map(function (incomingItem) {
                                        // Create model classes
                                        return _this24.modelManager.createItem(incomingItem, true
                                        /* dontNotifyObservers */
                                        );
                                      }));
                                      options.syncToken = response.sync_token;
                                      options.cursorToken = response.cursor_token;

                                      if (options.cursorToken) {
                                        _this24.stateless_downloadAllItems(options).then(resolve);
                                      } else {
                                        resolve(options.retrievedItems);
                                      }

                                    case 11:
                                    case "end":
                                      return _context95.stop();
                                  }
                                }
                              }, _callee95, _this24);
                            }));

                            return function (_x125) {
                              return _ref102.apply(this, arguments);
                            };
                          }();

                          _context96.t4 = function (response, statusCode) {
                            reject(response);
                          };

                          _context96.t0.postAbsolute.call(_context96.t0, _context96.t1, _context96.t2, _context96.t3, _context96.t4);

                          _context96.next = 16;
                          break;

                        case 12:
                          _context96.prev = 12;
                          _context96.t5 = _context96["catch"](1);
                          console.log("Download all items exception caught:", _context96.t5);
                          reject(_context96.t5);

                        case 16:
                        case "end":
                          return _context96.stop();
                      }
                    }
                  }, _callee96, _this24, [[1, 12]]);
                }));

                return function (_x123, _x124) {
                  return _ref101.apply(this, arguments);
                };
              }());
            }
          }, {
            key: "resolveOutOfSync",
            value: function () {
              var _ref103 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee98() {
                var _this25 = this;

                return regeneratorRuntime.wrap(function _callee98$(_context98) {
                  while (1) {
                    switch (_context98.prev = _context98.next) {
                      case 0:
                        return _context98.abrupt("return", this.stateless_downloadAllItems({
                          event: "resolve-out-of-sync"
                        }).then(function () {
                          var _ref104 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee97(downloadedItems) {
                            var itemsToMap, _iteratorNormalCompletion46, _didIteratorError46, _iteratorError46, _iterator46, _step46, downloadedItem, existingItem, contentDoesntMatch, duplicate;

                            return regeneratorRuntime.wrap(function _callee97$(_context97) {
                              while (1) {
                                switch (_context97.prev = _context97.next) {
                                  case 0:
                                    itemsToMap = [];
                                    _iteratorNormalCompletion46 = true;
                                    _didIteratorError46 = false;
                                    _iteratorError46 = undefined;
                                    _context97.prev = 4;
                                    _iterator46 = downloadedItems[Symbol.iterator]();

                                  case 6:
                                    if (_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done) {
                                      _context97.next = 20;
                                      break;
                                    }

                                    downloadedItem = _step46.value; // Note that deleted items will not be sent back by the server.

                                    existingItem = _this25.modelManager.findItem(downloadedItem.uuid);

                                    if (!existingItem) {
                                      _context97.next = 16;
                                      break;
                                    } // Check if the content differs. If it does, create a new item, and do not map downloadedItem.


                                    contentDoesntMatch = !downloadedItem.isItemContentEqualWith(existingItem);

                                    if (!contentDoesntMatch) {
                                      _context97.next = 16;
                                      break;
                                    }

                                    _context97.next = 14;
                                    return _this25.modelManager.createConflictedItem(existingItem, existingItem);

                                  case 14:
                                    duplicate = _context97.sent;

                                    _this25.modelManager.addConflictedItem(duplicate, existingItem);

                                  case 16:
                                    // Map the downloadedItem as authoritive content. If client copy at all differed, we would have created a duplicate of it above and synced it.
                                    // This is also neccessary to map the updated_at value from the server
                                    itemsToMap.push(downloadedItem);

                                  case 17:
                                    _iteratorNormalCompletion46 = true;
                                    _context97.next = 6;
                                    break;

                                  case 20:
                                    _context97.next = 26;
                                    break;

                                  case 22:
                                    _context97.prev = 22;
                                    _context97.t0 = _context97["catch"](4);
                                    _didIteratorError46 = true;
                                    _iteratorError46 = _context97.t0;

                                  case 26:
                                    _context97.prev = 26;
                                    _context97.prev = 27;

                                    if (!_iteratorNormalCompletion46 && _iterator46.return) {
                                      _iterator46.return();
                                    }

                                  case 29:
                                    _context97.prev = 29;

                                    if (!_didIteratorError46) {
                                      _context97.next = 32;
                                      break;
                                    }

                                    throw _iteratorError46;

                                  case 32:
                                    return _context97.finish(29);

                                  case 33:
                                    return _context97.finish(26);

                                  case 34:
                                    _this25.modelManager.mapResponseItemsToLocalModelsWithOptions({
                                      items: itemsToMap,
                                      source: SFModelManager.MappingSourceRemoteRetrieved
                                    }); // Save all items locally. Usually sync() would save downloaded items locally, but we're using stateless_sync here, so we have to do it manually


                                    _context97.next = 37;
                                    return _this25.writeItemsToLocalStorage(_this25.modelManager.allNondummyItems);

                                  case 37:
                                    return _context97.abrupt("return", _this25.sync({
                                      performIntegrityCheck: true
                                    }));

                                  case 38:
                                  case "end":
                                    return _context97.stop();
                                }
                              }
                            }, _callee97, _this25, [[4, 22, 26, 34], [27,, 29, 33]]);
                          }));

                          return function (_x126) {
                            return _ref104.apply(this, arguments);
                          };
                        }()));

                      case 1:
                      case "end":
                        return _context98.stop();
                    }
                  }
                }, _callee98, this);
              }));

              function resolveOutOfSync() {
                return _ref103.apply(this, arguments);
              }

              return resolveOutOfSync;
            }()
          }, {
            key: "handleSignout",
            value: function () {
              var _ref105 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee99() {
                return regeneratorRuntime.wrap(function _callee99$(_context99) {
                  while (1) {
                    switch (_context99.prev = _context99.next) {
                      case 0:
                        this._syncToken = null;
                        this._cursorToken = null;
                        this._queuedCallbacks = [];
                        this.syncStatus = {};

                      case 4:
                      case "end":
                        return _context99.stop();
                    }
                  }
                }, _callee99, this);
              }));

              function handleSignout() {
                return _ref105.apply(this, arguments);
              }

              return handleSignout;
            }()
          }, {
            key: "clearSyncToken",
            value: function () {
              var _ref106 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee100() {
                return regeneratorRuntime.wrap(function _callee100$(_context100) {
                  while (1) {
                    switch (_context100.prev = _context100.next) {
                      case 0:
                        this._syncToken = null;
                        this._cursorToken = null;
                        return _context100.abrupt("return", this.storageManager.removeItem("syncToken"));

                      case 3:
                      case "end":
                        return _context100.stop();
                    }
                  }
                }, _callee100, this);
              }));

              function clearSyncToken() {
                return _ref106.apply(this, arguments);
              }

              return clearSyncToken;
            }()
          }, {
            key: "queuedCallbacks",
            get: function get() {
              if (!this._queuedCallbacks) {
                this._queuedCallbacks = [];
              }

              return this._queuedCallbacks;
            }
          }]);

          return SFSyncManager;
        }();

        ;
        var dateFormatter;

        var SFItem = exports.SFItem = function () {
          function SFItem() {
            var json_obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _classCallCheck(this, SFItem);

            this.content = {};
            this.referencingObjects = [];
            this.updateFromJSON(json_obj);

            if (!this.uuid) {
              // on React Native, this method will not exist. UUID gen will be handled manually via async methods.
              if (typeof SFJS !== "undefined" && SFJS.crypto.generateUUIDSync) {
                this.uuid = SFJS.crypto.generateUUIDSync();
              }
            }

            if (_typeof(this.content) === 'object' && !this.content.references) {
              this.content.references = [];
            }
          } // On some platforms, syncrounous uuid generation is not available.
          // Those platforms (mobile) must call this function manually.


          _createClass(SFItem, [{
            key: "initUUID",
            value: function () {
              var _ref107 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee101() {
                return regeneratorRuntime.wrap(function _callee101$(_context101) {
                  while (1) {
                    switch (_context101.prev = _context101.next) {
                      case 0:
                        if (this.uuid) {
                          _context101.next = 4;
                          break;
                        }

                        _context101.next = 3;
                        return SFJS.crypto.generateUUID();

                      case 3:
                        this.uuid = _context101.sent;

                      case 4:
                      case "end":
                        return _context101.stop();
                    }
                  }
                }, _callee101, this);
              }));

              function initUUID() {
                return _ref107.apply(this, arguments);
              }

              return initUUID;
            }()
          }, {
            key: "updateFromJSON",
            value: function updateFromJSON(json) {
              // Don't expect this to ever be the case but we're having a crash with Android and this is the only suspect.
              if (!json) {
                return;
              } // Manually merge top level data instead of wholesale merge


              this.created_at = json.created_at;
              this.updated_at = json.updated_at;
              this.deleted = json.deleted;
              this.uuid = json.uuid;
              this.enc_item_key = json.enc_item_key;
              this.auth_hash = json.auth_hash;
              this.auth_params = json.auth_params; // When updating from server response (as opposed to local json response), these keys will be missing.
              // So we only want to update these values if they are explicitly present.

              var clientKeys = ["errorDecrypting", "dirty", "dirtyCount", "dummy"];
              var _iteratorNormalCompletion47 = true;
              var _didIteratorError47 = false;
              var _iteratorError47 = undefined;

              try {
                for (var _iterator47 = clientKeys[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
                  var key = _step47.value;

                  if (json[key] !== undefined) {
                    this[key] = json[key];
                  }
                } // Check if object has getter for content_type, and if so, skip

              } catch (err) {
                _didIteratorError47 = true;
                _iteratorError47 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion47 && _iterator47.return) {
                    _iterator47.return();
                  }
                } finally {
                  if (_didIteratorError47) {
                    throw _iteratorError47;
                  }
                }
              }

              if (!this.content_type) {
                this.content_type = json.content_type;
              } // this.content = json.content will copy it by reference rather than value. So we need to do a deep merge after.
              // json.content can still be a string here. We copy it to this.content, then do a deep merge to transfer over all values.


              if (json.errorDecrypting) {
                this.content = json.content;
              } else {
                try {
                  var parsedContent = typeof json.content === 'string' ? JSON.parse(json.content) : json.content;
                  SFItem.deepMerge(this.contentObject, parsedContent);
                } catch (e) {
                  console.log("Error while updating item from json", e);
                }
              }

              if (this.created_at) {
                this.created_at = new Date(this.created_at);
                this.updated_at = new Date(this.updated_at);
              } else {
                this.created_at = new Date();
                this.updated_at = new Date();
              } // Allows the getter to be re-invoked


              this._client_updated_at = null;

              if (json.content) {
                this.mapContentToLocalProperties(this.contentObject);
              } else if (json.deleted == true) {
                this.handleDeletedContent();
              }
            }
          }, {
            key: "mapContentToLocalProperties",
            value: function mapContentToLocalProperties(contentObj) {}
          }, {
            key: "createContentJSONFromProperties",
            value: function createContentJSONFromProperties() {
              /*
              NOTE: This function does have side effects and WILL modify our content.
               Subclasses will override structureParams, and add their own custom content and properties to the object returned from structureParams
              These are properties that this superclass will not be aware of, like 'title' or 'text'
               When we call createContentJSONFromProperties, we want to update our own inherit 'content' field with the values returned from structureParams,
              so that our content field is up to date.
               Each subclass will call super.structureParams and merge it with its own custom result object.
              Since our own structureParams gets a real-time copy of our content, it should be safe to merge the aggregate value back into our own content field.
              */
              var content = this.structureParams();
              SFItem.deepMerge(this.contentObject, content); // Return the content item copy and not our actual value, as we don't want it to be mutated outside our control.

              return content;
            }
          }, {
            key: "structureParams",
            value: function structureParams() {
              return this.getContentCopy();
            }
            /* Allows the item to handle the case where the item is deleted and the content is null */

          }, {
            key: "handleDeletedContent",
            value: function handleDeletedContent() {// Subclasses can override
            }
          }, {
            key: "setDirty",
            value: function setDirty(dirty, dontUpdateClientDate) {
              this.dirty = dirty; // Allows the syncManager to check if an item has been marked dirty after a sync has been started
              // This prevents it from clearing it as a dirty item after sync completion, if someone else has marked it dirty
              // again after an ongoing sync.

              if (!this.dirtyCount) {
                this.dirtyCount = 0;
              }

              if (dirty) {
                this.dirtyCount++;
              } else {
                this.dirtyCount = 0;
              }

              if (dirty && !dontUpdateClientDate) {
                // Set the client modified date to now if marking the item as dirty
                this.client_updated_at = new Date();
              } else if (!this.hasRawClientUpdatedAtValue()) {
                // copy updated_at
                this.client_updated_at = new Date(this.updated_at);
              }
            }
          }, {
            key: "updateLocalRelationships",
            value: function updateLocalRelationships() {// optional override
            }
          }, {
            key: "addItemAsRelationship",
            value: function addItemAsRelationship(item) {
              item.setIsBeingReferencedBy(this);

              if (this.hasRelationshipWithItem(item)) {
                return;
              }

              var references = this.content.references || [];
              references.push({
                uuid: item.uuid,
                content_type: item.content_type
              });
              this.content.references = references;
            }
          }, {
            key: "removeItemAsRelationship",
            value: function removeItemAsRelationship(item) {
              item.setIsNoLongerBeingReferencedBy(this);
              this.removeReferenceWithUuid(item.uuid);
            } // When another object has a relationship with us, we push that object into memory here.
            // We use this so that when `this` is deleted, we're able to update the references of those other objects.

          }, {
            key: "setIsBeingReferencedBy",
            value: function setIsBeingReferencedBy(item) {
              if (!_.find(this.referencingObjects, {
                uuid: item.uuid
              })) {
                this.referencingObjects.push(item);
              }
            }
          }, {
            key: "setIsNoLongerBeingReferencedBy",
            value: function setIsNoLongerBeingReferencedBy(item) {
              _.remove(this.referencingObjects, {
                uuid: item.uuid
              }); // Legacy two-way relationships should be handled here


              if (this.hasRelationshipWithItem(item)) {
                this.removeReferenceWithUuid(item.uuid); // We really shouldn't have the authority to set this item as dirty, but it's the only way to save this change.

                this.setDirty(true);
              }
            }
          }, {
            key: "removeReferenceWithUuid",
            value: function removeReferenceWithUuid(uuid) {
              var references = this.content.references || [];
              references = references.filter(function (r) {
                return r.uuid != uuid;
              });
              this.content.references = references;
            }
          }, {
            key: "hasRelationshipWithItem",
            value: function hasRelationshipWithItem(item) {
              var target = this.content.references.find(function (r) {
                return r.uuid == item.uuid;
              });
              return target != null;
            }
          }, {
            key: "isBeingRemovedLocally",
            value: function isBeingRemovedLocally() {}
          }, {
            key: "didFinishSyncing",
            value: function didFinishSyncing() {}
          }, {
            key: "informReferencesOfUUIDChange",
            value: function informReferencesOfUUIDChange(oldUUID, newUUID) {// optional override
            }
          }, {
            key: "potentialItemOfInterestHasChangedItsUUID",
            value: function potentialItemOfInterestHasChangedItsUUID(newItem, oldUUID, newUUID) {
              // optional override
              var _iteratorNormalCompletion48 = true;
              var _didIteratorError48 = false;
              var _iteratorError48 = undefined;

              try {
                for (var _iterator48 = this.content.references[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
                  var reference = _step48.value;

                  if (reference.uuid == oldUUID) {
                    reference.uuid = newUUID;
                    this.setDirty(true);
                  }
                }
              } catch (err) {
                _didIteratorError48 = true;
                _iteratorError48 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion48 && _iterator48.return) {
                    _iterator48.return();
                  }
                } finally {
                  if (_didIteratorError48) {
                    throw _iteratorError48;
                  }
                }
              }
            }
          }, {
            key: "doNotEncrypt",
            value: function doNotEncrypt() {
              return false;
            }
            /*
            App Data
            */

          }, {
            key: "setDomainDataItem",
            value: function setDomainDataItem(key, value, domain) {
              if (!domain) {
                console.error("SFItem.AppDomain needs to be set.");
                return;
              }

              if (this.errorDecrypting) {
                return;
              }

              if (!this.content.appData) {
                this.content.appData = {};
              }

              var data = this.content.appData[domain];

              if (!data) {
                data = {};
              }

              data[key] = value;
              this.content.appData[domain] = data;
            }
          }, {
            key: "getDomainDataItem",
            value: function getDomainDataItem(key, domain) {
              if (!domain) {
                console.error("SFItem.AppDomain needs to be set.");
                return;
              }

              if (this.errorDecrypting) {
                return;
              }

              if (!this.content.appData) {
                this.content.appData = {};
              }

              var data = this.content.appData[domain];

              if (data) {
                return data[key];
              } else {
                return null;
              }
            }
          }, {
            key: "setAppDataItem",
            value: function setAppDataItem(key, value) {
              this.setDomainDataItem(key, value, SFItem.AppDomain);
            }
          }, {
            key: "getAppDataItem",
            value: function getAppDataItem(key) {
              return this.getDomainDataItem(key, SFItem.AppDomain);
            }
          }, {
            key: "hasRawClientUpdatedAtValue",
            value: function hasRawClientUpdatedAtValue() {
              return this.getAppDataItem("client_updated_at") != null;
            }
          }, {
            key: "keysToIgnoreWhenCheckingContentEquality",

            /*
              During sync conflicts, when determing whether to create a duplicate for an item, we can omit keys that have no
              meaningful weight and can be ignored. For example, if one component has active = true and another component has active = false,
              it would be silly to duplicate them, so instead we ignore this.
             */
            value: function keysToIgnoreWhenCheckingContentEquality() {
              return [];
            } // Same as above, but keys inside appData[Item.AppDomain]

          }, {
            key: "appDataKeysToIgnoreWhenCheckingContentEquality",
            value: function appDataKeysToIgnoreWhenCheckingContentEquality() {
              return ["client_updated_at"];
            }
          }, {
            key: "getContentCopy",
            value: function getContentCopy() {
              var contentCopy = JSON.parse(JSON.stringify(this.content));
              return contentCopy;
            }
          }, {
            key: "isItemContentEqualWith",
            value: function isItemContentEqualWith(otherItem) {
              var omit = function omit(obj, keys) {
                if (!obj) {
                  return obj;
                }

                var _iteratorNormalCompletion49 = true;
                var _didIteratorError49 = false;
                var _iteratorError49 = undefined;

                try {
                  for (var _iterator49 = keys[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {
                    var key = _step49.value;
                    delete obj[key];
                  }
                } catch (err) {
                  _didIteratorError49 = true;
                  _iteratorError49 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion49 && _iterator49.return) {
                      _iterator49.return();
                    }
                  } finally {
                    if (_didIteratorError49) {
                      throw _iteratorError49;
                    }
                  }
                }

                return obj;
              }; // Create copies of objects before running omit as not to modify source values directly.


              var leftContent = this.getContentCopy();

              if (leftContent.appData) {
                omit(leftContent.appData[SFItem.AppDomain], this.appDataKeysToIgnoreWhenCheckingContentEquality());
              }

              leftContent = omit(leftContent, this.keysToIgnoreWhenCheckingContentEquality());
              var rightContent = otherItem.getContentCopy();

              if (rightContent.appData) {
                omit(rightContent.appData[SFItem.AppDomain], otherItem.appDataKeysToIgnoreWhenCheckingContentEquality());
              }

              rightContent = omit(rightContent, otherItem.keysToIgnoreWhenCheckingContentEquality());
              return JSON.stringify(leftContent) === JSON.stringify(rightContent);
            }
          }, {
            key: "satisfiesPredicate",
            value: function satisfiesPredicate(predicate) {
              /*
              Predicate is an SFPredicate having properties:
              {
                keypath: String,
                operator: String,
                value: object
              }
               */
              return SFPredicate.ItemSatisfiesPredicate(this, predicate);
            }
            /*
            Dates
            */

          }, {
            key: "createdAtString",
            value: function createdAtString() {
              return this.dateToLocalizedString(this.created_at);
            }
          }, {
            key: "updatedAtString",
            value: function updatedAtString() {
              return this.dateToLocalizedString(this.client_updated_at);
            }
          }, {
            key: "updatedAtTimestamp",
            value: function updatedAtTimestamp() {
              return this.updated_at.getTime();
            }
          }, {
            key: "dateToLocalizedString",
            value: function dateToLocalizedString(date) {
              if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
                if (!dateFormatter) {
                  var locale = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language;
                  dateFormatter = new Intl.DateTimeFormat(locale, {
                    year: 'numeric',
                    month: 'short',
                    day: '2-digit',
                    weekday: 'long',
                    hour: '2-digit',
                    minute: '2-digit'
                  });
                }

                return dateFormatter.format(date);
              } else {
                // IE < 11, Safari <= 9.0.
                // In English, this generates the string most similar to
                // the toLocaleDateString() result above.
                return date.toDateString() + ' ' + date.toLocaleTimeString();
              }
            }
          }, {
            key: "contentObject",
            get: function get() {
              if (this.errorDecrypting) {
                return this.content;
              }

              if (!this.content) {
                this.content = {};
                return this.content;
              }

              if (this.content !== null && _typeof(this.content) === 'object') {
                // this is the case when mapping localStorage content, in which case the content is already parsed
                return this.content;
              }

              try {
                var content = JSON.parse(this.content);
                this.content = content;
                return this.content;
              } catch (e) {
                console.log("Error parsing json", e, this);
                this.content = {};
                return this.content;
              }
            }
          }, {
            key: "pinned",
            get: function get() {
              return this.getAppDataItem("pinned");
            }
          }, {
            key: "archived",
            get: function get() {
              return this.getAppDataItem("archived");
            }
          }, {
            key: "locked",
            get: function get() {
              return this.getAppDataItem("locked");
            } // May be used by clients to display the human readable type for this item. Should be overriden by subclasses.

          }, {
            key: "displayName",
            get: function get() {
              return "Item";
            }
          }, {
            key: "client_updated_at",
            get: function get() {
              if (!this._client_updated_at) {
                var saved = this.getAppDataItem("client_updated_at");

                if (saved) {
                  this._client_updated_at = new Date(saved);
                } else {
                  this._client_updated_at = new Date(this.updated_at);
                }
              }

              return this._client_updated_at;
            },
            set: function set(date) {
              this._client_updated_at = date;
              this.setAppDataItem("client_updated_at", date);
            }
          }], [{
            key: "deepMerge",
            value: function deepMerge(a, b) {
              // By default _.merge will not merge a full array with an empty one.
              // We want to replace arrays wholesale
              function mergeCopyArrays(objValue, srcValue) {
                if (_.isArray(objValue)) {
                  return srcValue;
                }
              }

              _.mergeWith(a, b, mergeCopyArrays);

              return a;
            }
          }]);

          return SFItem;
        }();

        ;

        var SFItemParams = exports.SFItemParams = function () {
          function SFItemParams(item, keys, auth_params) {
            _classCallCheck(this, SFItemParams);

            this.item = item;
            this.keys = keys;
            this.auth_params = auth_params;

            if (this.keys && !this.auth_params) {
              throw "SFItemParams.auth_params must be supplied if supplying keys.";
            }

            if (this.auth_params && !this.auth_params.version) {
              throw "SFItemParams.auth_params is missing version";
            }
          }

          _createClass(SFItemParams, [{
            key: "paramsForExportFile",
            value: function () {
              var _ref108 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee102(includeDeleted) {
                var result;
                return regeneratorRuntime.wrap(function _callee102$(_context102) {
                  while (1) {
                    switch (_context102.prev = _context102.next) {
                      case 0:
                        this.additionalFields = ["updated_at"];
                        this.forExportFile = true;

                        if (!includeDeleted) {
                          _context102.next = 6;
                          break;
                        }

                        return _context102.abrupt("return", this.__params());

                      case 6:
                        _context102.next = 8;
                        return this.__params();

                      case 8:
                        result = _context102.sent;
                        return _context102.abrupt("return", _.omit(result, ["deleted"]));

                      case 10:
                      case "end":
                        return _context102.stop();
                    }
                  }
                }, _callee102, this);
              }));

              function paramsForExportFile(_x128) {
                return _ref108.apply(this, arguments);
              }

              return paramsForExportFile;
            }()
          }, {
            key: "paramsForExtension",
            value: function () {
              var _ref109 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee103() {
                return regeneratorRuntime.wrap(function _callee103$(_context103) {
                  while (1) {
                    switch (_context103.prev = _context103.next) {
                      case 0:
                        return _context103.abrupt("return", this.paramsForExportFile());

                      case 1:
                      case "end":
                        return _context103.stop();
                    }
                  }
                }, _callee103, this);
              }));

              function paramsForExtension() {
                return _ref109.apply(this, arguments);
              }

              return paramsForExtension;
            }()
          }, {
            key: "paramsForLocalStorage",
            value: function () {
              var _ref110 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee104() {
                return regeneratorRuntime.wrap(function _callee104$(_context104) {
                  while (1) {
                    switch (_context104.prev = _context104.next) {
                      case 0:
                        this.additionalFields = ["updated_at", "dirty", "errorDecrypting"];
                        this.forExportFile = true;
                        return _context104.abrupt("return", this.__params());

                      case 3:
                      case "end":
                        return _context104.stop();
                    }
                  }
                }, _callee104, this);
              }));

              function paramsForLocalStorage() {
                return _ref110.apply(this, arguments);
              }

              return paramsForLocalStorage;
            }()
          }, {
            key: "paramsForSync",
            value: function () {
              var _ref111 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee105() {
                return regeneratorRuntime.wrap(function _callee105$(_context105) {
                  while (1) {
                    switch (_context105.prev = _context105.next) {
                      case 0:
                        return _context105.abrupt("return", this.__params());

                      case 1:
                      case "end":
                        return _context105.stop();
                    }
                  }
                }, _callee105, this);
              }));

              function paramsForSync() {
                return _ref111.apply(this, arguments);
              }

              return paramsForSync;
            }()
          }, {
            key: "__params",
            value: function () {
              var _ref112 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee106() {
                var params, doNotEncrypt, encryptedParams;
                return regeneratorRuntime.wrap(function _callee106$(_context106) {
                  while (1) {
                    switch (_context106.prev = _context106.next) {
                      case 0:
                        params = {
                          uuid: this.item.uuid,
                          content_type: this.item.content_type,
                          deleted: this.item.deleted,
                          created_at: this.item.created_at
                        };

                        if (this.item.errorDecrypting) {
                          _context106.next = 23;
                          break;
                        } // Items should always be encrypted for export files. Only respect item.doNotEncrypt for remote sync params.


                        doNotEncrypt = this.item.doNotEncrypt() && !this.forExportFile;

                        if (!(this.keys && !doNotEncrypt)) {
                          _context106.next = 11;
                          break;
                        }

                        _context106.next = 6;
                        return SFJS.itemTransformer.encryptItem(this.item, this.keys, this.auth_params);

                      case 6:
                        encryptedParams = _context106.sent;

                        _.merge(params, encryptedParams);

                        if (this.auth_params.version !== "001") {
                          params.auth_hash = null;
                        }

                        _context106.next = 21;
                        break;

                      case 11:
                        if (!this.forExportFile) {
                          _context106.next = 15;
                          break;
                        }

                        _context106.t0 = this.item.createContentJSONFromProperties();
                        _context106.next = 19;
                        break;

                      case 15:
                        _context106.next = 17;
                        return SFJS.crypto.base64(JSON.stringify(this.item.createContentJSONFromProperties()));

                      case 17:
                        _context106.t1 = _context106.sent;
                        _context106.t0 = "000" + _context106.t1;

                      case 19:
                        params.content = _context106.t0;

                        if (!this.forExportFile) {
                          params.enc_item_key = null;
                          params.auth_hash = null;
                        }

                      case 21:
                        _context106.next = 26;
                        break;

                      case 23:
                        // Error decrypting, keep "content" and related fields as is (and do not try to encrypt, otherwise that would be undefined behavior)
                        params.content = this.item.content;
                        params.enc_item_key = this.item.enc_item_key;
                        params.auth_hash = this.item.auth_hash;

                      case 26:
                        if (this.additionalFields) {
                          _.merge(params, _.pick(this.item, this.additionalFields));
                        }

                        return _context106.abrupt("return", params);

                      case 28:
                      case "end":
                        return _context106.stop();
                    }
                  }
                }, _callee106, this);
              }));

              function __params() {
                return _ref112.apply(this, arguments);
              }

              return __params;
            }()
          }]);

          return SFItemParams;
        }();

        ;

        var SFPredicate = exports.SFPredicate = function () {
          function SFPredicate(keypath, operator, value) {
            _classCallCheck(this, SFPredicate);

            this.keypath = keypath;
            this.operator = operator;
            this.value = value; // Preprocessing to make predicate evaluation faster.
            // Won't recurse forever, but with arbitrarily large input could get stuck. Hope there are input size limits
            // somewhere else.

            if (SFPredicate.IsRecursiveOperator(this.operator)) {
              this.value = this.value.map(SFPredicate.fromArray);
            }
          }

          _createClass(SFPredicate, null, [{
            key: "fromArray",
            value: function fromArray(array) {
              return new SFPredicate(array[0], array[1], array[2]);
            }
          }, {
            key: "ObjectSatisfiesPredicate",
            value: function ObjectSatisfiesPredicate(object, predicate) {
              // Predicates may not always be created using the official constructor
              // so if it's still an array here, convert to object
              if (Array.isArray(predicate)) {
                predicate = this.fromArray(predicate);
              }

              if (SFPredicate.IsRecursiveOperator(predicate.operator)) {
                if (predicate.operator === "and") {
                  var _iteratorNormalCompletion50 = true;
                  var _didIteratorError50 = false;
                  var _iteratorError50 = undefined;

                  try {
                    for (var _iterator50 = predicate.value[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
                      var subPredicate = _step50.value;

                      if (!this.ObjectSatisfiesPredicate(object, subPredicate)) {
                        return false;
                      }
                    }
                  } catch (err) {
                    _didIteratorError50 = true;
                    _iteratorError50 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion50 && _iterator50.return) {
                        _iterator50.return();
                      }
                    } finally {
                      if (_didIteratorError50) {
                        throw _iteratorError50;
                      }
                    }
                  }

                  return true;
                }

                if (predicate.operator === "or") {
                  var _iteratorNormalCompletion51 = true;
                  var _didIteratorError51 = false;
                  var _iteratorError51 = undefined;

                  try {
                    for (var _iterator51 = predicate.value[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {
                      var subPredicate = _step51.value;

                      if (this.ObjectSatisfiesPredicate(object, subPredicate)) {
                        return true;
                      }
                    }
                  } catch (err) {
                    _didIteratorError51 = true;
                    _iteratorError51 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion51 && _iterator51.return) {
                        _iterator51.return();
                      }
                    } finally {
                      if (_didIteratorError51) {
                        throw _iteratorError51;
                      }
                    }
                  }

                  return false;
                }
              }

              var predicateValue = predicate.value;

              if (typeof predicateValue == 'string' && predicateValue.includes(".ago")) {
                predicateValue = this.DateFromString(predicateValue);
              }

              var valueAtKeyPath = predicate.keypath.split('.').reduce(function (previous, current) {
                return previous && previous[current];
              }, object);
              var falseyValues = [false, "", null, undefined, NaN]; // If the value at keyPath is undefined, either because the property is nonexistent or the value is null.

              if (valueAtKeyPath == undefined) {
                if (predicate.operator == "!=") {
                  return !falseyValues.includes(predicate.value);
                } else {
                  return falseyValues.includes(predicate.value);
                }
              }

              if (predicate.operator == "=") {
                // Use array comparison
                if (Array.isArray(valueAtKeyPath)) {
                  return JSON.stringify(valueAtKeyPath) == JSON.stringify(predicateValue);
                } else {
                  return valueAtKeyPath == predicateValue;
                }
              } else if (predicate.operator == "!=") {
                // Use array comparison
                if (Array.isArray(valueAtKeyPath)) {
                  return JSON.stringify(valueAtKeyPath) != JSON.stringify(predicateValue);
                } else {
                  return valueAtKeyPath !== predicateValue;
                }
              } else if (predicate.operator == "<") {
                return valueAtKeyPath < predicateValue;
              } else if (predicate.operator == ">") {
                return valueAtKeyPath > predicateValue;
              } else if (predicate.operator == "<=") {
                return valueAtKeyPath <= predicateValue;
              } else if (predicate.operator == ">=") {
                return valueAtKeyPath >= predicateValue;
              } else if (predicate.operator == "startsWith") {
                return valueAtKeyPath.startsWith(predicateValue);
              } else if (predicate.operator == "in") {
                return predicateValue.indexOf(valueAtKeyPath) != -1;
              } else if (predicate.operator == "includes") {
                return this.resolveIncludesPredicate(valueAtKeyPath, predicateValue);
              } else if (predicate.operator == "matches") {
                var regex = new RegExp(predicateValue);
                return regex.test(valueAtKeyPath);
              }

              return false;
            }
          }, {
            key: "resolveIncludesPredicate",
            value: function resolveIncludesPredicate(valueAtKeyPath, predicateValue) {
              // includes can be a string  or a predicate (in array form)
              if (typeof predicateValue == 'string') {
                // if string, simply check if the valueAtKeyPath includes the predicate value
                return valueAtKeyPath.includes(predicateValue);
              } else {
                // is a predicate array or predicate object
                var innerPredicate;

                if (Array.isArray(predicateValue)) {
                  innerPredicate = SFPredicate.fromArray(predicateValue);
                } else {
                  innerPredicate = predicateValue;
                }

                var _iteratorNormalCompletion52 = true;
                var _didIteratorError52 = false;
                var _iteratorError52 = undefined;

                try {
                  for (var _iterator52 = valueAtKeyPath[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
                    var obj = _step52.value;

                    if (this.ObjectSatisfiesPredicate(obj, innerPredicate)) {
                      return true;
                    }
                  }
                } catch (err) {
                  _didIteratorError52 = true;
                  _iteratorError52 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion52 && _iterator52.return) {
                      _iterator52.return();
                    }
                  } finally {
                    if (_didIteratorError52) {
                      throw _iteratorError52;
                    }
                  }
                }

                return false;
              }
            }
          }, {
            key: "ItemSatisfiesPredicate",
            value: function ItemSatisfiesPredicate(item, predicate) {
              if (Array.isArray(predicate)) {
                predicate = SFPredicate.fromArray(predicate);
              }

              return this.ObjectSatisfiesPredicate(item, predicate);
            }
          }, {
            key: "ItemSatisfiesPredicates",
            value: function ItemSatisfiesPredicates(item, predicates) {
              var _iteratorNormalCompletion53 = true;
              var _didIteratorError53 = false;
              var _iteratorError53 = undefined;

              try {
                for (var _iterator53 = predicates[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
                  var predicate = _step53.value;

                  if (!this.ItemSatisfiesPredicate(item, predicate)) {
                    return false;
                  }
                }
              } catch (err) {
                _didIteratorError53 = true;
                _iteratorError53 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion53 && _iterator53.return) {
                    _iterator53.return();
                  }
                } finally {
                  if (_didIteratorError53) {
                    throw _iteratorError53;
                  }
                }
              }

              return true;
            }
          }, {
            key: "DateFromString",
            value: function DateFromString(string) {
              // x.days.ago, x.hours.ago
              var comps = string.split(".");
              var unit = comps[1];
              var date = new Date();
              var offset = parseInt(comps[0]);

              if (unit == "days") {
                date.setDate(date.getDate() - offset);
              } else if (unit == "hours") {
                date.setHours(date.getHours() - offset);
              }

              return date;
            }
          }, {
            key: "IsRecursiveOperator",
            value: function IsRecursiveOperator(operator) {
              return ["and", "or"].includes(operator);
            }
          }]);

          return SFPredicate;
        }();

        ;

        var SFPrivileges = exports.SFPrivileges = function (_SFItem) {
          _inherits(SFPrivileges, _SFItem);

          _createClass(SFPrivileges, null, [{
            key: "contentType",
            value: function contentType() {
              // It has prefix SN since it was originally imported from SN codebase
              return "SN|Privileges";
            }
          }]);

          function SFPrivileges(json_obj) {
            _classCallCheck(this, SFPrivileges);

            var _this26 = _possibleConstructorReturn(this, (SFPrivileges.__proto__ || Object.getPrototypeOf(SFPrivileges)).call(this, json_obj));

            if (!_this26.content.desktopPrivileges) {
              _this26.content.desktopPrivileges = {};
            }

            return _this26;
          }

          _createClass(SFPrivileges, [{
            key: "setCredentialsForAction",
            value: function setCredentialsForAction(action, credentials) {
              this.content.desktopPrivileges[action] = credentials;
            }
          }, {
            key: "getCredentialsForAction",
            value: function getCredentialsForAction(action) {
              return this.content.desktopPrivileges[action] || [];
            }
          }, {
            key: "toggleCredentialForAction",
            value: function toggleCredentialForAction(action, credential) {
              if (this.isCredentialRequiredForAction(action, credential)) {
                this.removeCredentialForAction(action, credential);
              } else {
                this.addCredentialForAction(action, credential);
              }
            }
          }, {
            key: "removeCredentialForAction",
            value: function removeCredentialForAction(action, credential) {
              _.pull(this.content.desktopPrivileges[action], credential);
            }
          }, {
            key: "addCredentialForAction",
            value: function addCredentialForAction(action, credential) {
              var credentials = this.getCredentialsForAction(action);
              credentials.push(credential);
              this.setCredentialsForAction(action, credentials);
            }
          }, {
            key: "isCredentialRequiredForAction",
            value: function isCredentialRequiredForAction(action, credential) {
              var credentialsRequired = this.getCredentialsForAction(action);
              return credentialsRequired.includes(credential);
            }
          }]);

          return SFPrivileges;
        }(SFItem);

        ;
        /*
         Important: This is the only object in the session history domain that is persistable.
          A history session contains one main content object:
         the itemUUIDToItemHistoryMapping. This is a dictionary whose keys are item uuids,
         and each value is an SFItemHistory object.
          Each SFItemHistory object contains an array called `entires` which contain `SFItemHistory` entries (or subclasses, if the
         `SFItemHistory.HistoryEntryClassMapping` class property value is set.)
        */
        // See default class values at bottom of this file, including `SFHistorySession.LargeItemEntryAmountThreshold`.

        var SFHistorySession = exports.SFHistorySession = function (_SFItem2) {
          _inherits(SFHistorySession, _SFItem2);

          function SFHistorySession(json_obj) {
            _classCallCheck(this, SFHistorySession);
            /*
              Our .content params:
              {
                itemUUIDToItemHistoryMapping
              }
             */


            var _this27 = _possibleConstructorReturn(this, (SFHistorySession.__proto__ || Object.getPrototypeOf(SFHistorySession)).call(this, json_obj));

            if (!_this27.content.itemUUIDToItemHistoryMapping) {
              _this27.content.itemUUIDToItemHistoryMapping = {};
            } // When initializing from a json_obj, we want to deserialize the item history JSON into SFItemHistory objects.


            var uuids = Object.keys(_this27.content.itemUUIDToItemHistoryMapping);
            uuids.forEach(function (itemUUID) {
              var itemHistory = _this27.content.itemUUIDToItemHistoryMapping[itemUUID];
              _this27.content.itemUUIDToItemHistoryMapping[itemUUID] = new SFItemHistory(itemHistory);
            });
            return _this27;
          }

          _createClass(SFHistorySession, [{
            key: "addEntryForItem",
            value: function addEntryForItem(item) {
              var itemHistory = this.historyForItem(item);
              var entry = itemHistory.addHistoryEntryForItem(item);
              return entry;
            }
          }, {
            key: "historyForItem",
            value: function historyForItem(item) {
              var history = this.content.itemUUIDToItemHistoryMapping[item.uuid];

              if (!history) {
                history = this.content.itemUUIDToItemHistoryMapping[item.uuid] = new SFItemHistory();
              }

              return history;
            }
          }, {
            key: "clearItemHistory",
            value: function clearItemHistory(item) {
              this.historyForItem(item).clear();
            }
          }, {
            key: "clearAllHistory",
            value: function clearAllHistory() {
              this.content.itemUUIDToItemHistoryMapping = {};
            }
          }, {
            key: "optimizeHistoryForItem",
            value: function optimizeHistoryForItem(item) {
              // Clean up if there are too many revisions. Note SFHistorySession.LargeItemEntryAmountThreshold is the amount of revisions which above, call
              // for an optimization. An optimization may not remove entries above this threshold. It will determine what it should keep and what it shouldn't.
              // So, it is possible to have a threshold of 60 but have 600 entries, if the item history deems those worth keeping.
              var itemHistory = this.historyForItem(item);

              if (itemHistory.entries.length > SFHistorySession.LargeItemEntryAmountThreshold) {
                itemHistory.optimize();
              }
            }
          }]);

          return SFHistorySession;
        }(SFItem); // See comment in `this.optimizeHistoryForItem`


        SFHistorySession.LargeItemEntryAmountThreshold = 60;
        ; // See default class values at bottom of this file, including `SFItemHistory.LargeEntryDeltaThreshold`.

        var SFItemHistory = exports.SFItemHistory = function () {
          function SFItemHistory() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _classCallCheck(this, SFItemHistory);

            if (!this.entries) {
              this.entries = [];
            } // Deserialize the entries into entry objects.


            if (params.entries) {
              var _iteratorNormalCompletion54 = true;
              var _didIteratorError54 = false;
              var _iteratorError54 = undefined;

              try {
                for (var _iterator54 = params.entries[Symbol.iterator](), _step54; !(_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done); _iteratorNormalCompletion54 = true) {
                  var entryParams = _step54.value;
                  var entry = this.createEntryForItem(entryParams.item);
                  entry.setPreviousEntry(this.getLastEntry());
                  this.entries.push(entry);
                }
              } catch (err) {
                _didIteratorError54 = true;
                _iteratorError54 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion54 && _iterator54.return) {
                    _iterator54.return();
                  }
                } finally {
                  if (_didIteratorError54) {
                    throw _iteratorError54;
                  }
                }
              }
            }
          }

          _createClass(SFItemHistory, [{
            key: "createEntryForItem",
            value: function createEntryForItem(item) {
              var historyItemClass = SFItemHistory.HistoryEntryClassMapping && SFItemHistory.HistoryEntryClassMapping[item.content_type];

              if (!historyItemClass) {
                historyItemClass = SFItemHistoryEntry;
              }

              var entry = new historyItemClass(item);
              return entry;
            }
          }, {
            key: "getLastEntry",
            value: function getLastEntry() {
              return this.entries[this.entries.length - 1];
            }
          }, {
            key: "addHistoryEntryForItem",
            value: function addHistoryEntryForItem(item) {
              var prospectiveEntry = this.createEntryForItem(item);
              var previousEntry = this.getLastEntry();
              prospectiveEntry.setPreviousEntry(previousEntry); // Don't add first revision if text length is 0, as this means it's a new note.
              // Actually, nevermind. If we do this, the first character added to a new note
              // will be displayed as "1 characters loaded".
              // if(!previousRevision && prospectiveRevision.textCharDiffLength == 0) {
              //   return;
              // }
              // Don't add if text is the same

              if (prospectiveEntry.isSameAsEntry(previousEntry)) {
                return;
              }

              this.entries.push(prospectiveEntry);
              return prospectiveEntry;
            }
          }, {
            key: "clear",
            value: function clear() {
              this.entries.length = 0;
            }
          }, {
            key: "optimize",
            value: function optimize() {
              var _this28 = this;

              var keepEntries = [];

              var isEntrySignificant = function isEntrySignificant(entry) {
                return entry.deltaSize() > SFItemHistory.LargeEntryDeltaThreshold;
              };

              var processEntry = function processEntry(entry, index, keep) {
                // Entries may be processed retrospectively, meaning it can be decided to be deleted, then an upcoming processing can change that.
                if (keep) {
                  keepEntries.push(entry);
                } else {
                  // Remove if in keep
                  var index = keepEntries.indexOf(entry);

                  if (index !== -1) {
                    keepEntries.splice(index, 1);
                  }
                }

                if (keep && isEntrySignificant(entry) && entry.operationVector() == -1) {
                  // This is a large negative change. Hang on to the previous entry.
                  var previousEntry = _this28.entries[index - 1];

                  if (previousEntry) {
                    keepEntries.push(previousEntry);
                  }
                }
              };

              this.entries.forEach(function (entry, index) {
                if (index == 0 || index == _this28.entries.length - 1) {
                  // Keep the first and last
                  processEntry(entry, index, true);
                } else {
                  var significant = isEntrySignificant(entry);
                  processEntry(entry, index, significant);
                }
              });
              this.entries = this.entries.filter(function (entry, index) {
                return keepEntries.indexOf(entry) !== -1;
              });
            }
          }]);

          return SFItemHistory;
        }(); // The amount of characters added or removed that constitute a keepable entry after optimization.


        SFItemHistory.LargeEntryDeltaThreshold = 15;
        ;

        var SFItemHistoryEntry = exports.SFItemHistoryEntry = function () {
          function SFItemHistoryEntry(item) {
            _classCallCheck(this, SFItemHistoryEntry); // Whatever values `item` has will be persisted, so be sure that the values are picked beforehand.


            this.item = SFItem.deepMerge({}, item); // We'll assume a `text` content value to diff on. If it doesn't exist, no problem.

            this.defaultContentKeyToDiffOn = "text"; // Default value

            this.textCharDiffLength = 0;

            if (typeof this.item.updated_at == 'string') {
              this.item.updated_at = new Date(this.item.updated_at);
            }
          }

          _createClass(SFItemHistoryEntry, [{
            key: "setPreviousEntry",
            value: function setPreviousEntry(previousEntry) {
              this.hasPreviousEntry = previousEntry != null; // we'll try to compute the delta based on an assumed content property of `text`, if it exists.

              if (this.item.content[this.defaultContentKeyToDiffOn]) {
                if (previousEntry) {
                  this.textCharDiffLength = this.item.content[this.defaultContentKeyToDiffOn].length - previousEntry.item.content[this.defaultContentKeyToDiffOn].length;
                } else {
                  this.textCharDiffLength = this.item.content[this.defaultContentKeyToDiffOn].length;
                }
              }
            }
          }, {
            key: "operationVector",
            value: function operationVector() {
              // We'll try to use the value of `textCharDiffLength` to help determine this, if it's set
              if (this.textCharDiffLength != undefined) {
                if (!this.hasPreviousEntry || this.textCharDiffLength == 0) {
                  return 0;
                } else if (this.textCharDiffLength < 0) {
                  return -1;
                } else {
                  return 1;
                }
              } // Otherwise use a default value of 1


              return 1;
            }
          }, {
            key: "deltaSize",
            value: function deltaSize() {
              // Up to the subclass to determine how large the delta was, i.e number of characters changed.
              // But this general class won't be able to determine which property it should diff on, or even its format.
              // We can return the `textCharDiffLength` if it's set, otherwise, just return 1;
              if (this.textCharDiffLength != undefined) {
                return Math.abs(this.textCharDiffLength);
              } // Otherwise return 1 here to constitute a basic positive delta.
              // The value returned should always be positive. override `operationVector` to return the direction of the delta.


              return 1;
            }
          }, {
            key: "isSameAsEntry",
            value: function isSameAsEntry(entry) {
              if (!entry) {
                return false;
              }

              var lhs = new SFItem(this.item);
              var rhs = new SFItem(entry.item);
              return lhs.isItemContentEqualWith(rhs);
            }
          }]);

          return SFItemHistoryEntry;
        }();

        ;
        /* Abstract class. Instantiate an instance of either SFCryptoJS (uses cryptojs) or SFCryptoWeb (uses web crypto) */

        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

        var SFAbstractCrypto = exports.SFAbstractCrypto = function () {
          function SFAbstractCrypto() {
            _classCallCheck(this, SFAbstractCrypto);

            this.DefaultPBKDF2Length = 768;
          }
          /*
          Our WebCrypto implementation only offers PBKDf2, so any other encryption
          and key generation functions must use CryptoJS in this abstract implementation.
          */


          _createClass(SFAbstractCrypto, [{
            key: "generateUUIDSync",
            value: function generateUUIDSync() {
              var crypto = globalScope.crypto || globalScope.msCrypto;

              if (crypto) {
                var buf = new Uint32Array(4);
                crypto.getRandomValues(buf);
                var idx = -1;
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                  idx++;
                  var r = buf[idx >> 3] >> idx % 8 * 4 & 15;
                  var v = c == 'x' ? r : r & 0x3 | 0x8;
                  return v.toString(16);
                });
              } else {
                var d = new Date().getTime();

                if (globalScope.performance && typeof globalScope.performance.now === "function") {
                  d += performance.now(); //use high-precision timer if available
                }

                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                  var r = (d + Math.random() * 16) % 16 | 0;
                  d = Math.floor(d / 16);
                  return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
                });
                return uuid;
              }
            }
          }, {
            key: "generateUUID",
            value: function () {
              var _ref113 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee107() {
                return regeneratorRuntime.wrap(function _callee107$(_context107) {
                  while (1) {
                    switch (_context107.prev = _context107.next) {
                      case 0:
                        return _context107.abrupt("return", this.generateUUIDSync());

                      case 1:
                      case "end":
                        return _context107.stop();
                    }
                  }
                }, _callee107, this);
              }));

              function generateUUID() {
                return _ref113.apply(this, arguments);
              }

              return generateUUID;
            }()
          }, {
            key: "decryptText",
            value: function () {
              var _ref114 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee108() {
                var _ref115 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    ciphertextToAuth = _ref115.ciphertextToAuth,
                    contentCiphertext = _ref115.contentCiphertext,
                    encryptionKey = _ref115.encryptionKey,
                    iv = _ref115.iv,
                    authHash = _ref115.authHash,
                    authKey = _ref115.authKey;

                var requiresAuth = arguments[1];
                var localAuthHash, keyData, ivData, decrypted;
                return regeneratorRuntime.wrap(function _callee108$(_context108) {
                  while (1) {
                    switch (_context108.prev = _context108.next) {
                      case 0:
                        if (!(requiresAuth && !authHash)) {
                          _context108.next = 3;
                          break;
                        }

                        console.error("Auth hash is required.");
                        return _context108.abrupt("return");

                      case 3:
                        if (!authHash) {
                          _context108.next = 10;
                          break;
                        }

                        _context108.next = 6;
                        return this.hmac256(ciphertextToAuth, authKey);

                      case 6:
                        localAuthHash = _context108.sent;

                        if (!(authHash !== localAuthHash)) {
                          _context108.next = 10;
                          break;
                        }

                        console.error("Auth hash does not match, returning null.");
                        return _context108.abrupt("return", null);

                      case 10:
                        keyData = CryptoJS.enc.Hex.parse(encryptionKey);
                        ivData = CryptoJS.enc.Hex.parse(iv || "");
                        decrypted = CryptoJS.AES.decrypt(contentCiphertext, keyData, {
                          iv: ivData,
                          mode: CryptoJS.mode.CBC,
                          padding: CryptoJS.pad.Pkcs7
                        });
                        return _context108.abrupt("return", decrypted.toString(CryptoJS.enc.Utf8));

                      case 14:
                      case "end":
                        return _context108.stop();
                    }
                  }
                }, _callee108, this);
              }));

              function decryptText() {
                return _ref114.apply(this, arguments);
              }

              return decryptText;
            }()
          }, {
            key: "encryptText",
            value: function () {
              var _ref116 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee109(text, key, iv) {
                var keyData, ivData, encrypted;
                return regeneratorRuntime.wrap(function _callee109$(_context109) {
                  while (1) {
                    switch (_context109.prev = _context109.next) {
                      case 0:
                        keyData = CryptoJS.enc.Hex.parse(key);
                        ivData = CryptoJS.enc.Hex.parse(iv || "");
                        encrypted = CryptoJS.AES.encrypt(text, keyData, {
                          iv: ivData,
                          mode: CryptoJS.mode.CBC,
                          padding: CryptoJS.pad.Pkcs7
                        });
                        return _context109.abrupt("return", encrypted.toString());

                      case 4:
                      case "end":
                        return _context109.stop();
                    }
                  }
                }, _callee109, this);
              }));

              function encryptText(_x131, _x132, _x133) {
                return _ref116.apply(this, arguments);
              }

              return encryptText;
            }()
          }, {
            key: "generateRandomKey",
            value: function () {
              var _ref117 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee110(bits) {
                return regeneratorRuntime.wrap(function _callee110$(_context110) {
                  while (1) {
                    switch (_context110.prev = _context110.next) {
                      case 0:
                        return _context110.abrupt("return", CryptoJS.lib.WordArray.random(bits / 8).toString());

                      case 1:
                      case "end":
                        return _context110.stop();
                    }
                  }
                }, _callee110, this);
              }));

              function generateRandomKey(_x134) {
                return _ref117.apply(this, arguments);
              }

              return generateRandomKey;
            }()
          }, {
            key: "generateItemEncryptionKey",
            value: function () {
              var _ref118 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee111() {
                var length, cost, salt, passphrase;
                return regeneratorRuntime.wrap(function _callee111$(_context111) {
                  while (1) {
                    switch (_context111.prev = _context111.next) {
                      case 0:
                        // Generates a key that will be split in half, each being 256 bits. So total length will need to be 512.
                        length = 512;
                        cost = 1;
                        _context111.next = 4;
                        return this.generateRandomKey(length);

                      case 4:
                        salt = _context111.sent;
                        _context111.next = 7;
                        return this.generateRandomKey(length);

                      case 7:
                        passphrase = _context111.sent;
                        return _context111.abrupt("return", this.pbkdf2(passphrase, salt, cost, length));

                      case 9:
                      case "end":
                        return _context111.stop();
                    }
                  }
                }, _callee111, this);
              }));

              function generateItemEncryptionKey() {
                return _ref118.apply(this, arguments);
              }

              return generateItemEncryptionKey;
            }()
          }, {
            key: "firstHalfOfKey",
            value: function () {
              var _ref119 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee112(key) {
                return regeneratorRuntime.wrap(function _callee112$(_context112) {
                  while (1) {
                    switch (_context112.prev = _context112.next) {
                      case 0:
                        return _context112.abrupt("return", key.substring(0, key.length / 2));

                      case 1:
                      case "end":
                        return _context112.stop();
                    }
                  }
                }, _callee112, this);
              }));

              function firstHalfOfKey(_x135) {
                return _ref119.apply(this, arguments);
              }

              return firstHalfOfKey;
            }()
          }, {
            key: "secondHalfOfKey",
            value: function () {
              var _ref120 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee113(key) {
                return regeneratorRuntime.wrap(function _callee113$(_context113) {
                  while (1) {
                    switch (_context113.prev = _context113.next) {
                      case 0:
                        return _context113.abrupt("return", key.substring(key.length / 2, key.length));

                      case 1:
                      case "end":
                        return _context113.stop();
                    }
                  }
                }, _callee113, this);
              }));

              function secondHalfOfKey(_x136) {
                return _ref120.apply(this, arguments);
              }

              return secondHalfOfKey;
            }()
          }, {
            key: "base64",
            value: function () {
              var _ref121 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee114(text) {
                return regeneratorRuntime.wrap(function _callee114$(_context114) {
                  while (1) {
                    switch (_context114.prev = _context114.next) {
                      case 0:
                        return _context114.abrupt("return", globalScope.btoa(encodeURIComponent(text).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {
                          return String.fromCharCode('0x' + p1);
                        })));

                      case 1:
                      case "end":
                        return _context114.stop();
                    }
                  }
                }, _callee114, this);
              }));

              function base64(_x137) {
                return _ref121.apply(this, arguments);
              }

              return base64;
            }()
          }, {
            key: "base64Decode",
            value: function () {
              var _ref122 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee115(base64String) {
                return regeneratorRuntime.wrap(function _callee115$(_context115) {
                  while (1) {
                    switch (_context115.prev = _context115.next) {
                      case 0:
                        return _context115.abrupt("return", globalScope.atob(base64String));

                      case 1:
                      case "end":
                        return _context115.stop();
                    }
                  }
                }, _callee115, this);
              }));

              function base64Decode(_x138) {
                return _ref122.apply(this, arguments);
              }

              return base64Decode;
            }()
          }, {
            key: "sha256",
            value: function () {
              var _ref123 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee116(text) {
                return regeneratorRuntime.wrap(function _callee116$(_context116) {
                  while (1) {
                    switch (_context116.prev = _context116.next) {
                      case 0:
                        return _context116.abrupt("return", CryptoJS.SHA256(text).toString());

                      case 1:
                      case "end":
                        return _context116.stop();
                    }
                  }
                }, _callee116, this);
              }));

              function sha256(_x139) {
                return _ref123.apply(this, arguments);
              }

              return sha256;
            }()
          }, {
            key: "hmac256",
            value: function () {
              var _ref124 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee117(message, key) {
                var keyData, messageData, result;
                return regeneratorRuntime.wrap(function _callee117$(_context117) {
                  while (1) {
                    switch (_context117.prev = _context117.next) {
                      case 0:
                        keyData = CryptoJS.enc.Hex.parse(key);
                        messageData = CryptoJS.enc.Utf8.parse(message);
                        result = CryptoJS.HmacSHA256(messageData, keyData).toString();
                        return _context117.abrupt("return", result);

                      case 4:
                      case "end":
                        return _context117.stop();
                    }
                  }
                }, _callee117, this);
              }));

              function hmac256(_x140, _x141) {
                return _ref124.apply(this, arguments);
              }

              return hmac256;
            }()
          }, {
            key: "generateSalt",
            value: function () {
              var _ref125 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee118(identifier, version, cost, nonce) {
                var result;
                return regeneratorRuntime.wrap(function _callee118$(_context118) {
                  while (1) {
                    switch (_context118.prev = _context118.next) {
                      case 0:
                        _context118.next = 2;
                        return this.sha256([identifier, "SF", version, cost, nonce].join(":"));

                      case 2:
                        result = _context118.sent;
                        return _context118.abrupt("return", result);

                      case 4:
                      case "end":
                        return _context118.stop();
                    }
                  }
                }, _callee118, this);
              }));

              function generateSalt(_x142, _x143, _x144, _x145) {
                return _ref125.apply(this, arguments);
              }

              return generateSalt;
            }()
            /** Generates two deterministic keys based on one input */

          }, {
            key: "generateSymmetricKeyPair",
            value: function () {
              var _ref126 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee119() {
                var _ref127 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    password = _ref127.password,
                    pw_salt = _ref127.pw_salt,
                    pw_cost = _ref127.pw_cost;

                var output, outputLength, splitLength, firstThird, secondThird, thirdThird;
                return regeneratorRuntime.wrap(function _callee119$(_context119) {
                  while (1) {
                    switch (_context119.prev = _context119.next) {
                      case 0:
                        _context119.next = 2;
                        return this.pbkdf2(password, pw_salt, pw_cost, this.DefaultPBKDF2Length);

                      case 2:
                        output = _context119.sent;
                        outputLength = output.length;
                        splitLength = outputLength / 3;
                        firstThird = output.slice(0, splitLength);
                        secondThird = output.slice(splitLength, splitLength * 2);
                        thirdThird = output.slice(splitLength * 2, splitLength * 3);
                        return _context119.abrupt("return", [firstThird, secondThird, thirdThird]);

                      case 9:
                      case "end":
                        return _context119.stop();
                    }
                  }
                }, _callee119, this);
              }));

              function generateSymmetricKeyPair() {
                return _ref126.apply(this, arguments);
              }

              return generateSymmetricKeyPair;
            }()
          }, {
            key: "computeEncryptionKeysForUser",
            value: function () {
              var _ref128 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee120(password, authParams) {
                var pw_salt;
                return regeneratorRuntime.wrap(function _callee120$(_context120) {
                  while (1) {
                    switch (_context120.prev = _context120.next) {
                      case 0:
                        if (!(authParams.version == "003")) {
                          _context120.next = 9;
                          break;
                        }

                        if (authParams.identifier) {
                          _context120.next = 4;
                          break;
                        }

                        console.error("authParams is missing identifier.");
                        return _context120.abrupt("return");

                      case 4:
                        _context120.next = 6;
                        return this.generateSalt(authParams.identifier, authParams.version, authParams.pw_cost, authParams.pw_nonce);

                      case 6:
                        pw_salt = _context120.sent;
                        _context120.next = 10;
                        break;

                      case 9:
                        // Salt is returned from server
                        pw_salt = authParams.pw_salt;

                      case 10:
                        return _context120.abrupt("return", this.generateSymmetricKeyPair({
                          password: password,
                          pw_salt: pw_salt,
                          pw_cost: authParams.pw_cost
                        }).then(function (keys) {
                          var userKeys = {
                            pw: keys[0],
                            mk: keys[1],
                            ak: keys[2]
                          };
                          return userKeys;
                        }));

                      case 11:
                      case "end":
                        return _context120.stop();
                    }
                  }
                }, _callee120, this);
              }));

              function computeEncryptionKeysForUser(_x147, _x148) {
                return _ref128.apply(this, arguments);
              }

              return computeEncryptionKeysForUser;
            }() // Unlike computeEncryptionKeysForUser, this method always uses the latest SF Version

          }, {
            key: "generateInitialKeysAndAuthParamsForUser",
            value: function () {
              var _ref129 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee121(identifier, password) {
                var version, pw_cost, pw_nonce, pw_salt;
                return regeneratorRuntime.wrap(function _callee121$(_context121) {
                  while (1) {
                    switch (_context121.prev = _context121.next) {
                      case 0:
                        version = this.SFJS.version;
                        pw_cost = this.SFJS.defaultPasswordGenerationCost;
                        _context121.next = 4;
                        return this.generateRandomKey(256);

                      case 4:
                        pw_nonce = _context121.sent;
                        _context121.next = 7;
                        return this.generateSalt(identifier, version, pw_cost, pw_nonce);

                      case 7:
                        pw_salt = _context121.sent;
                        return _context121.abrupt("return", this.generateSymmetricKeyPair({
                          password: password,
                          pw_salt: pw_salt,
                          pw_cost: pw_cost
                        }).then(function (keys) {
                          var authParams = {
                            pw_nonce: pw_nonce,
                            pw_cost: pw_cost,
                            identifier: identifier,
                            version: version
                          };
                          var userKeys = {
                            pw: keys[0],
                            mk: keys[1],
                            ak: keys[2]
                          };
                          return {
                            keys: userKeys,
                            authParams: authParams
                          };
                        }));

                      case 9:
                      case "end":
                        return _context121.stop();
                    }
                  }
                }, _callee121, this);
              }));

              function generateInitialKeysAndAuthParamsForUser(_x149, _x150) {
                return _ref129.apply(this, arguments);
              }

              return generateInitialKeysAndAuthParamsForUser;
            }()
          }]);

          return SFAbstractCrypto;
        }();

        ;

        var SFCryptoJS = exports.SFCryptoJS = function (_SFAbstractCrypto) {
          _inherits(SFCryptoJS, _SFAbstractCrypto);

          function SFCryptoJS() {
            _classCallCheck(this, SFCryptoJS);

            return _possibleConstructorReturn(this, (SFCryptoJS.__proto__ || Object.getPrototypeOf(SFCryptoJS)).apply(this, arguments));
          }

          _createClass(SFCryptoJS, [{
            key: "pbkdf2",
            value: function () {
              var _ref130 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee122(password, pw_salt, pw_cost, length) {
                var params;
                return regeneratorRuntime.wrap(function _callee122$(_context122) {
                  while (1) {
                    switch (_context122.prev = _context122.next) {
                      case 0:
                        params = {
                          keySize: length / 32,
                          hasher: CryptoJS.algo.SHA512,
                          iterations: pw_cost
                        };
                        return _context122.abrupt("return", CryptoJS.PBKDF2(password, pw_salt, params).toString());

                      case 2:
                      case "end":
                        return _context122.stop();
                    }
                  }
                }, _callee122, this);
              }));

              function pbkdf2(_x151, _x152, _x153, _x154) {
                return _ref130.apply(this, arguments);
              }

              return pbkdf2;
            }()
          }]);

          return SFCryptoJS;
        }(SFAbstractCrypto);

        ;
        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;
        var subtleCrypto = globalScope.crypto ? globalScope.crypto.subtle : null;

        var SFCryptoWeb = exports.SFCryptoWeb = function (_SFAbstractCrypto2) {
          _inherits(SFCryptoWeb, _SFAbstractCrypto2);

          function SFCryptoWeb() {
            _classCallCheck(this, SFCryptoWeb);

            return _possibleConstructorReturn(this, (SFCryptoWeb.__proto__ || Object.getPrototypeOf(SFCryptoWeb)).apply(this, arguments));
          }

          _createClass(SFCryptoWeb, [{
            key: "pbkdf2",

            /**
            Public
            */
            value: function () {
              var _ref131 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee123(password, pw_salt, pw_cost, length) {
                var key;
                return regeneratorRuntime.wrap(function _callee123$(_context123) {
                  while (1) {
                    switch (_context123.prev = _context123.next) {
                      case 0:
                        _context123.next = 2;
                        return this.webCryptoImportKey(password, "PBKDF2", ["deriveBits"]);

                      case 2:
                        key = _context123.sent;

                        if (key) {
                          _context123.next = 6;
                          break;
                        }

                        console.log("Key is null, unable to continue");
                        return _context123.abrupt("return", null);

                      case 6:
                        return _context123.abrupt("return", this.webCryptoDeriveBits(key, pw_salt, pw_cost, length));

                      case 7:
                      case "end":
                        return _context123.stop();
                    }
                  }
                }, _callee123, this);
              }));

              function pbkdf2(_x155, _x156, _x157, _x158) {
                return _ref131.apply(this, arguments);
              }

              return pbkdf2;
            }()
          }, {
            key: "generateRandomKey",
            value: function () {
              var _ref132 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee125(bits) {
                var _this31 = this;

                var extractable;
                return regeneratorRuntime.wrap(function _callee125$(_context125) {
                  while (1) {
                    switch (_context125.prev = _context125.next) {
                      case 0:
                        extractable = true;
                        return _context125.abrupt("return", subtleCrypto.generateKey({
                          name: "AES-CBC",
                          length: bits
                        }, extractable, ["encrypt", "decrypt"]).then(function (keyObject) {
                          return subtleCrypto.exportKey("raw", keyObject).then(function () {
                            var _ref133 = _asyncToGenerator(
                            /*#__PURE__*/
                            regeneratorRuntime.mark(function _callee124(keyData) {
                              var key;
                              return regeneratorRuntime.wrap(function _callee124$(_context124) {
                                while (1) {
                                  switch (_context124.prev = _context124.next) {
                                    case 0:
                                      _context124.next = 2;
                                      return _this31.arrayBufferToHexString(new Uint8Array(keyData));

                                    case 2:
                                      key = _context124.sent;
                                      return _context124.abrupt("return", key);

                                    case 4:
                                    case "end":
                                      return _context124.stop();
                                  }
                                }
                              }, _callee124, _this31);
                            }));

                            return function (_x160) {
                              return _ref133.apply(this, arguments);
                            };
                          }()).catch(function (err) {
                            console.error("Error exporting key", err);
                          });
                        }).catch(function (err) {
                          console.error("Error generating key", err);
                        }));

                      case 2:
                      case "end":
                        return _context125.stop();
                    }
                  }
                }, _callee125, this);
              }));

              function generateRandomKey(_x159) {
                return _ref132.apply(this, arguments);
              }

              return generateRandomKey;
            }()
          }, {
            key: "generateItemEncryptionKey",
            value: function () {
              var _ref134 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee126() {
                var length;
                return regeneratorRuntime.wrap(function _callee126$(_context126) {
                  while (1) {
                    switch (_context126.prev = _context126.next) {
                      case 0:
                        // Generates a key that will be split in half, each being 256 bits. So total length will need to be 512.
                        length = 256;
                        return _context126.abrupt("return", Promise.all([this.generateRandomKey(length), this.generateRandomKey(length)]).then(function (values) {
                          return values.join("");
                        }));

                      case 2:
                      case "end":
                        return _context126.stop();
                    }
                  }
                }, _callee126, this);
              }));

              function generateItemEncryptionKey() {
                return _ref134.apply(this, arguments);
              }

              return generateItemEncryptionKey;
            }()
            /* This is a functioning implementation of WebCrypto's encrypt, however, in basic testing, CrpytoJS performs about 30-40% faster, surprisingly. */

          }, {
            key: "encryptText",
            value: function () {
              var _ref135 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee128(text, key, iv) {
                var _this32 = this;

                var ivData, alg, keyBuffer, keyData, textData;
                return regeneratorRuntime.wrap(function _callee128$(_context128) {
                  while (1) {
                    switch (_context128.prev = _context128.next) {
                      case 0:
                        if (!iv) {
                          _context128.next = 6;
                          break;
                        }

                        _context128.next = 3;
                        return this.hexStringToArrayBuffer(iv);

                      case 3:
                        _context128.t0 = _context128.sent;
                        _context128.next = 7;
                        break;

                      case 6:
                        _context128.t0 = new ArrayBuffer(16);

                      case 7:
                        ivData = _context128.t0;
                        alg = {
                          name: 'AES-CBC',
                          iv: ivData
                        };
                        _context128.next = 11;
                        return this.hexStringToArrayBuffer(key);

                      case 11:
                        keyBuffer = _context128.sent;
                        _context128.next = 14;
                        return this.webCryptoImportKey(keyBuffer, alg.name, ["encrypt"]);

                      case 14:
                        keyData = _context128.sent;
                        _context128.next = 17;
                        return this.stringToArrayBuffer(text);

                      case 17:
                        textData = _context128.sent;
                        return _context128.abrupt("return", crypto.subtle.encrypt(alg, keyData, textData).then(function () {
                          var _ref136 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee127(result) {
                            var cipher;
                            return regeneratorRuntime.wrap(function _callee127$(_context127) {
                              while (1) {
                                switch (_context127.prev = _context127.next) {
                                  case 0:
                                    _context127.next = 2;
                                    return _this32.arrayBufferToBase64(result);

                                  case 2:
                                    cipher = _context127.sent;
                                    return _context127.abrupt("return", cipher);

                                  case 4:
                                  case "end":
                                    return _context127.stop();
                                }
                              }
                            }, _callee127, _this32);
                          }));

                          return function (_x164) {
                            return _ref136.apply(this, arguments);
                          };
                        }()));

                      case 19:
                      case "end":
                        return _context128.stop();
                    }
                  }
                }, _callee128, this);
              }));

              function encryptText(_x161, _x162, _x163) {
                return _ref135.apply(this, arguments);
              }

              return encryptText;
            }()
          }, {
            key: "decryptText",
            value: function () {
              var _ref137 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee130() {
                var _this33 = this;

                var _ref138 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    ciphertextToAuth = _ref138.ciphertextToAuth,
                    contentCiphertext = _ref138.contentCiphertext,
                    encryptionKey = _ref138.encryptionKey,
                    iv = _ref138.iv,
                    authHash = _ref138.authHash,
                    authKey = _ref138.authKey;

                var requiresAuth = arguments[1];
                var localAuthHash, ivData, alg, keyBuffer, keyData, textData;
                return regeneratorRuntime.wrap(function _callee130$(_context130) {
                  while (1) {
                    switch (_context130.prev = _context130.next) {
                      case 0:
                        if (!(requiresAuth && !authHash)) {
                          _context130.next = 3;
                          break;
                        }

                        console.error("Auth hash is required.");
                        return _context130.abrupt("return");

                      case 3:
                        if (!authHash) {
                          _context130.next = 10;
                          break;
                        }

                        _context130.next = 6;
                        return this.hmac256(ciphertextToAuth, authKey);

                      case 6:
                        localAuthHash = _context130.sent;

                        if (!(authHash !== localAuthHash)) {
                          _context130.next = 10;
                          break;
                        }

                        console.error("Auth hash does not match, returning null. " + authHash + " != " + localAuthHash);
                        return _context130.abrupt("return", null);

                      case 10:
                        if (!iv) {
                          _context130.next = 16;
                          break;
                        }

                        _context130.next = 13;
                        return this.hexStringToArrayBuffer(iv);

                      case 13:
                        _context130.t0 = _context130.sent;
                        _context130.next = 17;
                        break;

                      case 16:
                        _context130.t0 = new ArrayBuffer(16);

                      case 17:
                        ivData = _context130.t0;
                        alg = {
                          name: 'AES-CBC',
                          iv: ivData
                        };
                        _context130.next = 21;
                        return this.hexStringToArrayBuffer(encryptionKey);

                      case 21:
                        keyBuffer = _context130.sent;
                        _context130.next = 24;
                        return this.webCryptoImportKey(keyBuffer, alg.name, ["decrypt"]);

                      case 24:
                        keyData = _context130.sent;
                        _context130.next = 27;
                        return this.base64ToArrayBuffer(contentCiphertext);

                      case 27:
                        textData = _context130.sent;
                        return _context130.abrupt("return", crypto.subtle.decrypt(alg, keyData, textData).then(function () {
                          var _ref139 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee129(result) {
                            var decoded;
                            return regeneratorRuntime.wrap(function _callee129$(_context129) {
                              while (1) {
                                switch (_context129.prev = _context129.next) {
                                  case 0:
                                    _context129.next = 2;
                                    return _this33.arrayBufferToString(result);

                                  case 2:
                                    decoded = _context129.sent;
                                    return _context129.abrupt("return", decoded);

                                  case 4:
                                  case "end":
                                    return _context129.stop();
                                }
                              }
                            }, _callee129, _this33);
                          }));

                          return function (_x166) {
                            return _ref139.apply(this, arguments);
                          };
                        }()).catch(function (error) {
                          console.error("Error decrypting:", error);
                        }));

                      case 29:
                      case "end":
                        return _context130.stop();
                    }
                  }
                }, _callee130, this);
              }));

              function decryptText() {
                return _ref137.apply(this, arguments);
              }

              return decryptText;
            }()
            /**
            Internal
            */

          }, {
            key: "webCryptoImportKey",
            value: function () {
              var _ref140 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee131(input, alg, actions, hash) {
                var text;
                return regeneratorRuntime.wrap(function _callee131$(_context131) {
                  while (1) {
                    switch (_context131.prev = _context131.next) {
                      case 0:
                        if (!(typeof input === "string")) {
                          _context131.next = 6;
                          break;
                        }

                        _context131.next = 3;
                        return this.stringToArrayBuffer(input);

                      case 3:
                        _context131.t0 = _context131.sent;
                        _context131.next = 7;
                        break;

                      case 6:
                        _context131.t0 = input;

                      case 7:
                        text = _context131.t0;
                        return _context131.abrupt("return", subtleCrypto.importKey("raw", text, {
                          name: alg,
                          hash: hash
                        }, false, actions).then(function (key) {
                          return key;
                        }).catch(function (err) {
                          console.error(err);
                          return null;
                        }));

                      case 9:
                      case "end":
                        return _context131.stop();
                    }
                  }
                }, _callee131, this);
              }));

              function webCryptoImportKey(_x167, _x168, _x169, _x170) {
                return _ref140.apply(this, arguments);
              }

              return webCryptoImportKey;
            }() //

          }, {
            key: "webCryptoDeriveBits",
            value: function () {
              var _ref141 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee133(key, pw_salt, pw_cost, length) {
                var _this34 = this;

                var params;
                return regeneratorRuntime.wrap(function _callee133$(_context133) {
                  while (1) {
                    switch (_context133.prev = _context133.next) {
                      case 0:
                        _context133.next = 2;
                        return this.stringToArrayBuffer(pw_salt);

                      case 2:
                        _context133.t0 = _context133.sent;
                        _context133.t1 = pw_cost;
                        _context133.t2 = {
                          name: "SHA-512"
                        };
                        params = {
                          "name": "PBKDF2",
                          salt: _context133.t0,
                          iterations: _context133.t1,
                          hash: _context133.t2
                        };
                        return _context133.abrupt("return", subtleCrypto.deriveBits(params, key, length).then(function () {
                          var _ref142 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee132(bits) {
                            var key;
                            return regeneratorRuntime.wrap(function _callee132$(_context132) {
                              while (1) {
                                switch (_context132.prev = _context132.next) {
                                  case 0:
                                    _context132.next = 2;
                                    return _this34.arrayBufferToHexString(new Uint8Array(bits));

                                  case 2:
                                    key = _context132.sent;
                                    return _context132.abrupt("return", key);

                                  case 4:
                                  case "end":
                                    return _context132.stop();
                                }
                              }
                            }, _callee132, _this34);
                          }));

                          return function (_x175) {
                            return _ref142.apply(this, arguments);
                          };
                        }()).catch(function (err) {
                          console.error(err);
                          return null;
                        }));

                      case 7:
                      case "end":
                        return _context133.stop();
                    }
                  }
                }, _callee133, this);
              }));

              function webCryptoDeriveBits(_x171, _x172, _x173, _x174) {
                return _ref141.apply(this, arguments);
              }

              return webCryptoDeriveBits;
            }()
          }, {
            key: "stringToArrayBuffer",
            value: function () {
              var _ref143 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee134(string) {
                return regeneratorRuntime.wrap(function _callee134$(_context134) {
                  while (1) {
                    switch (_context134.prev = _context134.next) {
                      case 0:
                        return _context134.abrupt("return", new Promise(function (resolve, reject) {
                          var blob = new Blob([string]);
                          var f = new FileReader();

                          f.onload = function (e) {
                            resolve(e.target.result);
                          };

                          f.readAsArrayBuffer(blob);
                        }));

                      case 1:
                      case "end":
                        return _context134.stop();
                    }
                  }
                }, _callee134, this);
              }));

              function stringToArrayBuffer(_x176) {
                return _ref143.apply(this, arguments);
              }

              return stringToArrayBuffer;
            }()
          }, {
            key: "arrayBufferToString",
            value: function () {
              var _ref144 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee135(arrayBuffer) {
                return regeneratorRuntime.wrap(function _callee135$(_context135) {
                  while (1) {
                    switch (_context135.prev = _context135.next) {
                      case 0:
                        return _context135.abrupt("return", new Promise(function (resolve, reject) {
                          var blob = new Blob([arrayBuffer]);
                          var f = new FileReader();

                          f.onload = function (e) {
                            resolve(e.target.result);
                          };

                          f.readAsText(blob);
                        }));

                      case 1:
                      case "end":
                        return _context135.stop();
                    }
                  }
                }, _callee135, this);
              }));

              function arrayBufferToString(_x177) {
                return _ref144.apply(this, arguments);
              }

              return arrayBufferToString;
            }()
          }, {
            key: "arrayBufferToHexString",
            value: function () {
              var _ref145 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee136(arrayBuffer) {
                var byteArray, hexString, nextHexByte, i;
                return regeneratorRuntime.wrap(function _callee136$(_context136) {
                  while (1) {
                    switch (_context136.prev = _context136.next) {
                      case 0:
                        byteArray = new Uint8Array(arrayBuffer);
                        hexString = "";

                        for (i = 0; i < byteArray.byteLength; i++) {
                          nextHexByte = byteArray[i].toString(16);

                          if (nextHexByte.length < 2) {
                            nextHexByte = "0" + nextHexByte;
                          }

                          hexString += nextHexByte;
                        }

                        return _context136.abrupt("return", hexString);

                      case 4:
                      case "end":
                        return _context136.stop();
                    }
                  }
                }, _callee136, this);
              }));

              function arrayBufferToHexString(_x178) {
                return _ref145.apply(this, arguments);
              }

              return arrayBufferToHexString;
            }()
          }, {
            key: "hexStringToArrayBuffer",
            value: function () {
              var _ref146 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee137(hex) {
                var bytes, c;
                return regeneratorRuntime.wrap(function _callee137$(_context137) {
                  while (1) {
                    switch (_context137.prev = _context137.next) {
                      case 0:
                        for (bytes = [], c = 0; c < hex.length; c += 2) {
                          bytes.push(parseInt(hex.substr(c, 2), 16));
                        }

                        return _context137.abrupt("return", new Uint8Array(bytes));

                      case 2:
                      case "end":
                        return _context137.stop();
                    }
                  }
                }, _callee137, this);
              }));

              function hexStringToArrayBuffer(_x179) {
                return _ref146.apply(this, arguments);
              }

              return hexStringToArrayBuffer;
            }()
          }, {
            key: "base64ToArrayBuffer",
            value: function () {
              var _ref147 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee138(base64) {
                var binary_string, len, bytes, i;
                return regeneratorRuntime.wrap(function _callee138$(_context138) {
                  while (1) {
                    switch (_context138.prev = _context138.next) {
                      case 0:
                        _context138.next = 2;
                        return this.base64Decode(base64);

                      case 2:
                        binary_string = _context138.sent;
                        len = binary_string.length;
                        bytes = new Uint8Array(len);

                        for (i = 0; i < len; i++) {
                          bytes[i] = binary_string.charCodeAt(i);
                        }

                        return _context138.abrupt("return", bytes.buffer);

                      case 7:
                      case "end":
                        return _context138.stop();
                    }
                  }
                }, _callee138, this);
              }));

              function base64ToArrayBuffer(_x180) {
                return _ref147.apply(this, arguments);
              }

              return base64ToArrayBuffer;
            }()
          }, {
            key: "arrayBufferToBase64",
            value: function () {
              var _ref148 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee139(buffer) {
                return regeneratorRuntime.wrap(function _callee139$(_context139) {
                  while (1) {
                    switch (_context139.prev = _context139.next) {
                      case 0:
                        return _context139.abrupt("return", new Promise(function (resolve, reject) {
                          var blob = new Blob([buffer], {
                            type: 'application/octet-binary'
                          });
                          var reader = new FileReader();

                          reader.onload = function (evt) {
                            var dataurl = evt.target.result;
                            resolve(dataurl.substr(dataurl.indexOf(',') + 1));
                          };

                          reader.readAsDataURL(blob);
                        }));

                      case 1:
                      case "end":
                        return _context139.stop();
                    }
                  }
                }, _callee139, this);
              }));

              function arrayBufferToBase64(_x181) {
                return _ref148.apply(this, arguments);
              }

              return arrayBufferToBase64;
            }()
          }, {
            key: "hmac256",
            value: function () {
              var _ref149 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee141(message, key) {
                var _this35 = this;

                var keyHexData, keyData, messageData;
                return regeneratorRuntime.wrap(function _callee141$(_context141) {
                  while (1) {
                    switch (_context141.prev = _context141.next) {
                      case 0:
                        _context141.next = 2;
                        return this.hexStringToArrayBuffer(key);

                      case 2:
                        keyHexData = _context141.sent;
                        _context141.next = 5;
                        return this.webCryptoImportKey(keyHexData, "HMAC", ["sign"], {
                          name: "SHA-256"
                        });

                      case 5:
                        keyData = _context141.sent;
                        _context141.next = 8;
                        return this.stringToArrayBuffer(message);

                      case 8:
                        messageData = _context141.sent;
                        return _context141.abrupt("return", crypto.subtle.sign({
                          name: "HMAC"
                        }, keyData, messageData).then(function () {
                          var _ref150 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee140(signature) {
                            var hash;
                            return regeneratorRuntime.wrap(function _callee140$(_context140) {
                              while (1) {
                                switch (_context140.prev = _context140.next) {
                                  case 0:
                                    _context140.next = 2;
                                    return _this35.arrayBufferToHexString(signature);

                                  case 2:
                                    hash = _context140.sent;
                                    return _context140.abrupt("return", hash);

                                  case 4:
                                  case "end":
                                    return _context140.stop();
                                }
                              }
                            }, _callee140, _this35);
                          }));

                          return function (_x184) {
                            return _ref150.apply(this, arguments);
                          };
                        }()).catch(function (err) {
                          console.error("Error computing hmac");
                        }));

                      case 10:
                      case "end":
                        return _context141.stop();
                    }
                  }
                }, _callee141, this);
              }));

              function hmac256(_x182, _x183) {
                return _ref149.apply(this, arguments);
              }

              return hmac256;
            }()
          }]);

          return SFCryptoWeb;
        }(SFAbstractCrypto);

        ;

        var SFItemTransformer = exports.SFItemTransformer = function () {
          function SFItemTransformer(crypto) {
            _classCallCheck(this, SFItemTransformer);

            this.crypto = crypto;
          }

          _createClass(SFItemTransformer, [{
            key: "_private_encryptString",
            value: function () {
              var _ref151 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee142(string, encryptionKey, authKey, uuid, auth_params) {
                var fullCiphertext, contentCiphertext, iv, ciphertextToAuth, authHash, authParamsString;
                return regeneratorRuntime.wrap(function _callee142$(_context142) {
                  while (1) {
                    switch (_context142.prev = _context142.next) {
                      case 0:
                        if (!(auth_params.version === "001")) {
                          _context142.next = 7;
                          break;
                        }

                        _context142.next = 3;
                        return this.crypto.encryptText(string, encryptionKey, null);

                      case 3:
                        contentCiphertext = _context142.sent;
                        fullCiphertext = auth_params.version + contentCiphertext;
                        _context142.next = 21;
                        break;

                      case 7:
                        _context142.next = 9;
                        return this.crypto.generateRandomKey(128);

                      case 9:
                        iv = _context142.sent;
                        _context142.next = 12;
                        return this.crypto.encryptText(string, encryptionKey, iv);

                      case 12:
                        contentCiphertext = _context142.sent;
                        ciphertextToAuth = [auth_params.version, uuid, iv, contentCiphertext].join(":");
                        _context142.next = 16;
                        return this.crypto.hmac256(ciphertextToAuth, authKey);

                      case 16:
                        authHash = _context142.sent;
                        _context142.next = 19;
                        return this.crypto.base64(JSON.stringify(auth_params));

                      case 19:
                        authParamsString = _context142.sent;
                        fullCiphertext = [auth_params.version, authHash, uuid, iv, contentCiphertext, authParamsString].join(":");

                      case 21:
                        return _context142.abrupt("return", fullCiphertext);

                      case 22:
                      case "end":
                        return _context142.stop();
                    }
                  }
                }, _callee142, this);
              }));

              function _private_encryptString(_x185, _x186, _x187, _x188, _x189) {
                return _ref151.apply(this, arguments);
              }

              return _private_encryptString;
            }()
          }, {
            key: "encryptItem",
            value: function () {
              var _ref152 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee143(item, keys, auth_params) {
                var params, item_key, ek, ak, ciphertext, authHash;
                return regeneratorRuntime.wrap(function _callee143$(_context143) {
                  while (1) {
                    switch (_context143.prev = _context143.next) {
                      case 0:
                        params = {}; // encrypt item key

                        _context143.next = 3;
                        return this.crypto.generateItemEncryptionKey();

                      case 3:
                        item_key = _context143.sent;

                        if (!(auth_params.version === "001")) {
                          _context143.next = 10;
                          break;
                        }

                        _context143.next = 7;
                        return this.crypto.encryptText(item_key, keys.mk, null);

                      case 7:
                        params.enc_item_key = _context143.sent;
                        _context143.next = 13;
                        break;

                      case 10:
                        _context143.next = 12;
                        return this._private_encryptString(item_key, keys.mk, keys.ak, item.uuid, auth_params);

                      case 12:
                        params.enc_item_key = _context143.sent;

                      case 13:
                        _context143.next = 15;
                        return this.crypto.firstHalfOfKey(item_key);

                      case 15:
                        ek = _context143.sent;
                        _context143.next = 18;
                        return this.crypto.secondHalfOfKey(item_key);

                      case 18:
                        ak = _context143.sent;
                        _context143.next = 21;
                        return this._private_encryptString(JSON.stringify(item.createContentJSONFromProperties()), ek, ak, item.uuid, auth_params);

                      case 21:
                        ciphertext = _context143.sent;

                        if (!(auth_params.version === "001")) {
                          _context143.next = 27;
                          break;
                        }

                        _context143.next = 25;
                        return this.crypto.hmac256(ciphertext, ak);

                      case 25:
                        authHash = _context143.sent;
                        params.auth_hash = authHash;

                      case 27:
                        params.content = ciphertext;
                        return _context143.abrupt("return", params);

                      case 29:
                      case "end":
                        return _context143.stop();
                    }
                  }
                }, _callee143, this);
              }));

              function encryptItem(_x190, _x191, _x192) {
                return _ref152.apply(this, arguments);
              }

              return encryptItem;
            }()
          }, {
            key: "encryptionComponentsFromString",
            value: function encryptionComponentsFromString(string, encryptionKey, authKey) {
              var encryptionVersion = string.substring(0, 3);

              if (encryptionVersion === "001") {
                return {
                  contentCiphertext: string.substring(3, string.length),
                  encryptionVersion: encryptionVersion,
                  ciphertextToAuth: string,
                  iv: null,
                  authHash: null,
                  encryptionKey: encryptionKey,
                  authKey: authKey
                };
              } else {
                var components = string.split(":");
                return {
                  encryptionVersion: components[0],
                  authHash: components[1],
                  uuid: components[2],
                  iv: components[3],
                  contentCiphertext: components[4],
                  authParams: components[5],
                  ciphertextToAuth: [components[0], components[2], components[3], components[4]].join(":"),
                  encryptionKey: encryptionKey,
                  authKey: authKey
                };
              }
            }
          }, {
            key: "decryptItem",
            value: function () {
              var _ref153 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee144(item, keys) {
                var encryptedItemKey, requiresAuth, keyParams, item_key, ek, ak, itemParams, content;
                return regeneratorRuntime.wrap(function _callee144$(_context144) {
                  while (1) {
                    switch (_context144.prev = _context144.next) {
                      case 0:
                        if (!(typeof item.content != "string")) {
                          _context144.next = 2;
                          break;
                        }

                        return _context144.abrupt("return");

                      case 2:
                        if (!item.content.startsWith("000")) {
                          _context144.next = 14;
                          break;
                        }

                        _context144.prev = 3;
                        _context144.t0 = JSON;
                        _context144.next = 7;
                        return this.crypto.base64Decode(item.content.substring(3, item.content.length));

                      case 7:
                        _context144.t1 = _context144.sent;
                        item.content = _context144.t0.parse.call(_context144.t0, _context144.t1);
                        _context144.next = 13;
                        break;

                      case 11:
                        _context144.prev = 11;
                        _context144.t2 = _context144["catch"](3);

                      case 13:
                        return _context144.abrupt("return");

                      case 14:
                        if (item.enc_item_key) {
                          _context144.next = 17;
                          break;
                        } // This needs to be here to continue, return otherwise


                        console.log("Missing item encryption key, skipping decryption.");
                        return _context144.abrupt("return");

                      case 17:
                        // decrypt encrypted key
                        encryptedItemKey = item.enc_item_key;
                        requiresAuth = true;

                        if (!encryptedItemKey.startsWith("002") && !encryptedItemKey.startsWith("003")) {
                          // legacy encryption type, has no prefix
                          encryptedItemKey = "001" + encryptedItemKey;
                          requiresAuth = false;
                        }

                        keyParams = this.encryptionComponentsFromString(encryptedItemKey, keys.mk, keys.ak); // return if uuid in auth hash does not match item uuid. Signs of tampering.

                        if (!(keyParams.uuid && keyParams.uuid !== item.uuid)) {
                          _context144.next = 26;
                          break;
                        }

                        console.error("Item key params UUID does not match item UUID");

                        if (!item.errorDecrypting) {
                          item.errorDecryptingValueChanged = true;
                        }

                        item.errorDecrypting = true;
                        return _context144.abrupt("return");

                      case 26:
                        _context144.next = 28;
                        return this.crypto.decryptText(keyParams, requiresAuth);

                      case 28:
                        item_key = _context144.sent;

                        if (item_key) {
                          _context144.next = 34;
                          break;
                        }

                        console.log("Error decrypting item", item);

                        if (!item.errorDecrypting) {
                          item.errorDecryptingValueChanged = true;
                        }

                        item.errorDecrypting = true;
                        return _context144.abrupt("return");

                      case 34:
                        _context144.next = 36;
                        return this.crypto.firstHalfOfKey(item_key);

                      case 36:
                        ek = _context144.sent;
                        _context144.next = 39;
                        return this.crypto.secondHalfOfKey(item_key);

                      case 39:
                        ak = _context144.sent;
                        itemParams = this.encryptionComponentsFromString(item.content, ek, ak);
                        _context144.prev = 41;
                        _context144.t3 = JSON;
                        _context144.next = 45;
                        return this.crypto.base64Decode(itemParams.authParams);

                      case 45:
                        _context144.t4 = _context144.sent;
                        item.auth_params = _context144.t3.parse.call(_context144.t3, _context144.t4);
                        _context144.next = 51;
                        break;

                      case 49:
                        _context144.prev = 49;
                        _context144.t5 = _context144["catch"](41);

                      case 51:
                        if (!(itemParams.uuid && itemParams.uuid !== item.uuid)) {
                          _context144.next = 55;
                          break;
                        }

                        if (!item.errorDecrypting) {
                          item.errorDecryptingValueChanged = true;
                        }

                        item.errorDecrypting = true;
                        return _context144.abrupt("return");

                      case 55:
                        if (!itemParams.authHash) {
                          // legacy 001
                          itemParams.authHash = item.auth_hash;
                        }

                        _context144.next = 58;
                        return this.crypto.decryptText(itemParams, true);

                      case 58:
                        content = _context144.sent;

                        if (!content) {
                          if (!item.errorDecrypting) {
                            item.errorDecryptingValueChanged = true;
                          }

                          item.errorDecrypting = true;
                        } else {
                          if (item.errorDecrypting == true) {
                            item.errorDecryptingValueChanged = true;
                          } // Content should only be set if it was successfully decrypted, and should otherwise remain unchanged.


                          item.errorDecrypting = false;
                          item.content = content;
                        }

                      case 60:
                      case "end":
                        return _context144.stop();
                    }
                  }
                }, _callee144, this, [[3, 11], [41, 49]]);
              }));

              function decryptItem(_x193, _x194) {
                return _ref153.apply(this, arguments);
              }

              return decryptItem;
            }()
          }, {
            key: "decryptMultipleItems",
            value: function () {
              var _ref154 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee146(items, keys, throws) {
                var _this36 = this;

                var decrypt;
                return regeneratorRuntime.wrap(function _callee146$(_context146) {
                  while (1) {
                    switch (_context146.prev = _context146.next) {
                      case 0:
                        decrypt = function () {
                          var _ref155 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee145(item) {
                            var isString;
                            return regeneratorRuntime.wrap(function _callee145$(_context145) {
                              while (1) {
                                switch (_context145.prev = _context145.next) {
                                  case 0:
                                    if (item) {
                                      _context145.next = 2;
                                      break;
                                    }

                                    return _context145.abrupt("return");

                                  case 2:
                                    if (!(item.deleted == true && item.content == null)) {
                                      _context145.next = 4;
                                      break;
                                    }

                                    return _context145.abrupt("return");

                                  case 4:
                                    isString = typeof item.content === 'string' || item.content instanceof String;

                                    if (!isString) {
                                      _context145.next = 19;
                                      break;
                                    }

                                    _context145.prev = 6;
                                    _context145.next = 9;
                                    return _this36.decryptItem(item, keys);

                                  case 9:
                                    _context145.next = 19;
                                    break;

                                  case 11:
                                    _context145.prev = 11;
                                    _context145.t0 = _context145["catch"](6);

                                    if (!item.errorDecrypting) {
                                      item.errorDecryptingValueChanged = true;
                                    }

                                    item.errorDecrypting = true;

                                    if (!throws) {
                                      _context145.next = 17;
                                      break;
                                    }

                                    throw _context145.t0;

                                  case 17:
                                    console.error("Error decrypting item", item, _context145.t0);
                                    return _context145.abrupt("return");

                                  case 19:
                                  case "end":
                                    return _context145.stop();
                                }
                              }
                            }, _callee145, _this36, [[6, 11]]);
                          }));

                          return function decrypt(_x198) {
                            return _ref155.apply(this, arguments);
                          };
                        }();

                        return _context146.abrupt("return", Promise.all(items.map(function (item) {
                          return decrypt(item);
                        })));

                      case 2:
                      case "end":
                        return _context146.stop();
                    }
                  }
                }, _callee146, this);
              }));

              function decryptMultipleItems(_x195, _x196, _x197) {
                return _ref154.apply(this, arguments);
              }

              return decryptMultipleItems;
            }()
          }]);

          return SFItemTransformer;
        }();

        ;
        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

        var StandardFile = exports.StandardFile = function () {
          function StandardFile(cryptoInstance) {
            _classCallCheck(this, StandardFile); // This library runs in native environments as well (react native)


            if (globalScope) {
              // detect IE8 and above, and edge.
              // IE and Edge do not support pbkdf2 in WebCrypto, therefore we need to use CryptoJS
              var IEOrEdge = typeof document !== 'undefined' && document.documentMode || /Edge/.test(navigator.userAgent);

              if (!IEOrEdge && globalScope.crypto && globalScope.crypto.subtle) {
                this.crypto = new SFCryptoWeb();
              } else {
                this.crypto = new SFCryptoJS();
              }
            } // This must be placed outside window check, as it's used in native.


            if (cryptoInstance) {
              this.crypto = cryptoInstance;
            }

            this.itemTransformer = new SFItemTransformer(this.crypto);
            this.crypto.SFJS = {
              version: this.version(),
              defaultPasswordGenerationCost: this.defaultPasswordGenerationCost()
            };
          }

          _createClass(StandardFile, [{
            key: "version",
            value: function version() {
              return "003";
            }
          }, {
            key: "supportsPasswordDerivationCost",
            value: function supportsPasswordDerivationCost(cost) {
              // some passwords are created on platforms with stronger pbkdf2 capabilities, like iOS,
              // which CryptoJS can't handle here (WebCrypto can however).
              // if user has high password cost and is using browser that doesn't support WebCrypto,
              // we want to tell them that they can't login with this browser.
              if (cost > 5000) {
                return this.crypto instanceof SFCryptoWeb;
              } else {
                return true;
              }
            } // Returns the versions that this library supports technically.

          }, {
            key: "supportedVersions",
            value: function supportedVersions() {
              return ["001", "002", "003"];
            }
          }, {
            key: "isVersionNewerThanLibraryVersion",
            value: function isVersionNewerThanLibraryVersion(version) {
              var libraryVersion = this.version();
              return parseInt(version) > parseInt(libraryVersion);
            }
          }, {
            key: "isProtocolVersionOutdated",
            value: function isProtocolVersionOutdated(version) {
              // YYYY-MM-DD
              var expirationDates = {
                "001": Date.parse("2018-01-01"),
                "002": Date.parse("2020-01-01")
              };
              var date = expirationDates[version];

              if (!date) {
                // No expiration date, is active version
                return false;
              }

              var expired = new Date() > date;
              return expired;
            }
          }, {
            key: "costMinimumForVersion",
            value: function costMinimumForVersion(version) {
              return {
                "001": 3000,
                "002": 3000,
                "003": 110000
              }[version];
            }
          }, {
            key: "defaultPasswordGenerationCost",
            value: function defaultPasswordGenerationCost() {
              return this.costMinimumForVersion(this.version());
            }
          }]);

          return StandardFile;
        }();

        if (globalScope) {
          // window is for some reason defined in React Native, but throws an exception when you try to set to it
          try {
            globalScope.StandardFile = StandardFile;
            globalScope.SFJS = new StandardFile();
            globalScope.SFCryptoWeb = SFCryptoWeb;
            globalScope.SFCryptoJS = SFCryptoJS;
            globalScope.SFItemTransformer = SFItemTransformer;
            globalScope.SFModelManager = SFModelManager;
            globalScope.SFItem = SFItem;
            globalScope.SFItemParams = SFItemParams;
            globalScope.SFHttpManager = SFHttpManager;
            globalScope.SFStorageManager = SFStorageManager;
            globalScope.SFSyncManager = SFSyncManager;
            globalScope.SFAuthManager = SFAuthManager;
            globalScope.SFMigrationManager = SFMigrationManager;
            globalScope.SFAlertManager = SFAlertManager;
            globalScope.SFPredicate = SFPredicate;
            globalScope.SFHistorySession = SFHistorySession;
            globalScope.SFSessionHistoryManager = SFSessionHistoryManager;
            globalScope.SFItemHistory = SFItemHistory;
            globalScope.SFItemHistoryEntry = SFItemHistoryEntry;
            globalScope.SFPrivilegesManager = SFPrivilegesManager;
            globalScope.SFPrivileges = SFPrivileges;
            globalScope.SFSingletonManager = SFSingletonManager;
          } catch (e) {
            console.log("Exception while exporting window variables", e);
          }
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}]
  }, {}, [1])(1);
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExtensionBridge; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js_dist_lodash_min_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js_dist_lodash_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_standard_file_js_dist_lodash_min_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_standard_file_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_standard_file_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_standard_file_js__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var ExtensionBridge =
/*#__PURE__*/
function () {
  function ExtensionBridge(componentManager) {
    _classCallCheck(this, ExtensionBridge);

    this.componentManager = componentManager;
    this.updateObservers = [];
    this.items = [];
  }

  _createClass(ExtensionBridge, [{
    key: "getPlatform",
    value: function getPlatform() {
      return this.componentManager.platform;
    }
  }, {
    key: "addEventHandler",
    value: function addEventHandler(callback) {
      var observer = {
        id: Math.random,
        callback: callback
      };
      this.updateObservers.push(observer);
      return observer;
    }
  }, {
    key: "removeUpdateObserver",
    value: function removeUpdateObserver(observer) {
      this.updateObservers.splice(this.updateObservers.indexOf(observer), 1);
    }
  }, {
    key: "notifyObserversOfEvent",
    value: function notifyObserversOfEvent(event) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.updateObservers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var observer = _step.value;
          observer.callback(event);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "filterItems",
    value: function filterItems(contentType) {
      return this.items.filter(function (item) {
        return item.content_type == contentType;
      });
    }
  }, {
    key: "getFileDescriptors",
    value: function getFileDescriptors() {
      return this.filterItems(ExtensionBridge.FileDescriptorContentTypeKey);
    }
  }, {
    key: "beginStreamingFiles",
    value: function beginStreamingFiles() {
      var _this = this;

      var contentTypes = [ExtensionBridge.FileDescriptorContentTypeKey, ExtensionBridge.FileSafeCredentialsContentType, ExtensionBridge.FileSafeIntegrationContentTypeKey];
      this.componentManager.streamItems(contentTypes, function (items) {
        _this.handleStreamItemsMessage(items);
      });
    }
  }, {
    key: "handleStreamItemsMessage",
    value: function () {
      var _handleStreamItemsMessage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(items) {
        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, item, index;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context.prev = 3;
                _iterator2 = items[Symbol.iterator]();

              case 5:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context.next = 18;
                  break;
                }

                item = _step2.value;
                item = new __WEBPACK_IMPORTED_MODULE_2_standard_file_js__["SFItem"](item);

                if (!item.deleted) {
                  _context.next = 11;
                  break;
                }

                this.removeItemFromItems(item);
                return _context.abrupt("continue", 15);

              case 11:
                if (!item.isMetadataUpdate) {
                  _context.next = 13;
                  break;
                }

                return _context.abrupt("continue", 15);

              case 13:
                index = this.indexOfItem(item);

                if (index >= 0) {
                  this.items[index] = item;
                } else {
                  this.items.push(item);
                }

              case 15:
                _iteratorNormalCompletion2 = true;
                _context.next = 5;
                break;

              case 18:
                _context.next = 24;
                break;

              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](3);
                _didIteratorError2 = true;
                _iteratorError2 = _context.t0;

              case 24:
                _context.prev = 24;
                _context.prev = 25;

                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }

              case 27:
                _context.prev = 27;

                if (!_didIteratorError2) {
                  _context.next = 30;
                  break;
                }

                throw _iteratorError2;

              case 30:
                return _context.finish(27);

              case 31:
                return _context.finish(24);

              case 32:
                this.notifyObserversOfEvent(ExtensionBridge.BridgeEventReceivedItems);

              case 33:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 20, 24, 32], [25,, 27, 31]]);
      }));

      function handleStreamItemsMessage(_x) {
        return _handleStreamItemsMessage.apply(this, arguments);
      }

      return handleStreamItemsMessage;
    }()
  }, {
    key: "indexOfItem",
    value: function indexOfItem(item) {
      for (var index in this.items) {
        if (this.items[index].uuid == item.uuid) {
          return index;
        }
      }

      return -1;
    }
  }, {
    key: "removeItemFromItems",
    value: function removeItemFromItems(item) {
      this.items = this.items.filter(function (candidate) {
        return candidate.uuid !== item.uuid;
      });
    }
  }, {
    key: "createItem",
    value: function createItem(item, callback) {
      this.createItems([item], callback);
    }
  }, {
    key: "createItems",
    value: function createItems(items, callback) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var item = _step3.value;
          item.uuid = null;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.componentManager.createItems(items, function (createdItems) {
        callback && callback(createdItems);
      });
    }
  }, {
    key: "saveItem",
    value: function () {
      var _saveItem = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(item) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.saveItems([item]));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function saveItem(_x2) {
        return _saveItem.apply(this, arguments);
      }

      return saveItem;
    }()
  }, {
    key: "saveItems",
    value: function () {
      var _saveItems = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(items) {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  _this2.componentManager.saveItems(items, function (response) {
                    resolve(response);

                    _this2.notifyObserversOfEvent(ExtensionBridge.BridgeEventSavedItem);
                  });
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function saveItems(_x3) {
        return _saveItems.apply(this, arguments);
      }

      return saveItems;
    }()
  }, {
    key: "indexOfItem",
    value: function indexOfItem(item) {
      for (var index in this.items) {
        if (this.items[index].uuid == item.uuid) {
          return index;
        }
      }

      return -1;
    }
  }, {
    key: "deleteItem",
    value: function deleteItem(item, callback) {
      this.deleteItems([item], callback);
    }
  }, {
    key: "deleteItems",
    value: function deleteItems(items, callback) {
      this.componentManager.deleteItems(items, callback);
    }
  }, {
    key: "removeItemFromItems",
    value: function removeItemFromItems(item) {
      this.items = this.items.filter(function (candidate) {
        return candidate.uuid !== item.uuid;
      });
    }
  }]);

  return ExtensionBridge;
}();

_defineProperty(ExtensionBridge, "FileItemContentTypeKey", "SN|FileSafe|File");

_defineProperty(ExtensionBridge, "FileSafeCredentialsContentType", "SN|FileSafe|Credentials");

_defineProperty(ExtensionBridge, "FileDescriptorContentTypeKey", "SN|FileSafe|FileMetadata");

_defineProperty(ExtensionBridge, "FileSafeIntegrationContentTypeKey", "SN|FileSafe|Integration");

_defineProperty(ExtensionBridge, "BridgeEventLoadedCredentials", "BridgeEventLoadedCredentials");

_defineProperty(ExtensionBridge, "BridgeEventReceivedItems", "BridgeEventReceivedItems");

_defineProperty(ExtensionBridge, "BridgeEventSavedItem", "BridgeEventSavedItem");



/***/ }),
/* 3 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Filesafe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_ExtensionBridge__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_RelayManager__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_IntegrationManager__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_CredentialManager__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_FileManager__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_util_Utils__ = __webpack_require__(13);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }








var Filesafe =
/*#__PURE__*/
function () {
  function Filesafe(_ref) {
    var _this = this;

    var componentManager = _ref.componentManager,
        onFilesChange = _ref.onFilesChange;

    _classCallCheck(this, Filesafe);

    this.extensionBridge = new __WEBPACK_IMPORTED_MODULE_0__lib_ExtensionBridge__["a" /* default */](componentManager);
    this.extensionBridge.addEventHandler(function (eventName) {
      onFilesChange && onFilesChange();
    });
    this.relayManager = new __WEBPACK_IMPORTED_MODULE_1__lib_RelayManager__["a" /* default */]();
    this.integrationManager = new __WEBPACK_IMPORTED_MODULE_2__lib_IntegrationManager__["a" /* default */](this.extensionBridge);
    this.credentialManager = new __WEBPACK_IMPORTED_MODULE_3__lib_CredentialManager__["a" /* default */]({
      extensionBridge: this.extensionBridge,
      onCredentialLoad: function onCredentialLoad() {
        _this.relayManager.setCredentials(_this.credentialManager.getDefaultCredentials());
      }
    });
    this.fileManager = new __WEBPACK_IMPORTED_MODULE_4__lib_FileManager__["a" /* default */](this.extensionBridge, this.relayManager, this.integrationManager, this.credentialManager);
    this.extensionBridge.beginStreamingFiles();
  }
  /* Files */


  _createClass(Filesafe, [{
    key: "fileDescriptorsForNote",
    value: function fileDescriptorsForNote(note) {
      return this.fileManager.fileDescriptorsForNote(note);
    }
  }, {
    key: "fileDescriptorsEncryptedWithCredential",
    value: function fileDescriptorsEncryptedWithCredential(credential) {
      return this.fileManager.fileDescriptorsEncryptedWithCredential(credential);
    }
  }, {
    key: "deleteFileFromDescriptor",
    value: function () {
      var _deleteFileFromDescriptor = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(fileDescriptor) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.fileManager.deleteFileFromDescriptor(fileDescriptor));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function deleteFileFromDescriptor(_x) {
        return _deleteFileFromDescriptor.apply(this, arguments);
      }

      return deleteFileFromDescriptor;
    }()
  }, {
    key: "uploadFile",
    value: function () {
      var _uploadFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(itemParams, inputFileName, fileType, credential, note) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.fileManager.uploadFile(itemParams, inputFileName, fileType, credential, note));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function uploadFile(_x2, _x3, _x4, _x5, _x6) {
        return _uploadFile.apply(this, arguments);
      }

      return uploadFile;
    }()
  }, {
    key: "downloadFileFromDescriptor",
    value: function () {
      var _downloadFileFromDescriptor = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(fileDescriptor) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.fileManager.downloadFileFromDescriptor(fileDescriptor));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function downloadFileFromDescriptor(_x7) {
        return _downloadFileFromDescriptor.apply(this, arguments);
      }

      return downloadFileFromDescriptor;
    }()
  }, {
    key: "encryptFile",
    value: function () {
      var _encryptFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(data, inputFileName, fileType, credential) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.fileManager.encryptFile(data, inputFileName, fileType, credential));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function encryptFile(_x8, _x9, _x10, _x11) {
        return _encryptFile.apply(this, arguments);
      }

      return encryptFile;
    }()
  }, {
    key: "decryptFile",
    value: function () {
      var _decryptFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(_ref2) {
        var fileDescriptor, fileItem;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                fileDescriptor = _ref2.fileDescriptor, fileItem = _ref2.fileItem;
                return _context5.abrupt("return", this.fileManager.decryptFile({
                  fileDescriptor: fileDescriptor,
                  fileItem: fileItem
                }));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function decryptFile(_x12) {
        return _decryptFile.apply(this, arguments);
      }

      return decryptFile;
    }()
  }, {
    key: "createTemporaryFileUrl",
    value: function createTemporaryFileUrl(_ref3) {
      var base64Data = _ref3.base64Data,
          dataType = _ref3.dataType;
      return __WEBPACK_IMPORTED_MODULE_5__lib_util_Utils__["a" /* default */].tempUrlForData(__WEBPACK_IMPORTED_MODULE_5__lib_util_Utils__["a" /* default */].base64toBinary(base64Data), dataType);
    }
    /* Credentials */

  }, {
    key: "createNewCredentials",
    value: function () {
      var _createNewCredentials = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.credentialManager.createNewCredentials());

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function createNewCredentials() {
        return _createNewCredentials.apply(this, arguments);
      }

      return createNewCredentials;
    }()
  }, {
    key: "numberOffileDescriptorsEncryptedWithCredential",
    value: function numberOffileDescriptorsEncryptedWithCredential(credential) {
      return this.fileManager.fileDescriptorsEncryptedWithCredential(credential).length;
    }
  }, {
    key: "credentialForFileDescriptor",
    value: function credentialForFileDescriptor(fileDescriptor) {
      return this.credentialManager.credentialForFileDescriptor(fileDescriptor);
    }
  }, {
    key: "getAllCredentials",
    value: function getAllCredentials() {
      return this.credentialManager.getAllCredentials();
    }
  }, {
    key: "getDefaultCredentials",
    value: function getDefaultCredentials() {
      return this.credentialManager.getDefaultCredentials();
    }
  }, {
    key: "setCredentialAsDefault",
    value: function setCredentialAsDefault(credential) {
      return this.credentialManager.setCredentialAsDefault(credential);
    }
  }, {
    key: "deleteCredential",
    value: function deleteCredential(credential) {
      return this.credentialManager.deleteCredential(credential);
    }
  }, {
    key: "saveCredential",
    value: function saveCredential(credential) {
      return this.credentialManager.saveCredential(credential);
    }
    /* Integrations */

  }, {
    key: "getAllIntegrations",
    value: function getAllIntegrations() {
      return this.integrationManager.integrations;
    }
  }, {
    key: "integrationForFileDescriptor",
    value: function integrationForFileDescriptor(fileDescriptor) {
      return this.integrationManager.integrationForFileDescriptor(fileDescriptor);
    }
  }, {
    key: "saveIntegrationFromCode",
    value: function saveIntegrationFromCode(code) {
      return this.integrationManager.saveIntegrationFromCode(code);
    }
  }, {
    key: "getDefaultIntegration",
    value: function getDefaultIntegration() {
      return this.integrationManager.getDefaultIntegration();
    }
  }, {
    key: "setIntegrationAsDefault",
    value: function setIntegrationAsDefault(integration) {
      return this.integrationManager.setIntegrationAsDefault(integration);
    }
  }, {
    key: "deleteIntegration",
    value: function deleteIntegration(integration) {
      return this.integrationManager.deleteIntegration(integration);
    }
  }]);

  return Filesafe;
}();



/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 * Build: `lodash include="includes,merge,filter,map,remove,find,omit,pull,cloneDeep,pick,uniq,sortedIndexBy,mergeWith"`
 */
;
(function () {
  function t(t, e) {
    return t.set(e[0], e[1]), t;
  }

  function e(t, e) {
    return t.add(e), t;
  }

  function n(t, e, n) {
    switch (n.length) {
      case 0:
        return t.call(e);

      case 1:
        return t.call(e, n[0]);

      case 2:
        return t.call(e, n[0], n[1]);

      case 3:
        return t.call(e, n[0], n[1], n[2]);
    }

    return t.apply(e, n);
  }

  function r(t, e) {
    for (var n = -1, r = null == t ? 0 : t.length; ++n < r && false !== e(t[n], n, t););
  }

  function o(t, e) {
    for (var n = -1, r = null == t ? 0 : t.length, o = 0, u = []; ++n < r;) {
      var c = t[n];
      e(c, n, t) && (u[o++] = c);
    }

    return u;
  }

  function u(t, e) {
    return !(null == t || !t.length) && -1 < s(t, e, 0);
  }

  function c(t, e) {
    for (var n = -1, r = null == t ? 0 : t.length, o = Array(r); ++n < r;) o[n] = e(t[n], n, t);

    return o;
  }

  function i(t, e) {
    for (var n = -1, r = e.length, o = t.length; ++n < r;) t[o + n] = e[n];

    return t;
  }

  function a(t, e, n) {
    for (var r = -1, o = null == t ? 0 : t.length; ++r < o;) n = e(n, t[r], r, t);

    return n;
  }

  function f(t, e) {
    for (var n = -1, r = null == t ? 0 : t.length; ++n < r;) if (e(t[n], n, t)) return true;

    return false;
  }

  function l(t, e, n) {
    var r = t.length;

    for (n += -1; ++n < r;) if (e(t[n], n, t)) return n;

    return -1;
  }

  function s(t, e, n) {
    if (e === e) t: {
      --n;

      for (var r = t.length; ++n < r;) if (t[n] === e) {
        t = n;
        break t;
      }

      t = -1;
    } else t = l(t, b, n);
    return t;
  }

  function b(t) {
    return t !== t;
  }

  function h(t) {
    return function (e) {
      return null == e ? ae : e[t];
    };
  }

  function p(t) {
    return function (e) {
      return t(e);
    };
  }

  function y(t, e) {
    return c(e, function (e) {
      return t[e];
    });
  }

  function j(t, e) {
    return t.has(e);
  }

  function v(t) {
    var e = -1,
        n = Array(t.size);
    return t.forEach(function (t, r) {
      n[++e] = [r, t];
    }), n;
  }

  function g(t) {
    var e = Object;
    return function (n) {
      return t(e(n));
    };
  }

  function _(t) {
    var e = -1,
        n = Array(t.size);
    return t.forEach(function (t) {
      n[++e] = t;
    }), n;
  }

  function d() {}

  function A(t) {
    var e = -1,
        n = null == t ? 0 : t.length;

    for (this.clear(); ++e < n;) {
      var r = t[e];
      this.set(r[0], r[1]);
    }
  }

  function w(t) {
    var e = -1,
        n = null == t ? 0 : t.length;

    for (this.clear(); ++e < n;) {
      var r = t[e];
      this.set(r[0], r[1]);
    }
  }

  function m(t) {
    var e = -1,
        n = null == t ? 0 : t.length;

    for (this.clear(); ++e < n;) {
      var r = t[e];
      this.set(r[0], r[1]);
    }
  }

  function O(t) {
    var e = -1,
        n = null == t ? 0 : t.length;

    for (this.__data__ = new m(); ++e < n;) this.add(t[e]);
  }

  function S(t) {
    this.size = (this.__data__ = new w(t)).size;
  }

  function k(t, e) {
    var n = Dn(t),
        r = !n && Bn(t),
        o = !n && !r && Pn(t),
        u = !n && !r && !o && Ln(t);

    if (n = n || r || o || u) {
      for (var r = t.length, c = String, i = -1, a = Array(r); ++i < r;) a[i] = c(i);

      r = a;
    } else r = [];

    var f,
        c = r.length;

    for (f in t) !e && !Ne.call(t, f) || n && ("length" == f || o && ("offset" == f || "parent" == f) || u && ("buffer" == f || "byteLength" == f || "byteOffset" == f) || mt(f, c)) || r.push(f);

    return r;
  }

  function z(t, e, n) {
    (n === ae || Bt(t[e], n)) && (n !== ae || e in t) || M(t, e, n);
  }

  function x(t, e, n) {
    var r = t[e];
    Ne.call(t, e) && Bt(r, n) && (n !== ae || e in t) || M(t, e, n);
  }

  function I(t, e) {
    for (var n = t.length; n--;) if (Bt(t[n][0], e)) return n;

    return -1;
  }

  function F(t, e) {
    return t && ut(e, Yt(e), t);
  }

  function E(t, e) {
    return t && ut(e, Zt(e), t);
  }

  function M(t, e, n) {
    "__proto__" == e && tn ? tn(t, e, {
      configurable: true,
      enumerable: true,
      value: n,
      writable: true
    }) : t[e] = n;
  }

  function $(t, e, n, o, u, c) {
    var i,
        a = 1 & e,
        f = 2 & e,
        l = 4 & e;
    if (n && (i = u ? n(t, o, u, c) : n(t)), i !== ae) return i;
    if (!Vt(t)) return t;

    if (o = Dn(t)) {
      if (i = _t(t), !a) return ot(t, i);
    } else {
      var s = Fn(t),
          b = "[object Function]" == s || "[object GeneratorFunction]" == s;
      if (Pn(t)) return et(t, a);

      if ("[object Object]" == s || "[object Arguments]" == s || b && !u) {
        if (i = f || b ? {} : dt(t), !a) return f ? it(t, E(i, t)) : ct(t, F(i, t));
      } else {
        if (!Oe[s]) return u ? t : {};
        i = At(t, s, $, a);
      }
    }

    if (c || (c = new S()), u = c.get(t)) return u;
    c.set(t, i);
    var f = l ? f ? pt : ht : f ? Zt : Yt,
        h = o ? ae : f(t);
    return r(h || t, function (r, o) {
      h && (o = r, r = t[o]), x(i, o, $(r, e, n, o, t, c));
    }), i;
  }

  function U(t, e) {
    var n = [];
    return On(t, function (t, r, o) {
      e(t, r, o) && n.push(t);
    }), n;
  }

  function B(t, e, n, r, o) {
    var u = -1,
        c = t.length;

    for (n || (n = wt), o || (o = []); ++u < c;) {
      var a = t[u];
      0 < e && n(a) ? 1 < e ? B(a, e - 1, n, r, o) : i(o, a) : r || (o[o.length] = a);
    }

    return o;
  }

  function D(t, e) {
    e = tt(e, t);

    for (var n = 0, r = e.length; null != t && n < r;) t = t[xt(e[n++])];

    return n && n == r ? t : ae;
  }

  function P(t, e, n) {
    return e = e(t), Dn(t) ? e : i(e, n(t));
  }

  function L(t) {
    if (null == t) t = t === ae ? "[object Undefined]" : "[object Null]";else if (Ze && Ze in Object(t)) {
      var e = Ne.call(t, Ze),
          n = t[Ze];

      try {
        t[Ze] = ae;
        var r = true;
      } catch (t) {}

      var o = Ce.call(t);
      r && (e ? t[Ze] = n : delete t[Ze]), t = o;
    } else t = Ce.call(t);
    return t;
  }

  function N(t) {
    return Ct(t) && "[object Arguments]" == L(t);
  }

  function V(t, e, n, r, o) {
    if (t === e) e = true;else if (null == t || null == e || !Ct(t) && !Ct(e)) e = t !== t && e !== e;else t: {
      var u = Dn(t),
          c = Dn(e),
          i = u ? "[object Array]" : Fn(t),
          a = c ? "[object Array]" : Fn(e),
          i = "[object Arguments]" == i ? "[object Object]" : i,
          a = "[object Arguments]" == a ? "[object Object]" : a,
          f = "[object Object]" == i,
          c = "[object Object]" == a;

      if ((a = i == a) && Pn(t)) {
        if (!Pn(e)) {
          e = false;
          break t;
        }

        u = true, f = false;
      }

      if (a && !f) o || (o = new S()), e = u || Ln(t) ? lt(t, e, n, r, V, o) : st(t, e, i, n, r, V, o);else {
        if (!(1 & n) && (u = f && Ne.call(t, "__wrapped__"), i = c && Ne.call(e, "__wrapped__"), u || i)) {
          t = u ? t.value() : t, e = i ? e.value() : e, o || (o = new S()), e = V(t, e, n, r, o);
          break t;
        }

        if (a) {
          e: if (o || (o = new S()), u = 1 & n, i = ht(t), c = i.length, a = ht(e).length, c == a || u) {
            for (f = c; f--;) {
              var l = i[f];

              if (!(u ? l in e : Ne.call(e, l))) {
                e = false;
                break e;
              }
            }

            if ((a = o.get(t)) && o.get(e)) e = a == e;else {
              a = true, o.set(t, e), o.set(e, t);

              for (var s = u; ++f < c;) {
                var l = i[f],
                    b = t[l],
                    h = e[l];
                if (r) var p = u ? r(h, b, l, e, t, o) : r(b, h, l, t, e, o);

                if (p === ae ? b !== h && !V(b, h, n, r, o) : !p) {
                  a = false;
                  break;
                }

                s || (s = "constructor" == l);
              }

              a && !s && (n = t.constructor, r = e.constructor, n != r && "constructor" in t && "constructor" in e && !(typeof n == "function" && n instanceof n && typeof r == "function" && r instanceof r) && (a = false)), o.delete(t), o.delete(e), e = a;
            }
          } else e = false;
        } else e = false;
      }
    }
    return e;
  }

  function C(t, e) {
    var n = e.length,
        r = n;
    if (null == t) return !r;

    for (t = Object(t); n--;) {
      var o = e[n];
      if (o[2] ? o[1] !== t[o[0]] : !(o[0] in t)) return false;
    }

    for (; ++n < r;) {
      var o = e[n],
          u = o[0],
          c = t[u],
          i = o[1];

      if (o[2]) {
        if (c === ae && !(u in t)) return false;
      } else if (o = new S(), void 0 === ae ? !V(i, c, 3, void 0, o) : 1) return false;
    }

    return true;
  }

  function R(t) {
    return Ct(t) && Nt(t.length) && !!me[L(t)];
  }

  function T(t) {
    return typeof t == "function" ? t : null == t ? ne : typeof t == "object" ? Dn(t) ? G(t[0], t[1]) : q(t) : ue(t);
  }

  function W(t, e) {
    var n = -1,
        r = Dt(t) ? Array(t.length) : [];
    return On(t, function (t, o, u) {
      r[++n] = e(t, o, u);
    }), r;
  }

  function q(t) {
    var e = vt(t);
    return 1 == e.length && e[0][2] ? kt(e[0][0], e[0][1]) : function (n) {
      return n === t || C(n, e);
    };
  }

  function G(t, e) {
    return Ot(t) && e === e && !Vt(e) ? kt(xt(t), e) : function (n) {
      var r = Qt(n, t);
      return r === ae && r === e ? Xt(n, t) : V(e, r, 3);
    };
  }

  function H(t, e, n, r, o) {
    t !== e && Sn(e, function (u, c) {
      if (Vt(u)) {
        o || (o = new S());
        var i = o,
            a = t[c],
            f = e[c],
            l = i.get(f);
        if (l) z(t, c, l);else {
          var l = r ? r(a, f, c + "", t, e, i) : ae,
              s = l === ae;

          if (s) {
            var b = Dn(f),
                h = !b && Pn(f),
                p = !b && !h && Ln(f),
                l = f;
            b || h || p ? Dn(a) ? l = a : Pt(a) ? l = ot(a) : h ? (s = false, l = et(f, true)) : p ? (s = false, l = rt(f, true)) : l = [] : Rt(f) || Bn(f) ? (l = a, Bn(a) ? l = Jt(a) : (!Vt(a) || n && Lt(a)) && (l = dt(f))) : s = false;
          }

          s && (i.set(f, l), H(l, f, n, r, i), i.delete(f)), z(t, c, l);
        }
      } else i = r ? r(t[c], u, c + "", t, e, o) : ae, i === ae && (i = u), z(t, c, i);
    }, Zt);
  }

  function J(t, e) {
    return K(t, e, function (e, n) {
      return Xt(t, n);
    });
  }

  function K(t, e, n) {
    for (var r = -1, o = e.length, u = {}; ++r < o;) {
      var c = e[r],
          i = D(t, c);

      if (n(i, c)) {
        var a = u,
            c = tt(c, t);
        if (Vt(a)) for (var c = tt(c, a), f = -1, l = c.length, s = l - 1; null != a && ++f < l;) {
          var b = xt(c[f]),
              h = i;

          if (f != s) {
            var p = a[b],
                h = ae;
            h === ae && (h = Vt(p) ? p : mt(c[f + 1]) ? [] : {});
          }

          x(a, b, h), a = a[b];
        }
      }
    }

    return u;
  }

  function Q(t) {
    return function (e) {
      return D(e, t);
    };
  }

  function X(t) {
    return En(zt(t, void 0, ne), t + "");
  }

  function Y(t) {
    if (typeof t == "string") return t;
    if (Dn(t)) return c(t, Y) + "";
    if (Wt(t)) return wn ? wn.call(t) : "";
    var e = t + "";
    return "0" == e && 1 / t == -fe ? "-0" : e;
  }

  function Z(t, e) {
    e = tt(e, t);
    var n;
    if (2 > e.length) n = t;else {
      n = e;
      var r = 0,
          o = -1,
          u = -1,
          c = n.length;

      for (0 > r && (r = -r > c ? 0 : c + r), o = o > c ? c : o, 0 > o && (o += c), c = r > o ? 0 : o - r >>> 0, r >>>= 0, o = Array(c); ++u < c;) o[u] = n[u + r];

      n = D(t, o);
    }
    t = n, null == t || delete t[xt(Mt(e))];
  }

  function tt(t, e) {
    return Dn(t) ? t : Ot(t, e) ? [t] : Mn(Kt(t));
  }

  function et(t, e) {
    if (e) return t.slice();
    var n = t.length,
        n = He ? He(n) : new t.constructor(n);
    return t.copy(n), n;
  }

  function nt(t) {
    var e = new t.constructor(t.byteLength);
    return new Ge(e).set(new Ge(t)), e;
  }

  function rt(t, e) {
    return new t.constructor(e ? nt(t.buffer) : t.buffer, t.byteOffset, t.length);
  }

  function ot(t, e) {
    var n = -1,
        r = t.length;

    for (e || (e = Array(r)); ++n < r;) e[n] = t[n];

    return e;
  }

  function ut(t, e, n) {
    var r = !n;
    n || (n = {});

    for (var o = -1, u = e.length; ++o < u;) {
      var c = e[o],
          i = ae;
      i === ae && (i = t[c]), r ? M(n, c, i) : x(n, c, i);
    }

    return n;
  }

  function ct(t, e) {
    return ut(t, xn(t), e);
  }

  function it(t, e) {
    return ut(t, In(t), e);
  }

  function at(t) {
    return X(function (e, n) {
      var r,
          o = -1,
          u = n.length,
          c = 1 < u ? n[u - 1] : ae,
          i = 2 < u ? n[2] : ae,
          c = 3 < t.length && typeof c == "function" ? (u--, c) : ae;

      if (r = i) {
        r = n[0];
        var a = n[1];

        if (Vt(i)) {
          var f = typeof a;
          r = !!("number" == f ? Dt(i) && mt(a, i.length) : "string" == f && a in i) && Bt(i[a], r);
        } else r = false;
      }

      for (r && (c = 3 > u ? ae : c, u = 1), e = Object(e); ++o < u;) (i = n[o]) && t(e, i, o, c);

      return e;
    });
  }

  function ft(t) {
    return Rt(t) ? ae : t;
  }

  function lt(t, e, n, r, o, u) {
    var c = 1 & n,
        i = t.length,
        a = e.length;
    if (i != a && !(c && a > i)) return false;
    if ((a = u.get(t)) && u.get(e)) return a == e;
    var a = -1,
        l = true,
        s = 2 & n ? new O() : ae;

    for (u.set(t, e), u.set(e, t); ++a < i;) {
      var b = t[a],
          h = e[a];
      if (r) var p = c ? r(h, b, a, e, t, u) : r(b, h, a, t, e, u);

      if (p !== ae) {
        if (p) continue;
        l = false;
        break;
      }

      if (s) {
        if (!f(e, function (t, e) {
          if (!j(s, e) && (b === t || o(b, t, n, r, u))) return s.push(e);
        })) {
          l = false;
          break;
        }
      } else if (b !== h && !o(b, h, n, r, u)) {
        l = false;
        break;
      }
    }

    return u.delete(t), u.delete(e), l;
  }

  function st(t, e, n, r, o, u, c) {
    switch (n) {
      case "[object DataView]":
        if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) break;
        t = t.buffer, e = e.buffer;

      case "[object ArrayBuffer]":
        if (t.byteLength != e.byteLength || !u(new Ge(t), new Ge(e))) break;
        return true;

      case "[object Boolean]":
      case "[object Date]":
      case "[object Number]":
        return Bt(+t, +e);

      case "[object Error]":
        return t.name == e.name && t.message == e.message;

      case "[object RegExp]":
      case "[object String]":
        return t == e + "";

      case "[object Map]":
        var i = v;

      case "[object Set]":
        if (i || (i = _), t.size != e.size && !(1 & r)) break;
        return (n = c.get(t)) ? n == e : (r |= 2, c.set(t, e), e = lt(i(t), i(e), r, o, u, c), c.delete(t), e);

      case "[object Symbol]":
        if (An) return An.call(t) == An.call(e);
    }

    return false;
  }

  function bt(t) {
    return En(zt(t, ae, Et), t + "");
  }

  function ht(t) {
    return P(t, Yt, xn);
  }

  function pt(t) {
    return P(t, Zt, In);
  }

  function yt() {
    var t = d.iteratee || re,
        t = t === re ? T : t;
    return arguments.length ? t(arguments[0], arguments[1]) : t;
  }

  function jt(t, e) {
    var n = t.__data__,
        r = typeof e;
    return ("string" == r || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== e : null === e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
  }

  function vt(t) {
    for (var e = Yt(t), n = e.length; n--;) {
      var r = e[n],
          o = t[r];
      e[n] = [r, o, o === o && !Vt(o)];
    }

    return e;
  }

  function gt(t, e) {
    var n = null == t ? ae : t[e];
    return (!Vt(n) || Ve && Ve in n ? 0 : (Lt(n) ? Te : de).test(It(n))) ? n : ae;
  }

  function _t(t) {
    var e = t.length,
        n = t.constructor(e);
    return e && "string" == typeof t[0] && Ne.call(t, "index") && (n.index = t.index, n.input = t.input), n;
  }

  function dt(t) {
    return typeof t.constructor != "function" || St(t) ? {} : mn(Je(t));
  }

  function At(n, r, o, u) {
    var c = n.constructor;

    switch (r) {
      case "[object ArrayBuffer]":
        return nt(n);

      case "[object Boolean]":
      case "[object Date]":
        return new c(+n);

      case "[object DataView]":
        return r = u ? nt(n.buffer) : n.buffer, new n.constructor(r, n.byteOffset, n.byteLength);

      case "[object Float32Array]":
      case "[object Float64Array]":
      case "[object Int8Array]":
      case "[object Int16Array]":
      case "[object Int32Array]":
      case "[object Uint8Array]":
      case "[object Uint8ClampedArray]":
      case "[object Uint16Array]":
      case "[object Uint32Array]":
        return rt(n, u);

      case "[object Map]":
        return r = u ? o(v(n), 1) : v(n), a(r, t, new n.constructor());

      case "[object Number]":
      case "[object String]":
        return new c(n);

      case "[object RegExp]":
        return r = new n.constructor(n.source, ve.exec(n)), r.lastIndex = n.lastIndex, r;

      case "[object Set]":
        return r = u ? o(_(n), 1) : _(n), a(r, e, new n.constructor());

      case "[object Symbol]":
        return An ? Object(An.call(n)) : {};
    }
  }

  function wt(t) {
    return Dn(t) || Bn(t) || !!(Ye && t && t[Ye]);
  }

  function mt(t, e) {
    return e = null == e ? 9007199254740991 : e, !!e && (typeof t == "number" || we.test(t)) && -1 < t && 0 == t % 1 && t < e;
  }

  function Ot(t, e) {
    if (Dn(t)) return false;
    var n = typeof t;
    return !("number" != n && "symbol" != n && "boolean" != n && null != t && !Wt(t)) || be.test(t) || !se.test(t) || null != e && t in Object(e);
  }

  function St(t) {
    var e = t && t.constructor;
    return t === (typeof e == "function" && e.prototype || De);
  }

  function kt(t, e) {
    return function (n) {
      return null != n && n[t] === e && (e !== ae || t in Object(n));
    };
  }

  function zt(t, e, r) {
    return e = un(e === ae ? t.length - 1 : e, 0), function () {
      for (var o = arguments, u = -1, c = un(o.length - e, 0), i = Array(c); ++u < c;) i[u] = o[e + u];

      for (u = -1, c = Array(e + 1); ++u < e;) c[u] = o[u];

      return c[e] = r(i), n(t, this, c);
    };
  }

  function xt(t) {
    if (typeof t == "string" || Wt(t)) return t;
    var e = t + "";
    return "0" == e && 1 / t == -fe ? "-0" : e;
  }

  function It(t) {
    if (null != t) {
      try {
        return Le.call(t);
      } catch (t) {}

      return t + "";
    }

    return "";
  }

  function Ft(t, e, n) {
    var r = null == t ? 0 : t.length;
    return r ? (n = null == n ? 0 : Gt(n), 0 > n && (n = un(r + n, 0)), l(t, yt(e, 3), n)) : -1;
  }

  function Et(t) {
    return (null == t ? 0 : t.length) ? B(t, 1) : [];
  }

  function Mt(t) {
    var e = null == t ? 0 : t.length;
    return e ? t[e - 1] : ae;
  }

  function $t(t, e) {
    var n;

    if (t && t.length && e && e.length) {
      n = e;
      var r = s,
          o = -1,
          u = n.length;

      for (t === n && (n = ot(n)); ++o < u;) for (var c = 0, i = n[o]; -1 < (c = r(t, i, c, void 0));) t !== t && Xe.call(t, c, 1), Xe.call(t, c, 1);

      n = t;
    } else n = t;

    return n;
  }

  function Ut(t, e) {
    function n() {
      var r = arguments,
          o = e ? e.apply(this, r) : r[0],
          u = n.cache;
      return u.has(o) ? u.get(o) : (r = t.apply(this, r), n.cache = u.set(o, r) || u, r);
    }

    if (typeof t != "function" || null != e && typeof e != "function") throw new TypeError("Expected a function");
    return n.cache = new (Ut.Cache || m)(), n;
  }

  function Bt(t, e) {
    return t === e || t !== t && e !== e;
  }

  function Dt(t) {
    return null != t && Nt(t.length) && !Lt(t);
  }

  function Pt(t) {
    return Ct(t) && Dt(t);
  }

  function Lt(t) {
    return !!Vt(t) && (t = L(t), "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t);
  }

  function Nt(t) {
    return typeof t == "number" && -1 < t && 0 == t % 1 && 9007199254740991 >= t;
  }

  function Vt(t) {
    var e = typeof t;
    return null != t && ("object" == e || "function" == e);
  }

  function Ct(t) {
    return null != t && typeof t == "object";
  }

  function Rt(t) {
    return !(!Ct(t) || "[object Object]" != L(t)) && (t = Je(t), null === t || (t = Ne.call(t, "constructor") && t.constructor, typeof t == "function" && t instanceof t && Le.call(t) == Re));
  }

  function Tt(t) {
    return typeof t == "string" || !Dn(t) && Ct(t) && "[object String]" == L(t);
  }

  function Wt(t) {
    return typeof t == "symbol" || Ct(t) && "[object Symbol]" == L(t);
  }

  function qt(t) {
    return t ? (t = Ht(t), t === fe || t === -fe ? 1.7976931348623157e308 * (0 > t ? -1 : 1) : t === t ? t : 0) : 0 === t ? t : 0;
  }

  function Gt(t) {
    t = qt(t);
    var e = t % 1;
    return t === t ? e ? t - e : t : 0;
  }

  function Ht(t) {
    if (typeof t == "number") return t;
    if (Wt(t)) return le;
    if (Vt(t) && (t = typeof t.valueOf == "function" ? t.valueOf() : t, t = Vt(t) ? t + "" : t), typeof t != "string") return 0 === t ? t : +t;
    t = t.replace(ye, "");

    var e = _e.test(t);

    return e || Ae.test(t) ? ke(t.slice(2), e ? 2 : 8) : ge.test(t) ? le : +t;
  }

  function Jt(t) {
    return ut(t, Zt(t));
  }

  function Kt(t) {
    return null == t ? "" : Y(t);
  }

  function Qt(t, e, n) {
    return t = null == t ? ae : D(t, e), t === ae ? n : t;
  }

  function Xt(t, e) {
    var n;

    if (n = null != t) {
      n = t;
      var r;
      r = tt(e, n);

      for (var o = -1, u = r.length, c = false; ++o < u;) {
        var i = xt(r[o]);
        if (!(c = null != n && null != n && i in Object(n))) break;
        n = n[i];
      }

      c || ++o != u ? n = c : (u = null == n ? 0 : n.length, n = !!u && Nt(u) && mt(i, u) && (Dn(n) || Bn(n)));
    }

    return n;
  }

  function Yt(t) {
    if (Dt(t)) t = k(t);else if (St(t)) {
      var e,
          n = [];

      for (e in Object(t)) Ne.call(t, e) && "constructor" != e && n.push(e);

      t = n;
    } else t = on(t);
    return t;
  }

  function Zt(t) {
    if (Dt(t)) t = k(t, true);else if (Vt(t)) {
      var e,
          n = St(t),
          r = [];

      for (e in t) ("constructor" != e || !n && Ne.call(t, e)) && r.push(e);

      t = r;
    } else {
      if (e = [], null != t) for (n in Object(t)) e.push(n);
      t = e;
    }
    return t;
  }

  function te(t) {
    return null == t ? [] : y(t, Yt(t));
  }

  function ee(t) {
    return function () {
      return t;
    };
  }

  function ne(t) {
    return t;
  }

  function re(t) {
    return T(typeof t == "function" ? t : $(t, 1));
  }

  function oe() {}

  function ue(t) {
    return Ot(t) ? h(xt(t)) : Q(t);
  }

  function ce() {
    return [];
  }

  function ie() {
    return false;
  }

  var ae,
      fe = 1 / 0,
      le = NaN,
      se = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      be = /^\w*$/,
      he = /^\./,
      pe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      ye = /^\s+|\s+$/g,
      je = /\\(\\)?/g,
      ve = /\w*$/,
      ge = /^[-+]0x[0-9a-f]+$/i,
      _e = /^0b[01]+$/i,
      de = /^\[object .+?Constructor\]$/,
      Ae = /^0o[0-7]+$/i,
      we = /^(?:0|[1-9]\d*)$/,
      me = {};
  me["[object Float32Array]"] = me["[object Float64Array]"] = me["[object Int8Array]"] = me["[object Int16Array]"] = me["[object Int32Array]"] = me["[object Uint8Array]"] = me["[object Uint8ClampedArray]"] = me["[object Uint16Array]"] = me["[object Uint32Array]"] = true, me["[object Arguments]"] = me["[object Array]"] = me["[object ArrayBuffer]"] = me["[object Boolean]"] = me["[object DataView]"] = me["[object Date]"] = me["[object Error]"] = me["[object Function]"] = me["[object Map]"] = me["[object Number]"] = me["[object Object]"] = me["[object RegExp]"] = me["[object Set]"] = me["[object String]"] = me["[object WeakMap]"] = false;
  var Oe = {};
  Oe["[object Arguments]"] = Oe["[object Array]"] = Oe["[object ArrayBuffer]"] = Oe["[object DataView]"] = Oe["[object Boolean]"] = Oe["[object Date]"] = Oe["[object Float32Array]"] = Oe["[object Float64Array]"] = Oe["[object Int8Array]"] = Oe["[object Int16Array]"] = Oe["[object Int32Array]"] = Oe["[object Map]"] = Oe["[object Number]"] = Oe["[object Object]"] = Oe["[object RegExp]"] = Oe["[object Set]"] = Oe["[object String]"] = Oe["[object Symbol]"] = Oe["[object Uint8Array]"] = Oe["[object Uint8ClampedArray]"] = Oe["[object Uint16Array]"] = Oe["[object Uint32Array]"] = true, Oe["[object Error]"] = Oe["[object Function]"] = Oe["[object WeakMap]"] = false;
  var Se,
      ke = parseInt,
      ze = typeof global == "object" && global && global.Object === Object && global,
      xe = typeof self == "object" && self && self.Object === Object && self,
      Ie = ze || xe || Function("return this")(),
      Fe = typeof exports == "object" && exports && !exports.nodeType && exports,
      Ee = Fe && typeof module == "object" && module && !module.nodeType && module,
      Me = Ee && Ee.exports === Fe,
      $e = Me && ze.process;

  t: {
    try {
      Se = $e && $e.binding && $e.binding("util");
      break t;
    } catch (t) {}

    Se = void 0;
  }

  var Ue = Se && Se.isTypedArray,
      Be = Array.prototype,
      De = Object.prototype,
      Pe = Ie["__core-js_shared__"],
      Le = Function.prototype.toString,
      Ne = De.hasOwnProperty,
      Ve = function () {
    var t = /[^.]+$/.exec(Pe && Pe.keys && Pe.keys.IE_PROTO || "");
    return t ? "Symbol(src)_1." + t : "";
  }(),
      Ce = De.toString,
      Re = Le.call(Object),
      Te = RegExp("^" + Le.call(Ne).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
      We = Me ? Ie.Buffer : ae,
      qe = Ie.Symbol,
      Ge = Ie.Uint8Array,
      He = We ? We.a : ae,
      Je = g(Object.getPrototypeOf),
      Ke = Object.create,
      Qe = De.propertyIsEnumerable,
      Xe = Be.splice,
      Ye = qe ? qe.isConcatSpreadable : ae,
      Ze = qe ? qe.toStringTag : ae,
      tn = function () {
    try {
      var t = gt(Object, "defineProperty");
      return t({}, "", {}), t;
    } catch (t) {}
  }(),
      en = Math.floor,
      nn = Object.getOwnPropertySymbols,
      rn = We ? We.isBuffer : ae,
      on = g(Object.keys),
      un = Math.max,
      cn = Math.min,
      an = Date.now,
      fn = gt(Ie, "DataView"),
      ln = gt(Ie, "Map"),
      sn = gt(Ie, "Promise"),
      bn = gt(Ie, "Set"),
      hn = gt(Ie, "WeakMap"),
      pn = gt(Object, "create"),
      yn = It(fn),
      jn = It(ln),
      vn = It(sn),
      gn = It(bn),
      _n = It(hn),
      dn = qe ? qe.prototype : ae,
      An = dn ? dn.valueOf : ae,
      wn = dn ? dn.toString : ae,
      mn = function () {
    function t() {}

    return function (e) {
      return Vt(e) ? Ke ? Ke(e) : (t.prototype = e, e = new t(), t.prototype = ae, e) : {};
    };
  }();

  A.prototype.clear = function () {
    this.__data__ = pn ? pn(null) : {}, this.size = 0;
  }, A.prototype.delete = function (t) {
    return t = this.has(t) && delete this.__data__[t], this.size -= t ? 1 : 0, t;
  }, A.prototype.get = function (t) {
    var e = this.__data__;
    return pn ? (t = e[t], "__lodash_hash_undefined__" === t ? ae : t) : Ne.call(e, t) ? e[t] : ae;
  }, A.prototype.has = function (t) {
    var e = this.__data__;
    return pn ? e[t] !== ae : Ne.call(e, t);
  }, A.prototype.set = function (t, e) {
    var n = this.__data__;
    return this.size += this.has(t) ? 0 : 1, n[t] = pn && e === ae ? "__lodash_hash_undefined__" : e, this;
  }, w.prototype.clear = function () {
    this.__data__ = [], this.size = 0;
  }, w.prototype.delete = function (t) {
    var e = this.__data__;
    return t = I(e, t), !(0 > t) && (t == e.length - 1 ? e.pop() : Xe.call(e, t, 1), --this.size, true);
  }, w.prototype.get = function (t) {
    var e = this.__data__;
    return t = I(e, t), 0 > t ? ae : e[t][1];
  }, w.prototype.has = function (t) {
    return -1 < I(this.__data__, t);
  }, w.prototype.set = function (t, e) {
    var n = this.__data__,
        r = I(n, t);
    return 0 > r ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
  }, m.prototype.clear = function () {
    this.size = 0, this.__data__ = {
      hash: new A(),
      map: new (ln || w)(),
      string: new A()
    };
  }, m.prototype.delete = function (t) {
    return t = jt(this, t).delete(t), this.size -= t ? 1 : 0, t;
  }, m.prototype.get = function (t) {
    return jt(this, t).get(t);
  }, m.prototype.has = function (t) {
    return jt(this, t).has(t);
  }, m.prototype.set = function (t, e) {
    var n = jt(this, t),
        r = n.size;
    return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
  }, O.prototype.add = O.prototype.push = function (t) {
    return this.__data__.set(t, "__lodash_hash_undefined__"), this;
  }, O.prototype.has = function (t) {
    return this.__data__.has(t);
  }, S.prototype.clear = function () {
    this.__data__ = new w(), this.size = 0;
  }, S.prototype.delete = function (t) {
    var e = this.__data__;
    return t = e.delete(t), this.size = e.size, t;
  }, S.prototype.get = function (t) {
    return this.__data__.get(t);
  }, S.prototype.has = function (t) {
    return this.__data__.has(t);
  }, S.prototype.set = function (t, e) {
    var n = this.__data__;

    if (n instanceof w) {
      var r = n.__data__;
      if (!ln || 199 > r.length) return r.push([t, e]), this.size = ++n.size, this;
      n = this.__data__ = new m(r);
    }

    return n.set(t, e), this.size = n.size, this;
  };

  var On = function (t, e) {
    return function (n, r) {
      if (null == n) return n;
      if (!Dt(n)) return t(n, r);

      for (var o = n.length, u = e ? o : -1, c = Object(n); (e ? u-- : ++u < o) && false !== r(c[u], u, c););

      return n;
    };
  }(function (t, e) {
    return t && Sn(t, e, Yt);
  }),
      Sn = function (t) {
    return function (e, n, r) {
      var o = -1,
          u = Object(e);
      r = r(e);

      for (var c = r.length; c--;) {
        var i = r[t ? c : ++o];
        if (false === n(u[i], i, u)) break;
      }

      return e;
    };
  }(),
      kn = tn ? function (t, e) {
    return tn(t, "toString", {
      configurable: true,
      enumerable: false,
      value: ee(e),
      writable: true
    });
  } : ne,
      zn = bn && 1 / _(new bn([, -0]))[1] == fe ? function (t) {
    return new bn(t);
  } : oe,
      xn = nn ? function (t) {
    return null == t ? [] : (t = Object(t), o(nn(t), function (e) {
      return Qe.call(t, e);
    }));
  } : ce,
      In = nn ? function (t) {
    for (var e = []; t;) i(e, xn(t)), t = Je(t);

    return e;
  } : ce,
      Fn = L;

  (fn && "[object DataView]" != Fn(new fn(new ArrayBuffer(1))) || ln && "[object Map]" != Fn(new ln()) || sn && "[object Promise]" != Fn(sn.resolve()) || bn && "[object Set]" != Fn(new bn()) || hn && "[object WeakMap]" != Fn(new hn())) && (Fn = function (t) {
    var e = L(t);
    if (t = (t = "[object Object]" == e ? t.constructor : ae) ? It(t) : "") switch (t) {
      case yn:
        return "[object DataView]";

      case jn:
        return "[object Map]";

      case vn:
        return "[object Promise]";

      case gn:
        return "[object Set]";

      case _n:
        return "[object WeakMap]";
    }
    return e;
  });

  var En = function (t) {
    var e = 0,
        n = 0;
    return function () {
      var r = an(),
          o = 16 - (r - n);

      if (n = r, 0 < o) {
        if (800 <= ++e) return arguments[0];
      } else e = 0;

      return t.apply(ae, arguments);
    };
  }(kn),
      Mn = function (t) {
    t = Ut(t, function (t) {
      return 500 === e.size && e.clear(), t;
    });
    var e = t.cache;
    return t;
  }(function (t) {
    var e = [];
    return he.test(t) && e.push(""), t.replace(pe, function (t, n, r, o) {
      e.push(r ? o.replace(je, "$1") : n || t);
    }), e;
  }),
      $n = X($t),
      Un = function (t) {
    return function (e, n, r) {
      var o = Object(e);

      if (!Dt(e)) {
        var u = yt(n, 3);
        e = Yt(e), n = function (t) {
          return u(o[t], t, o);
        };
      }

      return n = t(e, n, r), -1 < n ? o[u ? e[n] : n] : ae;
    };
  }(Ft);

  Ut.Cache = m;
  var Bn = N(function () {
    return arguments;
  }()) ? N : function (t) {
    return Ct(t) && Ne.call(t, "callee") && !Qe.call(t, "callee");
  },
      Dn = Array.isArray,
      Pn = rn || ie,
      Ln = Ue ? p(Ue) : R,
      Nn = at(function (t, e, n) {
    H(t, e, n);
  }),
      Vn = at(function (t, e, n, r) {
    H(t, e, n, r);
  }),
      Cn = bt(function (t, e) {
    var n = {};
    if (null == t) return n;
    var r = false;
    e = c(e, function (e) {
      return e = tt(e, t), r || (r = 1 < e.length), e;
    }), ut(t, pt(t), n), r && (n = $(n, 7, ft));

    for (var o = e.length; o--;) Z(n, e[o]);

    return n;
  }),
      Rn = bt(function (t, e) {
    return null == t ? {} : J(t, e);
  });
  d.constant = ee, d.filter = function (t, e) {
    return (Dn(t) ? o : U)(t, yt(e, 3));
  }, d.flatten = Et, d.iteratee = re, d.keys = Yt, d.keysIn = Zt, d.map = function (t, e) {
    return (Dn(t) ? c : W)(t, yt(e, 3));
  }, d.memoize = Ut, d.merge = Nn, d.mergeWith = Vn, d.omit = Cn, d.pick = Rn, d.property = ue, d.pull = $n, d.pullAll = $t, d.remove = function (t, e) {
    var n = [];
    if (!t || !t.length) return n;
    var r = -1,
        o = [],
        u = t.length;

    for (e = yt(e, 3); ++r < u;) {
      var c = t[r];
      e(c, r, t) && (n.push(c), o.push(r));
    }

    for (r = t ? o.length : 0, u = r - 1; r--;) if (c = o[r], r == u || c !== i) {
      var i = c;
      mt(c) ? Xe.call(t, c, 1) : Z(t, c);
    }

    return n;
  }, d.toPlainObject = Jt, d.uniq = function (t) {
    if (t && t.length) t: {
      var e = -1,
          n = u,
          r = t.length,
          o = true,
          c = [],
          i = c;

      if (200 <= r) {
        if (n = zn(t)) {
          t = _(n);
          break t;
        }

        o = false, n = j, i = new O();
      } else i = c;

      e: for (; ++e < r;) {
        var a = t[e],
            f = a,
            a = 0 !== a ? a : 0;

        if (o && f === f) {
          for (var l = i.length; l--;) if (i[l] === f) continue e;

          c.push(a);
        } else n(i, f, void 0) || (i !== c && i.push(f), c.push(a));
      }

      t = c;
    } else t = [];
    return t;
  }, d.values = te, d.cloneDeep = function (t) {
    return $(t, 5);
  }, d.eq = Bt, d.find = Un, d.findIndex = Ft, d.get = Qt, d.hasIn = Xt, d.identity = ne, d.includes = function (t, e, n, r) {
    return t = Dt(t) ? t : te(t), n = n && !r ? Gt(n) : 0, r = t.length, 0 > n && (n = un(r + n, 0)), Tt(t) ? n <= r && -1 < t.indexOf(e, n) : !!r && -1 < s(t, e, n);
  }, d.isArguments = Bn, d.isArray = Dn, d.isArrayLike = Dt, d.isArrayLikeObject = Pt, d.isBuffer = Pn, d.isFunction = Lt, d.isLength = Nt, d.isObject = Vt, d.isObjectLike = Ct, d.isPlainObject = Rt, d.isString = Tt, d.isSymbol = Wt, d.isTypedArray = Ln, d.last = Mt, d.stubArray = ce, d.stubFalse = ie, d.noop = oe, d.sortedIndexBy = function (t, e, n) {
    n = yt(n, 2), e = n(e);

    for (var r = 0, o = null == t ? 0 : t.length, u = e !== e, c = null === e, i = Wt(e), a = e === ae; r < o;) {
      var f = en((r + o) / 2),
          l = n(t[f]),
          s = l !== ae,
          b = null === l,
          h = l === l,
          p = Wt(l);
      (u ? h : a ? h && s : c ? h && s && !b : i ? h && s && !b && !p : b || p ? 0 : l < e) ? r = f + 1 : o = f;
    }

    return cn(o, 4294967294);
  }, d.toFinite = qt, d.toInteger = Gt, d.toNumber = Ht, d.toString = Kt, d.VERSION = "4.17.4",  true ? (Ie._ = d, !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return d;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : Ee ? ((Ee.exports = d)._ = d, Fe._ = d) : Ie._ = d;
}).call(this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(6)(module)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RelayManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_standard_file_js__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var RelayManager =
/*#__PURE__*/
function () {
  function RelayManager() {
    _classCallCheck(this, RelayManager);

    this.httpManger = new __WEBPACK_IMPORTED_MODULE_1_standard_file_js__["SFHttpManager"]();
    this.httpManger.setJWTRequestHandler(function () {});
  }

  _createClass(RelayManager, [{
    key: "setCredentials",
    value: function setCredentials(credentials) {
      this.credentials = credentials;
    }
  }, {
    key: "uploadFile",
    value: function () {
      var _uploadFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(name, item, integration) {
        var _this = this;

        var url, params;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                url = "".concat(integration.content.relayUrl, "/integrations/save-item");
                params = {
                  file: {
                    name: name,
                    item: item // base64 string of file

                  },
                  source: integration.content.source,
                  authorization: integration.content.authorization
                };
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  _this.httpManger.postAbsolute(url, params, function (response) {
                    resolve(response.metadata);
                  }, function (errorResponse) {
                    var error = errorResponse.error;

                    if (!error) {
                      error = {
                        message: "File upload failed."
                      };
                    }

                    console.log("Upload error response", error);
                    reject(error);
                  });
                }));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function uploadFile(_x, _x2, _x3) {
        return _uploadFile.apply(this, arguments);
      }

      return uploadFile;
    }()
  }, {
    key: "downloadFile",
    value: function () {
      var _downloadFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(fileDescriptor, integration) {
        var _this2 = this;

        var url, params;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                url = "".concat(integration.content.relayUrl, "/integrations/download-item");
                params = {
                  metadata: fileDescriptor.content.serverMetadata,
                  authorization: integration.content.authorization
                };
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  _this2.httpManger.postAbsolute(url, params, function (response) {
                    resolve(response);
                  }, function (errorResponse) {
                    var error = errorResponse.error;
                    console.log("Download error response", errorResponse);
                    reject(error);
                  });
                }));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function downloadFile(_x4, _x5) {
        return _downloadFile.apply(this, arguments);
      }

      return downloadFile;
    }()
  }, {
    key: "deleteFile",
    value: function () {
      var _deleteFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(fileDescriptor, integration) {
        var _this3 = this;

        var url, params;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                url = "".concat(integration.content.relayUrl, "/integrations/delete-item");
                params = {
                  metadata: fileDescriptor.content.serverMetadata,
                  authorization: integration.content.authorization
                };
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  _this3.httpManger.postAbsolute(url, params, function (response) {
                    resolve(response);
                  }, function (errorResponse) {
                    var error = errorResponse.error;
                    console.log("Download error response", errorResponse);
                    reject(error);
                  });
                }));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function deleteFile(_x6, _x7) {
        return _deleteFile.apply(this, arguments);
      }

      return deleteFile;
    }()
  }]);

  return RelayManager;
}();



/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IntegrationManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_standard_file_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__ = __webpack_require__(2);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var IntegrationManager =
/*#__PURE__*/
function () {
  function IntegrationManager(extensionBridge) {
    _classCallCheck(this, IntegrationManager);

    this.extensionBridge = extensionBridge;
  }

  _createClass(IntegrationManager, [{
    key: "integrationForFileDescriptor",
    value: function integrationForFileDescriptor(descriptor) {
      return this.integrations.find(function (integration) {
        return descriptor.content.serverMetadata && integration.content.source == descriptor.content.serverMetadata.source;
      });
    }
  }, {
    key: "parseIntegrationCode",
    value: function parseIntegrationCode(code) {
      var jsonString = atob(code);
      var integration = JSON.parse(jsonString);
      integration.rawCode = code;
      return integration;
    }
  }, {
    key: "saveIntegrationFromCode",
    value: function () {
      var _saveIntegrationFromCode = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(code) {
        var content, integration;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                content = this.parseIntegrationCode(code);

                if (this.integrations.length == 0) {
                  content.isDefaultUploadSource = true;
                }

                integration = this.createAndSaveIntegrationObject(content);
                return _context.abrupt("return", integration);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function saveIntegrationFromCode(_x) {
        return _saveIntegrationFromCode.apply(this, arguments);
      }

      return saveIntegrationFromCode;
    }()
  }, {
    key: "createAndSaveIntegrationObject",
    value: function createAndSaveIntegrationObject(content) {
      var integration = new __WEBPACK_IMPORTED_MODULE_1_standard_file_js__["SFItem"]({
        content_type: __WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__["a" /* default */].FileSafeIntegrationContentTypeKey,
        content: content
      });
      this.extensionBridge.createItems([integration]);
      return integration;
    }
  }, {
    key: "getDefaultUploadSource",
    value: function getDefaultUploadSource() {
      return this.integrations.find(function (integration) {
        return integration.content.isDefaultUploadSource;
      });
    }
  }, {
    key: "setIntegrationAsDefault",
    value: function setIntegrationAsDefault(integration) {
      var currentDefault = this.getDefaultUploadSource();

      if (currentDefault) {
        currentDefault.content.isDefaultUploadSource = false;
      }

      integration.content.isDefaultUploadSource = true;
      this.extensionBridge.saveItem(integration);
    }
  }, {
    key: "deleteIntegration",
    value: function deleteIntegration(integrationObject) {
      var _this = this;

      var isDefault = integrationObject.content.isDefaultUploadSource;
      this.extensionBridge.deleteItem(integrationObject, function (response) {
        if (response.deleted && isDefault) {
          if (_this.integrations.length > 0) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _this.integrations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var currentIntegration = _step.value;

                if (currentIntegration != integrationObject) {
                  _this.setIntegrationAsDefault(currentIntegration);

                  break;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "integrations",
    get: function get() {
      return this.extensionBridge.filterItems(__WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__["a" /* default */].FileSafeIntegrationContentTypeKey);
    }
  }]);

  return IntegrationManager;
}();



/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CredentialManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_standard_file_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__ = __webpack_require__(2);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var CredentialManager =
/*#__PURE__*/
function () {
  function CredentialManager(_ref) {
    var _this = this;

    var extensionBridge = _ref.extensionBridge,
        onCredentialLoad = _ref.onCredentialLoad;

    _classCallCheck(this, CredentialManager);

    _defineProperty(this, "getDefaultCredentials", function () {
      var defaultCredentials = _this.credentials.find(function (candidate) {
        return candidate.content.isDefault;
      });

      if (!defaultCredentials && _this.credentials.length > 0) {
        defaultCredentials = _this.credentials[0];
      }

      return defaultCredentials;
    });

    _defineProperty(this, "setCredentialAsDefault", function (credential) {
      var currentDefault = _this.getDefaultCredentials();

      if (currentDefault) {
        currentDefault.content.isDefault = false;
      }

      credential.content.isDefault = true;

      _this.extensionBridge.saveItems([currentDefault, credential]);
    });

    _defineProperty(this, "deleteCredential", function (credential) {
      _this.extensionBridge.deleteItem(credential);
    });

    this.extensionBridge = extensionBridge;
    this.onCredentialLoad = onCredentialLoad;
    this.credentials = [];
    this.extensionBridge.addEventHandler(function (event) {
      if (event == __WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__["a" /* default */].BridgeEventReceivedItems) {
        _this.reloadCredentials();
      }
    });
  }

  _createClass(CredentialManager, [{
    key: "reloadCredentials",
    value: function reloadCredentials() {
      // clear current credentials, search results should contain all items and not just new incoming stuff.
      this.credentials = [];
      var searchResults = this.extensionBridge.filterItems(__WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__["a" /* default */].FileSafeCredentialsContentType);

      if (searchResults.length == 0) {
        return;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = searchResults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var incomingCredentials = _step.value;

          if (!this.credentials.find(function (candidate) {
            return candidate.uuid == incomingCredentials.uuid;
          })) {
            this.credentials.push(incomingCredentials);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      console.log("Reloaded credentials", this.credentials);
      this.onCredentialLoad();

      if (this.credentials.length > 0) {
        this.didLoadCredentials();
      }
    }
  }, {
    key: "createNewCredentials",
    value: function () {
      var _createNewCredentials = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var bits, identifer, password, credentialParams, credentials;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                bits = 256;
                _context.next = 3;
                return SFJS.crypto.generateRandomKey(bits);

              case 3:
                identifer = _context.sent;
                _context.next = 6;
                return SFJS.crypto.generateRandomKey(bits);

              case 6:
                password = _context.sent;
                _context.next = 9;
                return SFJS.crypto.generateInitialKeysAndAuthParamsForUser(identifer, password);

              case 9:
                credentialParams = _context.sent;
                credentialParams.isDefault = this.credentials.length == 0;
                credentials = new __WEBPACK_IMPORTED_MODULE_1_standard_file_js__["SFItem"]({
                  content_type: __WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__["a" /* default */].FileSafeCredentialsContentType,
                  content: credentialParams
                });
                this.extensionBridge.saveItem(credentials);
                this.didLoadCredentials();
                return _context.abrupt("return", credentials);

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createNewCredentials() {
        return _createNewCredentials.apply(this, arguments);
      }

      return createNewCredentials;
    }()
  }, {
    key: "didLoadCredentials",
    value: function didLoadCredentials() {
      this.extensionBridge.notifyObserversOfEvent(__WEBPACK_IMPORTED_MODULE_2__ExtensionBridge__["a" /* default */].BridgeEventLoadedCredentials);
    }
  }, {
    key: "credentialForFileDescriptor",
    value: function credentialForFileDescriptor(fileDescriptor) {
      console.log("Getting credential for file", fileDescriptor);
      return this.credentials.find(function (candidate) {
        return fileDescriptor.content.references.find(function (ref) {
          return ref.uuid == candidate.uuid;
        });
      });
    }
  }, {
    key: "getAllCredentials",
    value: function getAllCredentials() {
      return this.credentials;
    }
  }, {
    key: "saveCredential",
    value: function saveCredential(credentials) {
      this.extensionBridge.saveItem(credentials);
    }
  }]);

  return CredentialManager;
}();



/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_standard_file_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_encryption_worker_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_encryption_worker_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_encryption_worker_js__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var FileManager =
/*#__PURE__*/
function () {
  function FileManager(extensionBridge, relayManager, integrationManager, credentialManager) {
    _classCallCheck(this, FileManager);

    this.extensionBridge = extensionBridge;
    this.relayManager = relayManager;
    this.integrationManager = integrationManager;
    this.credentialManager = credentialManager;
  }

  _createClass(FileManager, [{
    key: "getAllFileDescriptors",
    value: function getAllFileDescriptors() {
      return this.extensionBridge.getFileDescriptors();
    }
  }, {
    key: "fileDescriptorsForNote",
    value: function fileDescriptorsForNote(note) {
      if (!note) {
        return [];
      }

      return this.extensionBridge.getFileDescriptors().filter(function (fileDescriptor) {
        return fileDescriptor.hasRelationshipWithItem(note);
      });
    }
  }, {
    key: "fileDescriptorsEncryptedWithCredential",
    value: function fileDescriptorsEncryptedWithCredential(credential) {
      var descriptors = this.extensionBridge.getFileDescriptors();
      return descriptors.filter(function (descriptor) {
        return descriptor.content.references.find(function (ref) {
          return uuid == credential.uuid;
        });
      });
    }
  }, {
    key: "deleteFileFromDescriptor",
    value: function () {
      var _deleteFileFromDescriptor = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(fileDescriptor) {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  _this.extensionBridge.deleteItems([fileDescriptor], function (response) {
                    if (response.deleted) {
                      var integration = _this.integrationManager.integrationForFileDescriptor(fileDescriptor);

                      if (integration) {
                        _this.relayManager.deleteFile(fileDescriptor, integration).then(function (relayResponse) {
                          resolve();
                        });
                      }
                    } else {
                      resolve(response);
                    }
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function deleteFileFromDescriptor(_x) {
        return _deleteFileFromDescriptor.apply(this, arguments);
      }

      return deleteFileFromDescriptor;
    }()
  }, {
    key: "uploadFile",
    value: function () {
      var _uploadFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(itemParams, inputFileName, fileType, credential, note) {
        var _this2 = this;

        var integration, outputFileName;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                integration = this.integrationManager.getDefaultUploadSource();
                outputFileName = "".concat(inputFileName, ".sf.json");
                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  var worker = new __WEBPACK_IMPORTED_MODULE_2__util_encryption_worker_js___default.a();
                  worker.addEventListener("message", function (event) {
                    var data = event.data;

                    if (data.error) {
                      reject(data.error);
                      return;
                    }

                    var fileDescriptor = new __WEBPACK_IMPORTED_MODULE_1_standard_file_js__["SFItem"]({
                      content_type: ExtensionBridge.FileDescriptorContentTypeKey,
                      content: {
                        serverMetadata: event.data.metadata,
                        fileName: inputFileName,
                        fileType: fileType
                      }
                    });
                    fileDescriptor.addItemAsRelationship(note);
                    fileDescriptor.addItemAsRelationship(credential);

                    _this2.extensionBridge.createItem(fileDescriptor);

                    resolve();
                  });
                  var operation = "upload";
                  var params = {
                    outputFileName: outputFileName,
                    itemParams: itemParams,
                    integration: integration,
                    operation: operation,
                    credentials: _this2.credentialManager.getDefaultCredentials()
                  };
                  worker.postMessage(params);
                }));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function uploadFile(_x2, _x3, _x4, _x5, _x6) {
        return _uploadFile.apply(this, arguments);
      }

      return uploadFile;
    }()
  }, {
    key: "downloadFileFromDescriptor",
    value: function () {
      var _downloadFileFromDescriptor = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(fileDescriptor) {
        var integration, serverMetadata;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // TODO: Use web worker for this as well?
                integration = this.integrationManager.integrationForFileDescriptor(fileDescriptor);

                if (integration) {
                  _context3.next = 6;
                  break;
                }

                serverMetadata = fileDescriptor.content.serverMetadata;

                if (serverMetadata) {
                  alert("Unable to find integration named '".concat(serverMetadata.source, "'."));
                } else {
                  alert("Unable to find integration for this file.");
                }

                throw "Unable to find integration";

              case 6:
                return _context3.abrupt("return", this.relayManager.downloadFile(fileDescriptor, integration).then(function (data) {
                  var item = data.items[0];
                  return item;
                }));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function downloadFileFromDescriptor(_x7) {
        return _downloadFileFromDescriptor.apply(this, arguments);
      }

      return downloadFileFromDescriptor;
    }()
  }, {
    key: "encryptFile",
    value: function () {
      var _encryptFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(data, inputFileName, fileType, credential) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", new Promise(function (resolve, reject) {
                  var worker = new __WEBPACK_IMPORTED_MODULE_2__util_encryption_worker_js___default.a();
                  worker.addEventListener("message", function (event) {
                    resolve(event.data.itemParams);
                  });
                  worker.postMessage({
                    operation: "encrypt",
                    keys: credential.content.keys,
                    authParams: credential.content.authParams,
                    contentType: ExtensionBridge.FileItemContentTypeKey,
                    fileData: data,
                    fileName: inputFileName,
                    fileType: fileType
                  });
                }));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function encryptFile(_x8, _x9, _x10, _x11) {
        return _encryptFile.apply(this, arguments);
      }

      return encryptFile;
    }()
  }, {
    key: "decryptFile",
    value: function () {
      var _decryptFile = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(_ref) {
        var fileDescriptor, fileItem, credential;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                fileDescriptor = _ref.fileDescriptor, fileItem = _ref.fileItem;
                credential = this.credentialManager.credentialForFileDescriptor(fileDescriptor);
                return _context5.abrupt("return", new Promise(function (resolve, reject) {
                  var worker = new __WEBPACK_IMPORTED_MODULE_2__util_encryption_worker_js___default.a();
                  worker.addEventListener("message", function (event) {
                    var data = event.data;

                    if (data.error) {
                      reject(data.error);
                      return;
                    }

                    resolve(data);
                  });
                  worker.postMessage({
                    operation: "decrypt",
                    keys: credential.content.keys,
                    item: fileItem
                  });
                }));

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function decryptFile(_x12) {
        return _decryptFile.apply(this, arguments);
      }

      return decryptFile;
    }()
  }]);

  return FileManager;
}();

_defineProperty(FileManager, "FileItemContentTypeKey", "SN|FileSafe|File");

_defineProperty(FileManager, "FileDescriptorContentTypeKey", "SN|FileSafe|FileMetadata");



/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports=function(){return __webpack_require__(12)("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n!function (global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    } // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n\n\n    return;\n  } // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n\n\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      prototype[method] = function (arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  runtime.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  runtime.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  runtime.async = function (innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  runtime.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n}( // In sloppy mode, unbound `this` refers to the global object, fallback to\n// Function constructor if we're in global strict mode. That is sadly a form\n// of indirect eval which violates Content Security Policy.\nfunction () {\n  return this;\n}() || Function(\"return this\")());\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;var require;(function (f) {\n  if (true) {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.SF = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return require(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      (function (global) {\n        /*\n        CryptoJS v3.1.2\n        code.google.com/p/crypto-js\n        (c) 2009-2013 by Jeff Mott. All rights reserved.\n        code.google.com/p/crypto-js/wiki/License\n        */\n        var CryptoJS = CryptoJS || function (u, p) {\n          var d = {},\n              l = d.lib = {},\n              s = function () {},\n              t = l.Base = {\n            extend: function (a) {\n              s.prototype = this;\n              var c = new s();\n              a && c.mixIn(a);\n              c.hasOwnProperty(\"init\") || (c.init = function () {\n                c.$super.init.apply(this, arguments);\n              });\n              c.init.prototype = c;\n              c.$super = this;\n              return c;\n            },\n            create: function () {\n              var a = this.extend();\n              a.init.apply(a, arguments);\n              return a;\n            },\n            init: function () {},\n            mixIn: function (a) {\n              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);\n\n              a.hasOwnProperty(\"toString\") && (this.toString = a.toString);\n            },\n            clone: function () {\n              return this.init.prototype.extend(this);\n            }\n          },\n              r = l.WordArray = t.extend({\n            init: function (a, c) {\n              a = this.words = a || [];\n              this.sigBytes = c != p ? c : 4 * a.length;\n            },\n            toString: function (a) {\n              return (a || v).stringify(this);\n            },\n            concat: function (a) {\n              var c = this.words,\n                  e = a.words,\n                  j = this.sigBytes;\n              a = a.sigBytes;\n              this.clamp();\n              if (j % 4) for (var k = 0; k < a; k++) c[j + k >>> 2] |= (e[k >>> 2] >>> 24 - 8 * (k % 4) & 255) << 24 - 8 * ((j + k) % 4);else if (65535 < e.length) for (k = 0; k < a; k += 4) c[j + k >>> 2] = e[k >>> 2];else c.push.apply(c, e);\n              this.sigBytes += a;\n              return this;\n            },\n            clamp: function () {\n              var a = this.words,\n                  c = this.sigBytes;\n              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);\n              a.length = u.ceil(c / 4);\n            },\n            clone: function () {\n              var a = t.clone.call(this);\n              a.words = this.words.slice(0);\n              return a;\n            },\n            random: function (a) {\n              for (var c = [], e = 0; e < a; e += 4) c.push(4294967296 * u.random() | 0);\n\n              return new r.init(c, a);\n            }\n          }),\n              w = d.enc = {},\n              v = w.Hex = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var e = [], j = 0; j < a; j++) {\n                var k = c[j >>> 2] >>> 24 - 8 * (j % 4) & 255;\n                e.push((k >>> 4).toString(16));\n                e.push((k & 15).toString(16));\n              }\n\n              return e.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, e = [], j = 0; j < c; j += 2) e[j >>> 3] |= parseInt(a.substr(j, 2), 16) << 24 - 4 * (j % 8);\n\n              return new r.init(e, c / 2);\n            }\n          },\n              b = w.Latin1 = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var e = [], j = 0; j < a; j++) e.push(String.fromCharCode(c[j >>> 2] >>> 24 - 8 * (j % 4) & 255));\n\n              return e.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, e = [], j = 0; j < c; j++) e[j >>> 2] |= (a.charCodeAt(j) & 255) << 24 - 8 * (j % 4);\n\n              return new r.init(e, c);\n            }\n          },\n              x = w.Utf8 = {\n            stringify: function (a) {\n              try {\n                return decodeURIComponent(escape(b.stringify(a)));\n              } catch (c) {\n                throw Error(\"Malformed UTF-8 data\");\n              }\n            },\n            parse: function (a) {\n              return b.parse(unescape(encodeURIComponent(a)));\n            }\n          },\n              q = l.BufferedBlockAlgorithm = t.extend({\n            reset: function () {\n              this._data = new r.init();\n              this._nDataBytes = 0;\n            },\n            _append: function (a) {\n              \"string\" == typeof a && (a = x.parse(a));\n\n              this._data.concat(a);\n\n              this._nDataBytes += a.sigBytes;\n            },\n            _process: function (a) {\n              var c = this._data,\n                  e = c.words,\n                  j = c.sigBytes,\n                  k = this.blockSize,\n                  b = j / (4 * k),\n                  b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0);\n              a = b * k;\n              j = u.min(4 * a, j);\n\n              if (a) {\n                for (var q = 0; q < a; q += k) this._doProcessBlock(e, q);\n\n                q = e.splice(0, a);\n                c.sigBytes -= j;\n              }\n\n              return new r.init(q, j);\n            },\n            clone: function () {\n              var a = t.clone.call(this);\n              a._data = this._data.clone();\n              return a;\n            },\n            _minBufferSize: 0\n          });\n\n          l.Hasher = q.extend({\n            cfg: t.extend(),\n            init: function (a) {\n              this.cfg = this.cfg.extend(a);\n              this.reset();\n            },\n            reset: function () {\n              q.reset.call(this);\n\n              this._doReset();\n            },\n            update: function (a) {\n              this._append(a);\n\n              this._process();\n\n              return this;\n            },\n            finalize: function (a) {\n              a && this._append(a);\n              return this._doFinalize();\n            },\n            blockSize: 16,\n            _createHelper: function (a) {\n              return function (b, e) {\n                return new a.init(e).finalize(b);\n              };\n            },\n            _createHmacHelper: function (a) {\n              return function (b, e) {\n                return new n.HMAC.init(a, e).finalize(b);\n              };\n            }\n          });\n          var n = d.algo = {};\n          return d;\n        }(Math);\n\n        (function () {\n          var u = CryptoJS,\n              p = u.lib.WordArray;\n          u.enc.Base64 = {\n            stringify: function (d) {\n              var l = d.words,\n                  p = d.sigBytes,\n                  t = this._map;\n              d.clamp();\n              d = [];\n\n              for (var r = 0; r < p; r += 3) for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && r + 0.75 * v < p; v++) d.push(t.charAt(w >>> 6 * (3 - v) & 63));\n\n              if (l = t.charAt(64)) for (; d.length % 4;) d.push(l);\n              return d.join(\"\");\n            },\n            parse: function (d) {\n              var l = d.length,\n                  s = this._map,\n                  t = s.charAt(64);\n              t && (t = d.indexOf(t), -1 != t && (l = t));\n\n              for (var t = [], r = 0, w = 0; w < l; w++) if (w % 4) {\n                var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4),\n                    b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4);\n                t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4);\n                r++;\n              }\n\n              return p.create(t, r);\n            },\n            _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n          };\n        })();\n\n        (function (u) {\n          function p(b, n, a, c, e, j, k) {\n            b = b + (n & a | ~n & c) + e + k;\n            return (b << j | b >>> 32 - j) + n;\n          }\n\n          function d(b, n, a, c, e, j, k) {\n            b = b + (n & c | a & ~c) + e + k;\n            return (b << j | b >>> 32 - j) + n;\n          }\n\n          function l(b, n, a, c, e, j, k) {\n            b = b + (n ^ a ^ c) + e + k;\n            return (b << j | b >>> 32 - j) + n;\n          }\n\n          function s(b, n, a, c, e, j, k) {\n            b = b + (a ^ (n | ~c)) + e + k;\n            return (b << j | b >>> 32 - j) + n;\n          }\n\n          for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++) b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;\n\n          r = r.MD5 = v.extend({\n            _doReset: function () {\n              this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878]);\n            },\n            _doProcessBlock: function (q, n) {\n              for (var a = 0; 16 > a; a++) {\n                var c = n + a,\n                    e = q[c];\n                q[c] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;\n              }\n\n              var a = this._hash.words,\n                  c = q[n + 0],\n                  e = q[n + 1],\n                  j = q[n + 2],\n                  k = q[n + 3],\n                  z = q[n + 4],\n                  r = q[n + 5],\n                  t = q[n + 6],\n                  w = q[n + 7],\n                  v = q[n + 8],\n                  A = q[n + 9],\n                  B = q[n + 10],\n                  C = q[n + 11],\n                  u = q[n + 12],\n                  D = q[n + 13],\n                  E = q[n + 14],\n                  x = q[n + 15],\n                  f = a[0],\n                  m = a[1],\n                  g = a[2],\n                  h = a[3],\n                  f = p(f, m, g, h, c, 7, b[0]),\n                  h = p(h, f, m, g, e, 12, b[1]),\n                  g = p(g, h, f, m, j, 17, b[2]),\n                  m = p(m, g, h, f, k, 22, b[3]),\n                  f = p(f, m, g, h, z, 7, b[4]),\n                  h = p(h, f, m, g, r, 12, b[5]),\n                  g = p(g, h, f, m, t, 17, b[6]),\n                  m = p(m, g, h, f, w, 22, b[7]),\n                  f = p(f, m, g, h, v, 7, b[8]),\n                  h = p(h, f, m, g, A, 12, b[9]),\n                  g = p(g, h, f, m, B, 17, b[10]),\n                  m = p(m, g, h, f, C, 22, b[11]),\n                  f = p(f, m, g, h, u, 7, b[12]),\n                  h = p(h, f, m, g, D, 12, b[13]),\n                  g = p(g, h, f, m, E, 17, b[14]),\n                  m = p(m, g, h, f, x, 22, b[15]),\n                  f = d(f, m, g, h, e, 5, b[16]),\n                  h = d(h, f, m, g, t, 9, b[17]),\n                  g = d(g, h, f, m, C, 14, b[18]),\n                  m = d(m, g, h, f, c, 20, b[19]),\n                  f = d(f, m, g, h, r, 5, b[20]),\n                  h = d(h, f, m, g, B, 9, b[21]),\n                  g = d(g, h, f, m, x, 14, b[22]),\n                  m = d(m, g, h, f, z, 20, b[23]),\n                  f = d(f, m, g, h, A, 5, b[24]),\n                  h = d(h, f, m, g, E, 9, b[25]),\n                  g = d(g, h, f, m, k, 14, b[26]),\n                  m = d(m, g, h, f, v, 20, b[27]),\n                  f = d(f, m, g, h, D, 5, b[28]),\n                  h = d(h, f, m, g, j, 9, b[29]),\n                  g = d(g, h, f, m, w, 14, b[30]),\n                  m = d(m, g, h, f, u, 20, b[31]),\n                  f = l(f, m, g, h, r, 4, b[32]),\n                  h = l(h, f, m, g, v, 11, b[33]),\n                  g = l(g, h, f, m, C, 16, b[34]),\n                  m = l(m, g, h, f, E, 23, b[35]),\n                  f = l(f, m, g, h, e, 4, b[36]),\n                  h = l(h, f, m, g, z, 11, b[37]),\n                  g = l(g, h, f, m, w, 16, b[38]),\n                  m = l(m, g, h, f, B, 23, b[39]),\n                  f = l(f, m, g, h, D, 4, b[40]),\n                  h = l(h, f, m, g, c, 11, b[41]),\n                  g = l(g, h, f, m, k, 16, b[42]),\n                  m = l(m, g, h, f, t, 23, b[43]),\n                  f = l(f, m, g, h, A, 4, b[44]),\n                  h = l(h, f, m, g, u, 11, b[45]),\n                  g = l(g, h, f, m, x, 16, b[46]),\n                  m = l(m, g, h, f, j, 23, b[47]),\n                  f = s(f, m, g, h, c, 6, b[48]),\n                  h = s(h, f, m, g, w, 10, b[49]),\n                  g = s(g, h, f, m, E, 15, b[50]),\n                  m = s(m, g, h, f, r, 21, b[51]),\n                  f = s(f, m, g, h, u, 6, b[52]),\n                  h = s(h, f, m, g, k, 10, b[53]),\n                  g = s(g, h, f, m, B, 15, b[54]),\n                  m = s(m, g, h, f, e, 21, b[55]),\n                  f = s(f, m, g, h, v, 6, b[56]),\n                  h = s(h, f, m, g, x, 10, b[57]),\n                  g = s(g, h, f, m, t, 15, b[58]),\n                  m = s(m, g, h, f, D, 21, b[59]),\n                  f = s(f, m, g, h, z, 6, b[60]),\n                  h = s(h, f, m, g, C, 10, b[61]),\n                  g = s(g, h, f, m, j, 15, b[62]),\n                  m = s(m, g, h, f, A, 21, b[63]);\n              a[0] = a[0] + f | 0;\n              a[1] = a[1] + m | 0;\n              a[2] = a[2] + g | 0;\n              a[3] = a[3] + h | 0;\n            },\n            _doFinalize: function () {\n              var b = this._data,\n                  n = b.words,\n                  a = 8 * this._nDataBytes,\n                  c = 8 * b.sigBytes;\n              n[c >>> 5] |= 128 << 24 - c % 32;\n              var e = u.floor(a / 4294967296);\n              n[(c + 64 >>> 9 << 4) + 15] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;\n              n[(c + 64 >>> 9 << 4) + 14] = (a << 8 | a >>> 24) & 16711935 | (a << 24 | a >>> 8) & 4278255360;\n              b.sigBytes = 4 * (n.length + 1);\n\n              this._process();\n\n              b = this._hash;\n              n = b.words;\n\n              for (a = 0; 4 > a; a++) c = n[a], n[a] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;\n\n              return b;\n            },\n            clone: function () {\n              var b = v.clone.call(this);\n              b._hash = this._hash.clone();\n              return b;\n            }\n          });\n          t.MD5 = v._createHelper(r);\n          t.HmacMD5 = v._createHmacHelper(r);\n        })(Math);\n\n        (function () {\n          var u = CryptoJS,\n              p = u.lib,\n              d = p.Base,\n              l = p.WordArray,\n              p = u.algo,\n              s = p.EvpKDF = d.extend({\n            cfg: d.extend({\n              keySize: 4,\n              hasher: p.MD5,\n              iterations: 1\n            }),\n            init: function (d) {\n              this.cfg = this.cfg.extend(d);\n            },\n            compute: function (d, r) {\n              for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q;) {\n                n && s.update(n);\n                var n = s.update(d).finalize(r);\n                s.reset();\n\n                for (var a = 1; a < p; a++) n = s.finalize(n), s.reset();\n\n                b.concat(n);\n              }\n\n              b.sigBytes = 4 * q;\n              return b;\n            }\n          });\n\n          u.EvpKDF = function (d, l, p) {\n            return s.create(p).compute(d, l);\n          };\n        })();\n\n        CryptoJS.lib.Cipher || function (u) {\n          var p = CryptoJS,\n              d = p.lib,\n              l = d.Base,\n              s = d.WordArray,\n              t = d.BufferedBlockAlgorithm,\n              r = p.enc.Base64,\n              w = p.algo.EvpKDF,\n              v = d.Cipher = t.extend({\n            cfg: l.extend(),\n            createEncryptor: function (e, a) {\n              return this.create(this._ENC_XFORM_MODE, e, a);\n            },\n            createDecryptor: function (e, a) {\n              return this.create(this._DEC_XFORM_MODE, e, a);\n            },\n            init: function (e, a, b) {\n              this.cfg = this.cfg.extend(b);\n              this._xformMode = e;\n              this._key = a;\n              this.reset();\n            },\n            reset: function () {\n              t.reset.call(this);\n\n              this._doReset();\n            },\n            process: function (e) {\n              this._append(e);\n\n              return this._process();\n            },\n            finalize: function (e) {\n              e && this._append(e);\n              return this._doFinalize();\n            },\n            keySize: 4,\n            ivSize: 4,\n            _ENC_XFORM_MODE: 1,\n            _DEC_XFORM_MODE: 2,\n            _createHelper: function (e) {\n              return {\n                encrypt: function (b, k, d) {\n                  return (\"string\" == typeof k ? c : a).encrypt(e, b, k, d);\n                },\n                decrypt: function (b, k, d) {\n                  return (\"string\" == typeof k ? c : a).decrypt(e, b, k, d);\n                }\n              };\n            }\n          });\n          d.StreamCipher = v.extend({\n            _doFinalize: function () {\n              return this._process(!0);\n            },\n            blockSize: 1\n          });\n\n          var b = p.mode = {},\n              x = function (e, a, b) {\n            var c = this._iv;\n            c ? this._iv = u : c = this._prevBlock;\n\n            for (var d = 0; d < b; d++) e[a + d] ^= c[d];\n          },\n              q = (d.BlockCipherMode = l.extend({\n            createEncryptor: function (e, a) {\n              return this.Encryptor.create(e, a);\n            },\n            createDecryptor: function (e, a) {\n              return this.Decryptor.create(e, a);\n            },\n            init: function (e, a) {\n              this._cipher = e;\n              this._iv = a;\n            }\n          })).extend();\n\n          q.Encryptor = q.extend({\n            processBlock: function (e, a) {\n              var b = this._cipher,\n                  c = b.blockSize;\n              x.call(this, e, a, c);\n              b.encryptBlock(e, a);\n              this._prevBlock = e.slice(a, a + c);\n            }\n          });\n          q.Decryptor = q.extend({\n            processBlock: function (e, a) {\n              var b = this._cipher,\n                  c = b.blockSize,\n                  d = e.slice(a, a + c);\n              b.decryptBlock(e, a);\n              x.call(this, e, a, c);\n              this._prevBlock = d;\n            }\n          });\n          b = b.CBC = q;\n          q = (p.pad = {}).Pkcs7 = {\n            pad: function (a, b) {\n              for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; n < c; n += 4) l.push(d);\n\n              c = s.create(l, c);\n              a.concat(c);\n            },\n            unpad: function (a) {\n              a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255;\n            }\n          };\n          d.BlockCipher = v.extend({\n            cfg: v.cfg.extend({\n              mode: b,\n              padding: q\n            }),\n            reset: function () {\n              v.reset.call(this);\n              var a = this.cfg,\n                  b = a.iv,\n                  a = a.mode;\n              if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;else c = a.createDecryptor, this._minBufferSize = 1;\n              this._mode = c.call(a, this, b && b.words);\n            },\n            _doProcessBlock: function (a, b) {\n              this._mode.processBlock(a, b);\n            },\n            _doFinalize: function () {\n              var a = this.cfg.padding;\n\n              if (this._xformMode == this._ENC_XFORM_MODE) {\n                a.pad(this._data, this.blockSize);\n\n                var b = this._process(!0);\n              } else b = this._process(!0), a.unpad(b);\n\n              return b;\n            },\n            blockSize: 4\n          });\n          var n = d.CipherParams = l.extend({\n            init: function (a) {\n              this.mixIn(a);\n            },\n            toString: function (a) {\n              return (a || this.formatter).stringify(this);\n            }\n          }),\n              b = (p.format = {}).OpenSSL = {\n            stringify: function (a) {\n              var b = a.ciphertext;\n              a = a.salt;\n              return (a ? s.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r);\n            },\n            parse: function (a) {\n              a = r.parse(a);\n              var b = a.words;\n\n              if (1398893684 == b[0] && 1701076831 == b[1]) {\n                var c = s.create(b.slice(2, 4));\n                b.splice(0, 4);\n                a.sigBytes -= 16;\n              }\n\n              return n.create({\n                ciphertext: a,\n                salt: c\n              });\n            }\n          },\n              a = d.SerializableCipher = l.extend({\n            cfg: l.extend({\n              format: b\n            }),\n            encrypt: function (a, b, c, d) {\n              d = this.cfg.extend(d);\n              var l = a.createEncryptor(c, d);\n              b = l.finalize(b);\n              l = l.cfg;\n              return n.create({\n                ciphertext: b,\n                key: c,\n                iv: l.iv,\n                algorithm: a,\n                mode: l.mode,\n                padding: l.padding,\n                blockSize: a.blockSize,\n                formatter: d.format\n              });\n            },\n            decrypt: function (a, b, c, d) {\n              d = this.cfg.extend(d);\n              b = this._parse(b, d.format);\n              return a.createDecryptor(c, d).finalize(b.ciphertext);\n            },\n            _parse: function (a, b) {\n              return \"string\" == typeof a ? b.parse(a, this) : a;\n            }\n          }),\n              p = (p.kdf = {}).OpenSSL = {\n            execute: function (a, b, c, d) {\n              d || (d = s.random(8));\n              a = w.create({\n                keySize: b + c\n              }).compute(a, d);\n              c = s.create(a.words.slice(b), 4 * c);\n              a.sigBytes = 4 * b;\n              return n.create({\n                key: a,\n                iv: c,\n                salt: d\n              });\n            }\n          },\n              c = d.PasswordBasedCipher = a.extend({\n            cfg: a.cfg.extend({\n              kdf: p\n            }),\n            encrypt: function (b, c, d, l) {\n              l = this.cfg.extend(l);\n              d = l.kdf.execute(d, b.keySize, b.ivSize);\n              l.iv = d.iv;\n              b = a.encrypt.call(this, b, c, d.key, l);\n              b.mixIn(d);\n              return b;\n            },\n            decrypt: function (b, c, d, l) {\n              l = this.cfg.extend(l);\n              c = this._parse(c, l.format);\n              d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);\n              l.iv = d.iv;\n              return a.decrypt.call(this, b, c, d.key, l);\n            }\n          });\n        }();\n\n        (function () {\n          for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++) a[c] = 128 > c ? c << 1 : c << 1 ^ 283;\n\n          for (var e = 0, j = 0, c = 0; 256 > c; c++) {\n            var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4,\n                k = k >>> 8 ^ k & 255 ^ 99;\n            l[e] = k;\n            s[k] = e;\n            var z = a[e],\n                F = a[z],\n                G = a[F],\n                y = 257 * a[k] ^ 16843008 * k;\n            t[e] = y << 24 | y >>> 8;\n            r[e] = y << 16 | y >>> 16;\n            w[e] = y << 8 | y >>> 24;\n            v[e] = y;\n            y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e;\n            b[k] = y << 24 | y >>> 8;\n            x[k] = y << 16 | y >>> 16;\n            q[k] = y << 8 | y >>> 24;\n            n[k] = y;\n            e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1;\n          }\n\n          var H = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],\n              d = d.AES = p.extend({\n            _doReset: function () {\n              for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j < a; j++) if (j < d) e[j] = c[j];else {\n                var k = e[j - 1];\n                j % d ? 6 < d && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255]) : (k = k << 8 | k >>> 24, k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255], k ^= H[j / d | 0] << 24);\n                e[j] = e[j - d] ^ k;\n              }\n\n              c = this._invKeySchedule = [];\n\n              for (d = 0; d < a; d++) j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>> 8 & 255]] ^ n[l[k & 255]];\n            },\n            encryptBlock: function (a, b) {\n              this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l);\n            },\n            decryptBlock: function (a, c) {\n              var d = a[c + 1];\n              a[c + 1] = a[c + 3];\n              a[c + 3] = d;\n\n              this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);\n\n              d = a[c + 1];\n              a[c + 1] = a[c + 3];\n              a[c + 3] = d;\n            },\n            _doCryptBlock: function (a, b, c, d, e, j, l, f) {\n              for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r < m; r++) var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[n & 255] ^ c[p++], s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[g & 255] ^ c[p++], t = d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[h & 255] ^ c[p++], n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[k & 255] ^ c[p++], g = q, h = s, k = t;\n\n              q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[n & 255]) ^ c[p++];\n              s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[g & 255]) ^ c[p++];\n              t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[h & 255]) ^ c[p++];\n              n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[k & 255]) ^ c[p++];\n              a[b] = q;\n              a[b + 1] = s;\n              a[b + 2] = t;\n              a[b + 3] = n;\n            },\n            keySize: 8\n          });\n          u.AES = p._createHelper(d);\n        })();\n\n        ;\n        /*\n        CryptoJS v3.1.2\n        code.google.com/p/crypto-js\n        (c) 2009-2013 by Jeff Mott. All rights reserved.\n        code.google.com/p/crypto-js/wiki/License\n        */\n\n        var CryptoJS = CryptoJS || function (h, s) {\n          var f = {},\n              g = f.lib = {},\n              q = function () {},\n              m = g.Base = {\n            extend: function (a) {\n              q.prototype = this;\n              var c = new q();\n              a && c.mixIn(a);\n              c.hasOwnProperty(\"init\") || (c.init = function () {\n                c.$super.init.apply(this, arguments);\n              });\n              c.init.prototype = c;\n              c.$super = this;\n              return c;\n            },\n            create: function () {\n              var a = this.extend();\n              a.init.apply(a, arguments);\n              return a;\n            },\n            init: function () {},\n            mixIn: function (a) {\n              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);\n\n              a.hasOwnProperty(\"toString\") && (this.toString = a.toString);\n            },\n            clone: function () {\n              return this.init.prototype.extend(this);\n            }\n          },\n              r = g.WordArray = m.extend({\n            init: function (a, c) {\n              a = this.words = a || [];\n              this.sigBytes = c != s ? c : 4 * a.length;\n            },\n            toString: function (a) {\n              return (a || k).stringify(this);\n            },\n            concat: function (a) {\n              var c = this.words,\n                  d = a.words,\n                  b = this.sigBytes;\n              a = a.sigBytes;\n              this.clamp();\n              if (b % 4) for (var e = 0; e < a; e++) c[b + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((b + e) % 4);else if (65535 < d.length) for (e = 0; e < a; e += 4) c[b + e >>> 2] = d[e >>> 2];else c.push.apply(c, d);\n              this.sigBytes += a;\n              return this;\n            },\n            clamp: function () {\n              var a = this.words,\n                  c = this.sigBytes;\n              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);\n              a.length = h.ceil(c / 4);\n            },\n            clone: function () {\n              var a = m.clone.call(this);\n              a.words = this.words.slice(0);\n              return a;\n            },\n            random: function (a) {\n              for (var c = [], d = 0; d < a; d += 4) c.push(4294967296 * h.random() | 0);\n\n              return new r.init(c, a);\n            }\n          }),\n              l = f.enc = {},\n              k = l.Hex = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var d = [], b = 0; b < a; b++) {\n                var e = c[b >>> 2] >>> 24 - 8 * (b % 4) & 255;\n                d.push((e >>> 4).toString(16));\n                d.push((e & 15).toString(16));\n              }\n\n              return d.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, d = [], b = 0; b < c; b += 2) d[b >>> 3] |= parseInt(a.substr(b, 2), 16) << 24 - 4 * (b % 8);\n\n              return new r.init(d, c / 2);\n            }\n          },\n              n = l.Latin1 = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var d = [], b = 0; b < a; b++) d.push(String.fromCharCode(c[b >>> 2] >>> 24 - 8 * (b % 4) & 255));\n\n              return d.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, d = [], b = 0; b < c; b++) d[b >>> 2] |= (a.charCodeAt(b) & 255) << 24 - 8 * (b % 4);\n\n              return new r.init(d, c);\n            }\n          },\n              j = l.Utf8 = {\n            stringify: function (a) {\n              try {\n                return decodeURIComponent(escape(n.stringify(a)));\n              } catch (c) {\n                throw Error(\"Malformed UTF-8 data\");\n              }\n            },\n            parse: function (a) {\n              return n.parse(unescape(encodeURIComponent(a)));\n            }\n          },\n              u = g.BufferedBlockAlgorithm = m.extend({\n            reset: function () {\n              this._data = new r.init();\n              this._nDataBytes = 0;\n            },\n            _append: function (a) {\n              \"string\" == typeof a && (a = j.parse(a));\n\n              this._data.concat(a);\n\n              this._nDataBytes += a.sigBytes;\n            },\n            _process: function (a) {\n              var c = this._data,\n                  d = c.words,\n                  b = c.sigBytes,\n                  e = this.blockSize,\n                  f = b / (4 * e),\n                  f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0);\n              a = f * e;\n              b = h.min(4 * a, b);\n\n              if (a) {\n                for (var g = 0; g < a; g += e) this._doProcessBlock(d, g);\n\n                g = d.splice(0, a);\n                c.sigBytes -= b;\n              }\n\n              return new r.init(g, b);\n            },\n            clone: function () {\n              var a = m.clone.call(this);\n              a._data = this._data.clone();\n              return a;\n            },\n            _minBufferSize: 0\n          });\n\n          g.Hasher = u.extend({\n            cfg: m.extend(),\n            init: function (a) {\n              this.cfg = this.cfg.extend(a);\n              this.reset();\n            },\n            reset: function () {\n              u.reset.call(this);\n\n              this._doReset();\n            },\n            update: function (a) {\n              this._append(a);\n\n              this._process();\n\n              return this;\n            },\n            finalize: function (a) {\n              a && this._append(a);\n              return this._doFinalize();\n            },\n            blockSize: 16,\n            _createHelper: function (a) {\n              return function (c, d) {\n                return new a.init(d).finalize(c);\n              };\n            },\n            _createHmacHelper: function (a) {\n              return function (c, d) {\n                return new t.HMAC.init(a, d).finalize(c);\n              };\n            }\n          });\n          var t = f.algo = {};\n          return f;\n        }(Math);\n\n        (function (h) {\n          for (var s = CryptoJS, f = s.lib, g = f.WordArray, q = f.Hasher, f = s.algo, m = [], r = [], l = function (a) {\n            return 4294967296 * (a - (a | 0)) | 0;\n          }, k = 2, n = 0; 64 > n;) {\n            var j;\n\n            a: {\n              j = k;\n\n              for (var u = h.sqrt(j), t = 2; t <= u; t++) if (!(j % t)) {\n                j = !1;\n                break a;\n              }\n\n              j = !0;\n            }\n\n            j && (8 > n && (m[n] = l(h.pow(k, 0.5))), r[n] = l(h.pow(k, 1 / 3)), n++);\n            k++;\n          }\n\n          var a = [],\n              f = f.SHA256 = q.extend({\n            _doReset: function () {\n              this._hash = new g.init(m.slice(0));\n            },\n            _doProcessBlock: function (c, d) {\n              for (var b = this._hash.words, e = b[0], f = b[1], g = b[2], j = b[3], h = b[4], m = b[5], n = b[6], q = b[7], p = 0; 64 > p; p++) {\n                if (16 > p) a[p] = c[d + p] | 0;else {\n                  var k = a[p - 15],\n                      l = a[p - 2];\n                  a[p] = ((k << 25 | k >>> 7) ^ (k << 14 | k >>> 18) ^ k >>> 3) + a[p - 7] + ((l << 15 | l >>> 17) ^ (l << 13 | l >>> 19) ^ l >>> 10) + a[p - 16];\n                }\n                k = q + ((h << 26 | h >>> 6) ^ (h << 21 | h >>> 11) ^ (h << 7 | h >>> 25)) + (h & m ^ ~h & n) + r[p] + a[p];\n                l = ((e << 30 | e >>> 2) ^ (e << 19 | e >>> 13) ^ (e << 10 | e >>> 22)) + (e & f ^ e & g ^ f & g);\n                q = n;\n                n = m;\n                m = h;\n                h = j + k | 0;\n                j = g;\n                g = f;\n                f = e;\n                e = k + l | 0;\n              }\n\n              b[0] = b[0] + e | 0;\n              b[1] = b[1] + f | 0;\n              b[2] = b[2] + g | 0;\n              b[3] = b[3] + j | 0;\n              b[4] = b[4] + h | 0;\n              b[5] = b[5] + m | 0;\n              b[6] = b[6] + n | 0;\n              b[7] = b[7] + q | 0;\n            },\n            _doFinalize: function () {\n              var a = this._data,\n                  d = a.words,\n                  b = 8 * this._nDataBytes,\n                  e = 8 * a.sigBytes;\n              d[e >>> 5] |= 128 << 24 - e % 32;\n              d[(e + 64 >>> 9 << 4) + 14] = h.floor(b / 4294967296);\n              d[(e + 64 >>> 9 << 4) + 15] = b;\n              a.sigBytes = 4 * d.length;\n\n              this._process();\n\n              return this._hash;\n            },\n            clone: function () {\n              var a = q.clone.call(this);\n              a._hash = this._hash.clone();\n              return a;\n            }\n          });\n          s.SHA256 = q._createHelper(f);\n          s.HmacSHA256 = q._createHmacHelper(f);\n        })(Math);\n\n        (function () {\n          var h = CryptoJS,\n              s = h.enc.Utf8;\n          h.algo.HMAC = h.lib.Base.extend({\n            init: function (f, g) {\n              f = this._hasher = new f.init();\n              \"string\" == typeof g && (g = s.parse(g));\n              var h = f.blockSize,\n                  m = 4 * h;\n              g.sigBytes > m && (g = f.finalize(g));\n              g.clamp();\n\n              for (var r = this._oKey = g.clone(), l = this._iKey = g.clone(), k = r.words, n = l.words, j = 0; j < h; j++) k[j] ^= 1549556828, n[j] ^= 909522486;\n\n              r.sigBytes = l.sigBytes = m;\n              this.reset();\n            },\n            reset: function () {\n              var f = this._hasher;\n              f.reset();\n              f.update(this._iKey);\n            },\n            update: function (f) {\n              this._hasher.update(f);\n\n              return this;\n            },\n            finalize: function (f) {\n              var g = this._hasher;\n              f = g.finalize(f);\n              g.reset();\n              return g.finalize(this._oKey.clone().concat(f));\n            }\n          });\n        })();\n\n        ;\n        /*\n        CryptoJS v3.1.2\n        code.google.com/p/crypto-js\n        (c) 2009-2013 by Jeff Mott. All rights reserved.\n        code.google.com/p/crypto-js/wiki/License\n        */\n\n        var CryptoJS = CryptoJS || function (a, j) {\n          var c = {},\n              b = c.lib = {},\n              f = function () {},\n              l = b.Base = {\n            extend: function (a) {\n              f.prototype = this;\n              var d = new f();\n              a && d.mixIn(a);\n              d.hasOwnProperty(\"init\") || (d.init = function () {\n                d.$super.init.apply(this, arguments);\n              });\n              d.init.prototype = d;\n              d.$super = this;\n              return d;\n            },\n            create: function () {\n              var a = this.extend();\n              a.init.apply(a, arguments);\n              return a;\n            },\n            init: function () {},\n            mixIn: function (a) {\n              for (var d in a) a.hasOwnProperty(d) && (this[d] = a[d]);\n\n              a.hasOwnProperty(\"toString\") && (this.toString = a.toString);\n            },\n            clone: function () {\n              return this.init.prototype.extend(this);\n            }\n          },\n              u = b.WordArray = l.extend({\n            init: function (a, d) {\n              a = this.words = a || [];\n              this.sigBytes = d != j ? d : 4 * a.length;\n            },\n            toString: function (a) {\n              return (a || m).stringify(this);\n            },\n            concat: function (a) {\n              var d = this.words,\n                  M = a.words,\n                  e = this.sigBytes;\n              a = a.sigBytes;\n              this.clamp();\n              if (e % 4) for (var b = 0; b < a; b++) d[e + b >>> 2] |= (M[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((e + b) % 4);else if (65535 < M.length) for (b = 0; b < a; b += 4) d[e + b >>> 2] = M[b >>> 2];else d.push.apply(d, M);\n              this.sigBytes += a;\n              return this;\n            },\n            clamp: function () {\n              var D = this.words,\n                  d = this.sigBytes;\n              D[d >>> 2] &= 4294967295 << 32 - 8 * (d % 4);\n              D.length = a.ceil(d / 4);\n            },\n            clone: function () {\n              var a = l.clone.call(this);\n              a.words = this.words.slice(0);\n              return a;\n            },\n            random: function (D) {\n              for (var d = [], b = 0; b < D; b += 4) d.push(4294967296 * a.random() | 0);\n\n              return new u.init(d, D);\n            }\n          }),\n              k = c.enc = {},\n              m = k.Hex = {\n            stringify: function (a) {\n              var d = a.words;\n              a = a.sigBytes;\n\n              for (var b = [], e = 0; e < a; e++) {\n                var c = d[e >>> 2] >>> 24 - 8 * (e % 4) & 255;\n                b.push((c >>> 4).toString(16));\n                b.push((c & 15).toString(16));\n              }\n\n              return b.join(\"\");\n            },\n            parse: function (a) {\n              for (var d = a.length, b = [], e = 0; e < d; e += 2) b[e >>> 3] |= parseInt(a.substr(e, 2), 16) << 24 - 4 * (e % 8);\n\n              return new u.init(b, d / 2);\n            }\n          },\n              y = k.Latin1 = {\n            stringify: function (a) {\n              var b = a.words;\n              a = a.sigBytes;\n\n              for (var c = [], e = 0; e < a; e++) c.push(String.fromCharCode(b[e >>> 2] >>> 24 - 8 * (e % 4) & 255));\n\n              return c.join(\"\");\n            },\n            parse: function (a) {\n              for (var b = a.length, c = [], e = 0; e < b; e++) c[e >>> 2] |= (a.charCodeAt(e) & 255) << 24 - 8 * (e % 4);\n\n              return new u.init(c, b);\n            }\n          },\n              z = k.Utf8 = {\n            stringify: function (a) {\n              try {\n                return decodeURIComponent(escape(y.stringify(a)));\n              } catch (b) {\n                throw Error(\"Malformed UTF-8 data\");\n              }\n            },\n            parse: function (a) {\n              return y.parse(unescape(encodeURIComponent(a)));\n            }\n          },\n              x = b.BufferedBlockAlgorithm = l.extend({\n            reset: function () {\n              this._data = new u.init();\n              this._nDataBytes = 0;\n            },\n            _append: function (a) {\n              \"string\" == typeof a && (a = z.parse(a));\n\n              this._data.concat(a);\n\n              this._nDataBytes += a.sigBytes;\n            },\n            _process: function (b) {\n              var d = this._data,\n                  c = d.words,\n                  e = d.sigBytes,\n                  l = this.blockSize,\n                  k = e / (4 * l),\n                  k = b ? a.ceil(k) : a.max((k | 0) - this._minBufferSize, 0);\n              b = k * l;\n              e = a.min(4 * b, e);\n\n              if (b) {\n                for (var x = 0; x < b; x += l) this._doProcessBlock(c, x);\n\n                x = c.splice(0, b);\n                d.sigBytes -= e;\n              }\n\n              return new u.init(x, e);\n            },\n            clone: function () {\n              var a = l.clone.call(this);\n              a._data = this._data.clone();\n              return a;\n            },\n            _minBufferSize: 0\n          });\n\n          b.Hasher = x.extend({\n            cfg: l.extend(),\n            init: function (a) {\n              this.cfg = this.cfg.extend(a);\n              this.reset();\n            },\n            reset: function () {\n              x.reset.call(this);\n\n              this._doReset();\n            },\n            update: function (a) {\n              this._append(a);\n\n              this._process();\n\n              return this;\n            },\n            finalize: function (a) {\n              a && this._append(a);\n              return this._doFinalize();\n            },\n            blockSize: 16,\n            _createHelper: function (a) {\n              return function (b, c) {\n                return new a.init(c).finalize(b);\n              };\n            },\n            _createHmacHelper: function (a) {\n              return function (b, c) {\n                return new ja.HMAC.init(a, c).finalize(b);\n              };\n            }\n          });\n          var ja = c.algo = {};\n          return c;\n        }(Math);\n\n        (function (a) {\n          var j = CryptoJS,\n              c = j.lib,\n              b = c.Base,\n              f = c.WordArray,\n              j = j.x64 = {};\n          j.Word = b.extend({\n            init: function (a, b) {\n              this.high = a;\n              this.low = b;\n            }\n          });\n          j.WordArray = b.extend({\n            init: function (b, c) {\n              b = this.words = b || [];\n              this.sigBytes = c != a ? c : 8 * b.length;\n            },\n            toX32: function () {\n              for (var a = this.words, b = a.length, c = [], m = 0; m < b; m++) {\n                var y = a[m];\n                c.push(y.high);\n                c.push(y.low);\n              }\n\n              return f.create(c, this.sigBytes);\n            },\n            clone: function () {\n              for (var a = b.clone.call(this), c = a.words = this.words.slice(0), k = c.length, f = 0; f < k; f++) c[f] = c[f].clone();\n\n              return a;\n            }\n          });\n        })();\n\n        (function () {\n          function a() {\n            return f.create.apply(f, arguments);\n          }\n\n          for (var j = CryptoJS, c = j.lib.Hasher, b = j.x64, f = b.Word, l = b.WordArray, b = j.algo, u = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317), a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291, 2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899), a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470, 3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)], k = [], m = 0; 80 > m; m++) k[m] = a();\n\n          b = b.SHA512 = c.extend({\n            _doReset: function () {\n              this._hash = new l.init([new f.init(1779033703, 4089235720), new f.init(3144134277, 2227873595), new f.init(1013904242, 4271175723), new f.init(2773480762, 1595750129), new f.init(1359893119, 2917565137), new f.init(2600822924, 725511199), new f.init(528734635, 4215389547), new f.init(1541459225, 327033209)]);\n            },\n            _doProcessBlock: function (a, b) {\n              for (var c = this._hash.words, f = c[0], j = c[1], d = c[2], l = c[3], e = c[4], m = c[5], N = c[6], c = c[7], aa = f.high, O = f.low, ba = j.high, P = j.low, ca = d.high, Q = d.low, da = l.high, R = l.low, ea = e.high, S = e.low, fa = m.high, T = m.low, ga = N.high, U = N.low, ha = c.high, V = c.low, r = aa, n = O, G = ba, E = P, H = ca, F = Q, Y = da, I = R, s = ea, p = S, W = fa, J = T, X = ga, K = U, Z = ha, L = V, t = 0; 80 > t; t++) {\n                var A = k[t];\n                if (16 > t) var q = A.high = a[b + 2 * t] | 0,\n                    g = A.low = a[b + 2 * t + 1] | 0;else {\n                  var q = k[t - 15],\n                      g = q.high,\n                      v = q.low,\n                      q = (g >>> 1 | v << 31) ^ (g >>> 8 | v << 24) ^ g >>> 7,\n                      v = (v >>> 1 | g << 31) ^ (v >>> 8 | g << 24) ^ (v >>> 7 | g << 25),\n                      C = k[t - 2],\n                      g = C.high,\n                      h = C.low,\n                      C = (g >>> 19 | h << 13) ^ (g << 3 | h >>> 29) ^ g >>> 6,\n                      h = (h >>> 19 | g << 13) ^ (h << 3 | g >>> 29) ^ (h >>> 6 | g << 26),\n                      g = k[t - 7],\n                      $ = g.high,\n                      B = k[t - 16],\n                      w = B.high,\n                      B = B.low,\n                      g = v + g.low,\n                      q = q + $ + (g >>> 0 < v >>> 0 ? 1 : 0),\n                      g = g + h,\n                      q = q + C + (g >>> 0 < h >>> 0 ? 1 : 0),\n                      g = g + B,\n                      q = q + w + (g >>> 0 < B >>> 0 ? 1 : 0);\n                  A.high = q;\n                  A.low = g;\n                }\n                var $ = s & W ^ ~s & X,\n                    B = p & J ^ ~p & K,\n                    A = r & G ^ r & H ^ G & H,\n                    ka = n & E ^ n & F ^ E & F,\n                    v = (r >>> 28 | n << 4) ^ (r << 30 | n >>> 2) ^ (r << 25 | n >>> 7),\n                    C = (n >>> 28 | r << 4) ^ (n << 30 | r >>> 2) ^ (n << 25 | r >>> 7),\n                    h = u[t],\n                    la = h.high,\n                    ia = h.low,\n                    h = L + ((p >>> 14 | s << 18) ^ (p >>> 18 | s << 14) ^ (p << 23 | s >>> 9)),\n                    w = Z + ((s >>> 14 | p << 18) ^ (s >>> 18 | p << 14) ^ (s << 23 | p >>> 9)) + (h >>> 0 < L >>> 0 ? 1 : 0),\n                    h = h + B,\n                    w = w + $ + (h >>> 0 < B >>> 0 ? 1 : 0),\n                    h = h + ia,\n                    w = w + la + (h >>> 0 < ia >>> 0 ? 1 : 0),\n                    h = h + g,\n                    w = w + q + (h >>> 0 < g >>> 0 ? 1 : 0),\n                    g = C + ka,\n                    A = v + A + (g >>> 0 < C >>> 0 ? 1 : 0),\n                    Z = X,\n                    L = K,\n                    X = W,\n                    K = J,\n                    W = s,\n                    J = p,\n                    p = I + h | 0,\n                    s = Y + w + (p >>> 0 < I >>> 0 ? 1 : 0) | 0,\n                    Y = H,\n                    I = F,\n                    H = G,\n                    F = E,\n                    G = r,\n                    E = n,\n                    n = h + g | 0,\n                    r = w + A + (n >>> 0 < h >>> 0 ? 1 : 0) | 0;\n              }\n\n              O = f.low = O + n;\n              f.high = aa + r + (O >>> 0 < n >>> 0 ? 1 : 0);\n              P = j.low = P + E;\n              j.high = ba + G + (P >>> 0 < E >>> 0 ? 1 : 0);\n              Q = d.low = Q + F;\n              d.high = ca + H + (Q >>> 0 < F >>> 0 ? 1 : 0);\n              R = l.low = R + I;\n              l.high = da + Y + (R >>> 0 < I >>> 0 ? 1 : 0);\n              S = e.low = S + p;\n              e.high = ea + s + (S >>> 0 < p >>> 0 ? 1 : 0);\n              T = m.low = T + J;\n              m.high = fa + W + (T >>> 0 < J >>> 0 ? 1 : 0);\n              U = N.low = U + K;\n              N.high = ga + X + (U >>> 0 < K >>> 0 ? 1 : 0);\n              V = c.low = V + L;\n              c.high = ha + Z + (V >>> 0 < L >>> 0 ? 1 : 0);\n            },\n            _doFinalize: function () {\n              var a = this._data,\n                  b = a.words,\n                  c = 8 * this._nDataBytes,\n                  f = 8 * a.sigBytes;\n              b[f >>> 5] |= 128 << 24 - f % 32;\n              b[(f + 128 >>> 10 << 5) + 30] = Math.floor(c / 4294967296);\n              b[(f + 128 >>> 10 << 5) + 31] = c;\n              a.sigBytes = 4 * b.length;\n\n              this._process();\n\n              return this._hash.toX32();\n            },\n            clone: function () {\n              var a = c.clone.call(this);\n              a._hash = this._hash.clone();\n              return a;\n            },\n            blockSize: 32\n          });\n          j.SHA512 = c._createHelper(b);\n          j.HmacSHA512 = c._createHmacHelper(b);\n        })();\n\n        (function () {\n          var a = CryptoJS,\n              j = a.enc.Utf8;\n          a.algo.HMAC = a.lib.Base.extend({\n            init: function (a, b) {\n              a = this._hasher = new a.init();\n              \"string\" == typeof b && (b = j.parse(b));\n              var f = a.blockSize,\n                  l = 4 * f;\n              b.sigBytes > l && (b = a.finalize(b));\n              b.clamp();\n\n              for (var u = this._oKey = b.clone(), k = this._iKey = b.clone(), m = u.words, y = k.words, z = 0; z < f; z++) m[z] ^= 1549556828, y[z] ^= 909522486;\n\n              u.sigBytes = k.sigBytes = l;\n              this.reset();\n            },\n            reset: function () {\n              var a = this._hasher;\n              a.reset();\n              a.update(this._iKey);\n            },\n            update: function (a) {\n              this._hasher.update(a);\n\n              return this;\n            },\n            finalize: function (a) {\n              var b = this._hasher;\n              a = b.finalize(a);\n              b.reset();\n              return b.finalize(this._oKey.clone().concat(a));\n            }\n          });\n        })();\n\n        ;\n        /*\n        CryptoJS v3.1.2\n        code.google.com/p/crypto-js\n        (c) 2009-2013 by Jeff Mott. All rights reserved.\n        code.google.com/p/crypto-js/wiki/License\n        */\n\n        var CryptoJS = CryptoJS || function (g, j) {\n          var e = {},\n              d = e.lib = {},\n              m = function () {},\n              n = d.Base = {\n            extend: function (a) {\n              m.prototype = this;\n              var c = new m();\n              a && c.mixIn(a);\n              c.hasOwnProperty(\"init\") || (c.init = function () {\n                c.$super.init.apply(this, arguments);\n              });\n              c.init.prototype = c;\n              c.$super = this;\n              return c;\n            },\n            create: function () {\n              var a = this.extend();\n              a.init.apply(a, arguments);\n              return a;\n            },\n            init: function () {},\n            mixIn: function (a) {\n              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);\n\n              a.hasOwnProperty(\"toString\") && (this.toString = a.toString);\n            },\n            clone: function () {\n              return this.init.prototype.extend(this);\n            }\n          },\n              q = d.WordArray = n.extend({\n            init: function (a, c) {\n              a = this.words = a || [];\n              this.sigBytes = c != j ? c : 4 * a.length;\n            },\n            toString: function (a) {\n              return (a || l).stringify(this);\n            },\n            concat: function (a) {\n              var c = this.words,\n                  p = a.words,\n                  f = this.sigBytes;\n              a = a.sigBytes;\n              this.clamp();\n              if (f % 4) for (var b = 0; b < a; b++) c[f + b >>> 2] |= (p[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((f + b) % 4);else if (65535 < p.length) for (b = 0; b < a; b += 4) c[f + b >>> 2] = p[b >>> 2];else c.push.apply(c, p);\n              this.sigBytes += a;\n              return this;\n            },\n            clamp: function () {\n              var a = this.words,\n                  c = this.sigBytes;\n              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);\n              a.length = g.ceil(c / 4);\n            },\n            clone: function () {\n              var a = n.clone.call(this);\n              a.words = this.words.slice(0);\n              return a;\n            },\n            random: function (a) {\n              for (var c = [], b = 0; b < a; b += 4) c.push(4294967296 * g.random() | 0);\n\n              return new q.init(c, a);\n            }\n          }),\n              b = e.enc = {},\n              l = b.Hex = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var b = [], f = 0; f < a; f++) {\n                var d = c[f >>> 2] >>> 24 - 8 * (f % 4) & 255;\n                b.push((d >>> 4).toString(16));\n                b.push((d & 15).toString(16));\n              }\n\n              return b.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, b = [], f = 0; f < c; f += 2) b[f >>> 3] |= parseInt(a.substr(f, 2), 16) << 24 - 4 * (f % 8);\n\n              return new q.init(b, c / 2);\n            }\n          },\n              k = b.Latin1 = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var b = [], f = 0; f < a; f++) b.push(String.fromCharCode(c[f >>> 2] >>> 24 - 8 * (f % 4) & 255));\n\n              return b.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, b = [], f = 0; f < c; f++) b[f >>> 2] |= (a.charCodeAt(f) & 255) << 24 - 8 * (f % 4);\n\n              return new q.init(b, c);\n            }\n          },\n              h = b.Utf8 = {\n            stringify: function (a) {\n              try {\n                return decodeURIComponent(escape(k.stringify(a)));\n              } catch (b) {\n                throw Error(\"Malformed UTF-8 data\");\n              }\n            },\n            parse: function (a) {\n              return k.parse(unescape(encodeURIComponent(a)));\n            }\n          },\n              u = d.BufferedBlockAlgorithm = n.extend({\n            reset: function () {\n              this._data = new q.init();\n              this._nDataBytes = 0;\n            },\n            _append: function (a) {\n              \"string\" == typeof a && (a = h.parse(a));\n\n              this._data.concat(a);\n\n              this._nDataBytes += a.sigBytes;\n            },\n            _process: function (a) {\n              var b = this._data,\n                  d = b.words,\n                  f = b.sigBytes,\n                  l = this.blockSize,\n                  e = f / (4 * l),\n                  e = a ? g.ceil(e) : g.max((e | 0) - this._minBufferSize, 0);\n              a = e * l;\n              f = g.min(4 * a, f);\n\n              if (a) {\n                for (var h = 0; h < a; h += l) this._doProcessBlock(d, h);\n\n                h = d.splice(0, a);\n                b.sigBytes -= f;\n              }\n\n              return new q.init(h, f);\n            },\n            clone: function () {\n              var a = n.clone.call(this);\n              a._data = this._data.clone();\n              return a;\n            },\n            _minBufferSize: 0\n          });\n\n          d.Hasher = u.extend({\n            cfg: n.extend(),\n            init: function (a) {\n              this.cfg = this.cfg.extend(a);\n              this.reset();\n            },\n            reset: function () {\n              u.reset.call(this);\n\n              this._doReset();\n            },\n            update: function (a) {\n              this._append(a);\n\n              this._process();\n\n              return this;\n            },\n            finalize: function (a) {\n              a && this._append(a);\n              return this._doFinalize();\n            },\n            blockSize: 16,\n            _createHelper: function (a) {\n              return function (b, d) {\n                return new a.init(d).finalize(b);\n              };\n            },\n            _createHmacHelper: function (a) {\n              return function (b, d) {\n                return new w.HMAC.init(a, d).finalize(b);\n              };\n            }\n          });\n          var w = e.algo = {};\n          return e;\n        }(Math);\n\n        (function () {\n          var g = CryptoJS,\n              j = g.lib,\n              e = j.WordArray,\n              d = j.Hasher,\n              m = [],\n              j = g.algo.SHA1 = d.extend({\n            _doReset: function () {\n              this._hash = new e.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);\n            },\n            _doProcessBlock: function (d, e) {\n              for (var b = this._hash.words, l = b[0], k = b[1], h = b[2], g = b[3], j = b[4], a = 0; 80 > a; a++) {\n                if (16 > a) m[a] = d[e + a] | 0;else {\n                  var c = m[a - 3] ^ m[a - 8] ^ m[a - 14] ^ m[a - 16];\n                  m[a] = c << 1 | c >>> 31;\n                }\n                c = (l << 5 | l >>> 27) + j + m[a];\n                c = 20 > a ? c + ((k & h | ~k & g) + 1518500249) : 40 > a ? c + ((k ^ h ^ g) + 1859775393) : 60 > a ? c + ((k & h | k & g | h & g) - 1894007588) : c + ((k ^ h ^ g) - 899497514);\n                j = g;\n                g = h;\n                h = k << 30 | k >>> 2;\n                k = l;\n                l = c;\n              }\n\n              b[0] = b[0] + l | 0;\n              b[1] = b[1] + k | 0;\n              b[2] = b[2] + h | 0;\n              b[3] = b[3] + g | 0;\n              b[4] = b[4] + j | 0;\n            },\n            _doFinalize: function () {\n              var d = this._data,\n                  e = d.words,\n                  b = 8 * this._nDataBytes,\n                  l = 8 * d.sigBytes;\n              e[l >>> 5] |= 128 << 24 - l % 32;\n              e[(l + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);\n              e[(l + 64 >>> 9 << 4) + 15] = b;\n              d.sigBytes = 4 * e.length;\n\n              this._process();\n\n              return this._hash;\n            },\n            clone: function () {\n              var e = d.clone.call(this);\n              e._hash = this._hash.clone();\n              return e;\n            }\n          });\n          g.SHA1 = d._createHelper(j);\n          g.HmacSHA1 = d._createHmacHelper(j);\n        })();\n\n        (function () {\n          var g = CryptoJS,\n              j = g.enc.Utf8;\n          g.algo.HMAC = g.lib.Base.extend({\n            init: function (e, d) {\n              e = this._hasher = new e.init();\n              \"string\" == typeof d && (d = j.parse(d));\n              var g = e.blockSize,\n                  n = 4 * g;\n              d.sigBytes > n && (d = e.finalize(d));\n              d.clamp();\n\n              for (var q = this._oKey = d.clone(), b = this._iKey = d.clone(), l = q.words, k = b.words, h = 0; h < g; h++) l[h] ^= 1549556828, k[h] ^= 909522486;\n\n              q.sigBytes = b.sigBytes = n;\n              this.reset();\n            },\n            reset: function () {\n              var e = this._hasher;\n              e.reset();\n              e.update(this._iKey);\n            },\n            update: function (e) {\n              this._hasher.update(e);\n\n              return this;\n            },\n            finalize: function (e) {\n              var d = this._hasher;\n              e = d.finalize(e);\n              d.reset();\n              return d.finalize(this._oKey.clone().concat(e));\n            }\n          });\n        })();\n\n        (function () {\n          var g = CryptoJS,\n              j = g.lib,\n              e = j.Base,\n              d = j.WordArray,\n              j = g.algo,\n              m = j.HMAC,\n              n = j.PBKDF2 = e.extend({\n            cfg: e.extend({\n              keySize: 4,\n              hasher: j.SHA1,\n              iterations: 1\n            }),\n            init: function (d) {\n              this.cfg = this.cfg.extend(d);\n            },\n            compute: function (e, b) {\n              for (var g = this.cfg, k = m.create(g.hasher, e), h = d.create(), j = d.create([1]), n = h.words, a = j.words, c = g.keySize, g = g.iterations; n.length < c;) {\n                var p = k.update(b).finalize(j);\n                k.reset();\n\n                for (var f = p.words, v = f.length, s = p, t = 1; t < g; t++) {\n                  s = k.finalize(s);\n                  k.reset();\n\n                  for (var x = s.words, r = 0; r < v; r++) f[r] ^= x[r];\n                }\n\n                h.concat(p);\n                a[0]++;\n              }\n\n              h.sigBytes = 4 * c;\n              return h;\n            }\n          });\n\n          g.PBKDF2 = function (d, b, e) {\n            return n.create(e).compute(d, b);\n          };\n        })();\n\n        ;\n        /*\n        CryptoJS v3.1.2\n        code.google.com/p/crypto-js\n        (c) 2009-2013 by Jeff Mott. All rights reserved.\n        code.google.com/p/crypto-js/wiki/License\n        */\n\n        var CryptoJS = CryptoJS || function (e, m) {\n          var p = {},\n              j = p.lib = {},\n              l = function () {},\n              f = j.Base = {\n            extend: function (a) {\n              l.prototype = this;\n              var c = new l();\n              a && c.mixIn(a);\n              c.hasOwnProperty(\"init\") || (c.init = function () {\n                c.$super.init.apply(this, arguments);\n              });\n              c.init.prototype = c;\n              c.$super = this;\n              return c;\n            },\n            create: function () {\n              var a = this.extend();\n              a.init.apply(a, arguments);\n              return a;\n            },\n            init: function () {},\n            mixIn: function (a) {\n              for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);\n\n              a.hasOwnProperty(\"toString\") && (this.toString = a.toString);\n            },\n            clone: function () {\n              return this.init.prototype.extend(this);\n            }\n          },\n              n = j.WordArray = f.extend({\n            init: function (a, c) {\n              a = this.words = a || [];\n              this.sigBytes = c != m ? c : 4 * a.length;\n            },\n            toString: function (a) {\n              return (a || h).stringify(this);\n            },\n            concat: function (a) {\n              var c = this.words,\n                  q = a.words,\n                  d = this.sigBytes;\n              a = a.sigBytes;\n              this.clamp();\n              if (d % 4) for (var b = 0; b < a; b++) c[d + b >>> 2] |= (q[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((d + b) % 4);else if (65535 < q.length) for (b = 0; b < a; b += 4) c[d + b >>> 2] = q[b >>> 2];else c.push.apply(c, q);\n              this.sigBytes += a;\n              return this;\n            },\n            clamp: function () {\n              var a = this.words,\n                  c = this.sigBytes;\n              a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);\n              a.length = e.ceil(c / 4);\n            },\n            clone: function () {\n              var a = f.clone.call(this);\n              a.words = this.words.slice(0);\n              return a;\n            },\n            random: function (a) {\n              for (var c = [], b = 0; b < a; b += 4) c.push(4294967296 * e.random() | 0);\n\n              return new n.init(c, a);\n            }\n          }),\n              b = p.enc = {},\n              h = b.Hex = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var b = [], d = 0; d < a; d++) {\n                var f = c[d >>> 2] >>> 24 - 8 * (d % 4) & 255;\n                b.push((f >>> 4).toString(16));\n                b.push((f & 15).toString(16));\n              }\n\n              return b.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, b = [], d = 0; d < c; d += 2) b[d >>> 3] |= parseInt(a.substr(d, 2), 16) << 24 - 4 * (d % 8);\n\n              return new n.init(b, c / 2);\n            }\n          },\n              g = b.Latin1 = {\n            stringify: function (a) {\n              var c = a.words;\n              a = a.sigBytes;\n\n              for (var b = [], d = 0; d < a; d++) b.push(String.fromCharCode(c[d >>> 2] >>> 24 - 8 * (d % 4) & 255));\n\n              return b.join(\"\");\n            },\n            parse: function (a) {\n              for (var c = a.length, b = [], d = 0; d < c; d++) b[d >>> 2] |= (a.charCodeAt(d) & 255) << 24 - 8 * (d % 4);\n\n              return new n.init(b, c);\n            }\n          },\n              r = b.Utf8 = {\n            stringify: function (a) {\n              try {\n                return decodeURIComponent(escape(g.stringify(a)));\n              } catch (c) {\n                throw Error(\"Malformed UTF-8 data\");\n              }\n            },\n            parse: function (a) {\n              return g.parse(unescape(encodeURIComponent(a)));\n            }\n          },\n              k = j.BufferedBlockAlgorithm = f.extend({\n            reset: function () {\n              this._data = new n.init();\n              this._nDataBytes = 0;\n            },\n            _append: function (a) {\n              \"string\" == typeof a && (a = r.parse(a));\n\n              this._data.concat(a);\n\n              this._nDataBytes += a.sigBytes;\n            },\n            _process: function (a) {\n              var c = this._data,\n                  b = c.words,\n                  d = c.sigBytes,\n                  f = this.blockSize,\n                  h = d / (4 * f),\n                  h = a ? e.ceil(h) : e.max((h | 0) - this._minBufferSize, 0);\n              a = h * f;\n              d = e.min(4 * a, d);\n\n              if (a) {\n                for (var g = 0; g < a; g += f) this._doProcessBlock(b, g);\n\n                g = b.splice(0, a);\n                c.sigBytes -= d;\n              }\n\n              return new n.init(g, d);\n            },\n            clone: function () {\n              var a = f.clone.call(this);\n              a._data = this._data.clone();\n              return a;\n            },\n            _minBufferSize: 0\n          });\n\n          j.Hasher = k.extend({\n            cfg: f.extend(),\n            init: function (a) {\n              this.cfg = this.cfg.extend(a);\n              this.reset();\n            },\n            reset: function () {\n              k.reset.call(this);\n\n              this._doReset();\n            },\n            update: function (a) {\n              this._append(a);\n\n              this._process();\n\n              return this;\n            },\n            finalize: function (a) {\n              a && this._append(a);\n              return this._doFinalize();\n            },\n            blockSize: 16,\n            _createHelper: function (a) {\n              return function (c, b) {\n                return new a.init(b).finalize(c);\n              };\n            },\n            _createHmacHelper: function (a) {\n              return function (b, f) {\n                return new s.HMAC.init(a, f).finalize(b);\n              };\n            }\n          });\n          var s = p.algo = {};\n          return p;\n        }(Math);\n\n        (function () {\n          var e = CryptoJS,\n              m = e.lib,\n              p = m.WordArray,\n              j = m.Hasher,\n              l = [],\n              m = e.algo.SHA1 = j.extend({\n            _doReset: function () {\n              this._hash = new p.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);\n            },\n            _doProcessBlock: function (f, n) {\n              for (var b = this._hash.words, h = b[0], g = b[1], e = b[2], k = b[3], j = b[4], a = 0; 80 > a; a++) {\n                if (16 > a) l[a] = f[n + a] | 0;else {\n                  var c = l[a - 3] ^ l[a - 8] ^ l[a - 14] ^ l[a - 16];\n                  l[a] = c << 1 | c >>> 31;\n                }\n                c = (h << 5 | h >>> 27) + j + l[a];\n                c = 20 > a ? c + ((g & e | ~g & k) + 1518500249) : 40 > a ? c + ((g ^ e ^ k) + 1859775393) : 60 > a ? c + ((g & e | g & k | e & k) - 1894007588) : c + ((g ^ e ^ k) - 899497514);\n                j = k;\n                k = e;\n                e = g << 30 | g >>> 2;\n                g = h;\n                h = c;\n              }\n\n              b[0] = b[0] + h | 0;\n              b[1] = b[1] + g | 0;\n              b[2] = b[2] + e | 0;\n              b[3] = b[3] + k | 0;\n              b[4] = b[4] + j | 0;\n            },\n            _doFinalize: function () {\n              var f = this._data,\n                  e = f.words,\n                  b = 8 * this._nDataBytes,\n                  h = 8 * f.sigBytes;\n              e[h >>> 5] |= 128 << 24 - h % 32;\n              e[(h + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);\n              e[(h + 64 >>> 9 << 4) + 15] = b;\n              f.sigBytes = 4 * e.length;\n\n              this._process();\n\n              return this._hash;\n            },\n            clone: function () {\n              var e = j.clone.call(this);\n              e._hash = this._hash.clone();\n              return e;\n            }\n          });\n          e.SHA1 = j._createHelper(m);\n          e.HmacSHA1 = j._createHmacHelper(m);\n        })();\n\n        ;\n        \"use strict\";\n\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n\n        var _slicedToArray = function () {\n          function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n\n            try {\n              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                _arr.push(_s.value);\n\n                if (i && _arr.length === i) break;\n              }\n            } catch (err) {\n              _d = true;\n              _e = err;\n            } finally {\n              try {\n                if (!_n && _i[\"return\"]) _i[\"return\"]();\n              } finally {\n                if (_d) throw _e;\n              }\n            }\n\n            return _arr;\n          }\n\n          return function (arr, i) {\n            if (Array.isArray(arr)) {\n              return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n              return sliceIterator(arr, i);\n            } else {\n              throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n          };\n        }();\n\n        var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n          return typeof obj;\n        } : function (obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n\n        function _possibleConstructorReturn(self, call) {\n          if (!self) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          }\n\n          return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n        }\n\n        function _inherits(subClass, superClass) {\n          if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n          }\n\n          subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n              value: subClass,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n          if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n        }\n\n        function _asyncToGenerator(fn) {\n          return function () {\n            var gen = fn.apply(this, arguments);\n            return new Promise(function (resolve, reject) {\n              function step(key, arg) {\n                try {\n                  var info = gen[key](arg);\n                  var value = info.value;\n                } catch (error) {\n                  reject(error);\n                  return;\n                }\n\n                if (info.done) {\n                  resolve(value);\n                } else {\n                  return Promise.resolve(value).then(function (value) {\n                    step(\"next\", value);\n                  }, function (err) {\n                    step(\"throw\", err);\n                  });\n                }\n              }\n\n              return step(\"next\");\n            });\n          };\n        }\n\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        var SFAlertManager = exports.SFAlertManager = function () {\n          function SFAlertManager() {\n            _classCallCheck(this, SFAlertManager);\n          }\n\n          _createClass(SFAlertManager, [{\n            key: \"alert\",\n            value: function () {\n              var _ref = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee(params) {\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          window.alert(params.text);\n                          resolve();\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, this);\n              }));\n\n              function alert(_x) {\n                return _ref.apply(this, arguments);\n              }\n\n              return alert;\n            }()\n          }, {\n            key: \"confirm\",\n            value: function () {\n              var _ref2 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee2(params) {\n                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          if (window.confirm(params.text)) {\n                            resolve();\n                          } else {\n                            reject();\n                          }\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, this);\n              }));\n\n              function confirm(_x2) {\n                return _ref2.apply(this, arguments);\n              }\n\n              return confirm;\n            }()\n          }]);\n\n          return SFAlertManager;\n        }();\n\n        ;\n\n        var SFAuthManager = exports.SFAuthManager = function () {\n          function SFAuthManager(storageManager, httpManager, alertManager, timeout) {\n            _classCallCheck(this, SFAuthManager);\n\n            SFAuthManager.DidSignOutEvent = \"DidSignOutEvent\";\n            SFAuthManager.WillSignInEvent = \"WillSignInEvent\";\n            SFAuthManager.DidSignInEvent = \"DidSignInEvent\";\n            this.httpManager = httpManager;\n            this.storageManager = storageManager;\n            this.alertManager = alertManager || new SFAlertManager();\n            this.$timeout = timeout || setTimeout.bind(window);\n            this.eventHandlers = [];\n          }\n\n          _createClass(SFAuthManager, [{\n            key: \"addEventHandler\",\n            value: function addEventHandler(handler) {\n              this.eventHandlers.push(handler);\n              return handler;\n            }\n          }, {\n            key: \"removeEventHandler\",\n            value: function removeEventHandler(handler) {\n              _.pull(this.eventHandlers, handler);\n            }\n          }, {\n            key: \"notifyEvent\",\n            value: function notifyEvent(event, data) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = this.eventHandlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var handler = _step.value;\n                  handler(event, data || {});\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            }\n          }, {\n            key: \"saveKeys\",\n            value: function () {\n              var _ref3 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee3(keys) {\n                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        this._keys = keys;\n                        _context3.next = 3;\n                        return this.storageManager.setItem(\"mk\", keys.mk);\n\n                      case 3:\n                        _context3.next = 5;\n                        return this.storageManager.setItem(\"ak\", keys.ak);\n\n                      case 5:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3, this);\n              }));\n\n              function saveKeys(_x3) {\n                return _ref3.apply(this, arguments);\n              }\n\n              return saveKeys;\n            }()\n          }, {\n            key: \"signout\",\n            value: function () {\n              var _ref4 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee4(clearAllData) {\n                var _this = this;\n\n                return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        this._keys = null;\n                        this._authParams = null;\n\n                        if (!clearAllData) {\n                          _context4.next = 6;\n                          break;\n                        }\n\n                        return _context4.abrupt(\"return\", this.storageManager.clearAllData().then(function () {\n                          _this.notifyEvent(SFAuthManager.DidSignOutEvent);\n                        }));\n\n                      case 6:\n                        this.notifyEvent(SFAuthManager.DidSignOutEvent);\n\n                      case 7:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4, this);\n              }));\n\n              function signout(_x4) {\n                return _ref4.apply(this, arguments);\n              }\n\n              return signout;\n            }()\n          }, {\n            key: \"keys\",\n            value: function () {\n              var _ref5 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee5() {\n                var mk;\n                return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                        if (this._keys) {\n                          _context5.next = 11;\n                          break;\n                        }\n\n                        _context5.next = 3;\n                        return this.storageManager.getItem(\"mk\");\n\n                      case 3:\n                        mk = _context5.sent;\n\n                        if (mk) {\n                          _context5.next = 6;\n                          break;\n                        }\n\n                        return _context5.abrupt(\"return\", null);\n\n                      case 6:\n                        _context5.t0 = mk;\n                        _context5.next = 9;\n                        return this.storageManager.getItem(\"ak\");\n\n                      case 9:\n                        _context5.t1 = _context5.sent;\n                        this._keys = {\n                          mk: _context5.t0,\n                          ak: _context5.t1\n                        };\n\n                      case 11:\n                        return _context5.abrupt(\"return\", this._keys);\n\n                      case 12:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5, this);\n              }));\n\n              function keys() {\n                return _ref5.apply(this, arguments);\n              }\n\n              return keys;\n            }()\n          }, {\n            key: \"getAuthParams\",\n            value: function () {\n              var _ref6 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee6() {\n                var data;\n                return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        if (this._authParams) {\n                          _context6.next = 5;\n                          break;\n                        }\n\n                        _context6.next = 3;\n                        return this.storageManager.getItem(\"auth_params\");\n\n                      case 3:\n                        data = _context6.sent;\n                        this._authParams = JSON.parse(data);\n\n                      case 5:\n                        if (!(this._authParams && !this._authParams.version)) {\n                          _context6.next = 9;\n                          break;\n                        }\n\n                        _context6.next = 8;\n                        return this.defaultProtocolVersion();\n\n                      case 8:\n                        this._authParams.version = _context6.sent;\n\n                      case 9:\n                        return _context6.abrupt(\"return\", this._authParams);\n\n                      case 10:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6, this);\n              }));\n\n              function getAuthParams() {\n                return _ref6.apply(this, arguments);\n              }\n\n              return getAuthParams;\n            }()\n          }, {\n            key: \"defaultProtocolVersion\",\n            value: function () {\n              var _ref7 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee7() {\n                var keys;\n                return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        _context7.next = 2;\n                        return this.keys();\n\n                      case 2:\n                        keys = _context7.sent;\n\n                        if (!(keys && keys.ak)) {\n                          _context7.next = 7;\n                          break;\n                        }\n\n                        return _context7.abrupt(\"return\", \"002\");\n\n                      case 7:\n                        return _context7.abrupt(\"return\", \"001\");\n\n                      case 8:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7, this);\n              }));\n\n              function defaultProtocolVersion() {\n                return _ref7.apply(this, arguments);\n              }\n\n              return defaultProtocolVersion;\n            }()\n          }, {\n            key: \"protocolVersion\",\n            value: function () {\n              var _ref8 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee8() {\n                var authParams;\n                return regeneratorRuntime.wrap(function _callee8$(_context8) {\n                  while (1) {\n                    switch (_context8.prev = _context8.next) {\n                      case 0:\n                        _context8.next = 2;\n                        return this.getAuthParams();\n\n                      case 2:\n                        authParams = _context8.sent;\n\n                        if (!(authParams && authParams.version)) {\n                          _context8.next = 5;\n                          break;\n                        }\n\n                        return _context8.abrupt(\"return\", authParams.version);\n\n                      case 5:\n                        return _context8.abrupt(\"return\", this.defaultProtocolVersion());\n\n                      case 6:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }\n                }, _callee8, this);\n              }));\n\n              function protocolVersion() {\n                return _ref8.apply(this, arguments);\n              }\n\n              return protocolVersion;\n            }()\n          }, {\n            key: \"getAuthParamsForEmail\",\n            value: function () {\n              var _ref9 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee9(url, email, extraParams) {\n                var _this2 = this;\n\n                return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                  while (1) {\n                    switch (_context9.prev = _context9.next) {\n                      case 0:\n                        return _context9.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          var requestUrl = url + \"/auth/params\";\n\n                          _this2.httpManager.getAbsolute(requestUrl, _.merge({\n                            email: email\n                          }, extraParams), function (response) {\n                            resolve(response);\n                          }, function (response) {\n                            console.error(\"Error getting auth params\", response);\n\n                            if ((typeof response === \"undefined\" ? \"undefined\" : _typeof(response)) !== 'object') {\n                              response = {\n                                error: {\n                                  message: \"A server error occurred while trying to sign in. Please try again.\"\n                                }\n                              };\n                            }\n\n                            resolve(response);\n                          });\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context9.stop();\n                    }\n                  }\n                }, _callee9, this);\n              }));\n\n              function getAuthParamsForEmail(_x5, _x6, _x7) {\n                return _ref9.apply(this, arguments);\n              }\n\n              return getAuthParamsForEmail;\n            }()\n          }, {\n            key: \"lock\",\n            value: function lock() {\n              this.locked = true;\n            }\n          }, {\n            key: \"unlock\",\n            value: function unlock() {\n              this.locked = false;\n            }\n          }, {\n            key: \"isLocked\",\n            value: function isLocked() {\n              return this.locked == true;\n            }\n          }, {\n            key: \"unlockAndResolve\",\n            value: function unlockAndResolve(resolve, param) {\n              this.unlock();\n              resolve(param);\n            }\n          }, {\n            key: \"login\",\n            value: function () {\n              var _ref10 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee12(url, email, password, strictSignin, extraParams) {\n                var _this3 = this;\n\n                return regeneratorRuntime.wrap(function _callee12$(_context12) {\n                  while (1) {\n                    switch (_context12.prev = _context12.next) {\n                      case 0:\n                        return _context12.abrupt(\"return\", new Promise(function () {\n                          var _ref11 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee11(resolve, reject) {\n                            var existingKeys, authParams, message, _message, abort, _message2, minimum, _message3, latestVersion, _message4, keys, requestUrl, params;\n\n                            return regeneratorRuntime.wrap(function _callee11$(_context11) {\n                              while (1) {\n                                switch (_context11.prev = _context11.next) {\n                                  case 0:\n                                    _context11.next = 2;\n                                    return _this3.keys();\n\n                                  case 2:\n                                    existingKeys = _context11.sent;\n\n                                    if (!(existingKeys != null)) {\n                                      _context11.next = 6;\n                                      break;\n                                    }\n\n                                    resolve({\n                                      error: {\n                                        message: \"Cannot log in because already signed in.\"\n                                      }\n                                    });\n                                    return _context11.abrupt(\"return\");\n\n                                  case 6:\n                                    if (!_this3.isLocked()) {\n                                      _context11.next = 9;\n                                      break;\n                                    }\n\n                                    resolve({\n                                      error: {\n                                        message: \"Login already in progress.\"\n                                      }\n                                    });\n                                    return _context11.abrupt(\"return\");\n\n                                  case 9:\n                                    _this3.lock();\n\n                                    _this3.notifyEvent(SFAuthManager.WillSignInEvent);\n\n                                    _context11.next = 13;\n                                    return _this3.getAuthParamsForEmail(url, email, extraParams);\n\n                                  case 13:\n                                    authParams = _context11.sent; // SF3 requires a unique identifier in the auth params\n\n                                    authParams.identifier = email;\n\n                                    if (!authParams.error) {\n                                      _context11.next = 18;\n                                      break;\n                                    }\n\n                                    _this3.unlockAndResolve(resolve, authParams);\n\n                                    return _context11.abrupt(\"return\");\n\n                                  case 18:\n                                    if (!(!authParams || !authParams.pw_cost)) {\n                                      _context11.next = 21;\n                                      break;\n                                    }\n\n                                    _this3.unlockAndResolve(resolve, {\n                                      error: {\n                                        message: \"Invalid email or password.\"\n                                      }\n                                    });\n\n                                    return _context11.abrupt(\"return\");\n\n                                  case 21:\n                                    if (SFJS.supportedVersions().includes(authParams.version)) {\n                                      _context11.next = 25;\n                                      break;\n                                    }\n\n                                    if (SFJS.isVersionNewerThanLibraryVersion(authParams.version)) {\n                                      // The user has a new account type, but is signing in to an older client.\n                                      message = \"This version of the application does not support your newer account type. Please upgrade to the latest version of Standard Notes to sign in.\";\n                                    } else {\n                                      // The user has a very old account type, which is no longer supported by this client\n                                      message = \"The protocol version associated with your account is outdated and no longer supported by this application. Please visit standardnotes.org/help/security for more information.\";\n                                    }\n\n                                    _this3.unlockAndResolve(resolve, {\n                                      error: {\n                                        message: message\n                                      }\n                                    });\n\n                                    return _context11.abrupt(\"return\");\n\n                                  case 25:\n                                    if (!SFJS.isProtocolVersionOutdated(authParams.version)) {\n                                      _context11.next = 32;\n                                      break;\n                                    }\n\n                                    _message = \"The encryption version for your account, \" + authParams.version + \", is outdated and requires upgrade. You may proceed with login, but are advised to perform a security update using the web or desktop application. Please visit standardnotes.org/help/security for more information.\";\n                                    abort = false;\n                                    _context11.next = 30;\n                                    return _this3.alertManager.confirm({\n                                      title: \"Update Needed\",\n                                      text: _message,\n                                      confirmButtonText: \"Sign In\"\n                                    }).catch(function () {\n                                      _this3.unlockAndResolve(resolve, {\n                                        error: {}\n                                      });\n\n                                      abort = true;\n                                    });\n\n                                  case 30:\n                                    if (!abort) {\n                                      _context11.next = 32;\n                                      break;\n                                    }\n\n                                    return _context11.abrupt(\"return\");\n\n                                  case 32:\n                                    if (SFJS.supportsPasswordDerivationCost(authParams.pw_cost)) {\n                                      _context11.next = 36;\n                                      break;\n                                    }\n\n                                    _message2 = \"Your account was created on a platform with higher security capabilities than this browser supports. \" + \"If we attempted to generate your login keys here, it would take hours. \" + \"Please use a browser with more up to date security capabilities, like Google Chrome or Firefox, to log in.\";\n\n                                    _this3.unlockAndResolve(resolve, {\n                                      error: {\n                                        message: _message2\n                                      }\n                                    });\n\n                                    return _context11.abrupt(\"return\");\n\n                                  case 36:\n                                    minimum = SFJS.costMinimumForVersion(authParams.version);\n\n                                    if (!(authParams.pw_cost < minimum)) {\n                                      _context11.next = 41;\n                                      break;\n                                    }\n\n                                    _message3 = \"Unable to login due to insecure password parameters. Please visit standardnotes.org/help/security for more information.\";\n\n                                    _this3.unlockAndResolve(resolve, {\n                                      error: {\n                                        message: _message3\n                                      }\n                                    });\n\n                                    return _context11.abrupt(\"return\");\n\n                                  case 41:\n                                    if (!strictSignin) {\n                                      _context11.next = 47;\n                                      break;\n                                    } // Refuse sign in if authParams.version is anything but the latest version\n\n\n                                    latestVersion = SFJS.version();\n\n                                    if (!(authParams.version !== latestVersion)) {\n                                      _context11.next = 47;\n                                      break;\n                                    }\n\n                                    _message4 = \"Strict sign in refused server sign in parameters. The latest security version is \" + latestVersion + \", but your account is reported to have version \" + authParams.version + \". If you'd like to proceed with sign in anyway, please disable strict sign in and try again.\";\n\n                                    _this3.unlockAndResolve(resolve, {\n                                      error: {\n                                        message: _message4\n                                      }\n                                    });\n\n                                    return _context11.abrupt(\"return\");\n\n                                  case 47:\n                                    _context11.next = 49;\n                                    return SFJS.crypto.computeEncryptionKeysForUser(password, authParams);\n\n                                  case 49:\n                                    keys = _context11.sent;\n                                    requestUrl = url + \"/auth/sign_in\";\n                                    params = _.merge({\n                                      password: keys.pw,\n                                      email: email\n                                    }, extraParams);\n\n                                    _this3.httpManager.postAbsolute(requestUrl, params, function () {\n                                      var _ref12 = _asyncToGenerator(\n                                      /*#__PURE__*/\n                                      regeneratorRuntime.mark(function _callee10(response) {\n                                        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n                                          while (1) {\n                                            switch (_context10.prev = _context10.next) {\n                                              case 0:\n                                                _context10.next = 2;\n                                                return _this3.handleAuthResponse(response, email, url, authParams, keys);\n\n                                              case 2:\n                                                _this3.notifyEvent(SFAuthManager.DidSignInEvent);\n\n                                                _this3.$timeout(function () {\n                                                  return _this3.unlockAndResolve(resolve, response);\n                                                });\n\n                                              case 4:\n                                              case \"end\":\n                                                return _context10.stop();\n                                            }\n                                          }\n                                        }, _callee10, _this3);\n                                      }));\n\n                                      return function (_x15) {\n                                        return _ref12.apply(this, arguments);\n                                      };\n                                    }(), function (response) {\n                                      console.error(\"Error logging in\", response);\n\n                                      if ((typeof response === \"undefined\" ? \"undefined\" : _typeof(response)) !== 'object') {\n                                        response = {\n                                          error: {\n                                            message: \"A server error occurred while trying to sign in. Please try again.\"\n                                          }\n                                        };\n                                      }\n\n                                      _this3.$timeout(function () {\n                                        return _this3.unlockAndResolve(resolve, response);\n                                      });\n                                    });\n\n                                  case 53:\n                                  case \"end\":\n                                    return _context11.stop();\n                                }\n                              }\n                            }, _callee11, _this3);\n                          }));\n\n                          return function (_x13, _x14) {\n                            return _ref11.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 1:\n                      case \"end\":\n                        return _context12.stop();\n                    }\n                  }\n                }, _callee12, this);\n              }));\n\n              function login(_x8, _x9, _x10, _x11, _x12) {\n                return _ref10.apply(this, arguments);\n              }\n\n              return login;\n            }()\n          }, {\n            key: \"register\",\n            value: function register(url, email, password) {\n              var _this4 = this;\n\n              return new Promise(function () {\n                var _ref13 = _asyncToGenerator(\n                /*#__PURE__*/\n                regeneratorRuntime.mark(function _callee14(resolve, reject) {\n                  var results, keys, authParams, requestUrl, params;\n                  return regeneratorRuntime.wrap(function _callee14$(_context14) {\n                    while (1) {\n                      switch (_context14.prev = _context14.next) {\n                        case 0:\n                          if (!_this4.isLocked()) {\n                            _context14.next = 3;\n                            break;\n                          }\n\n                          resolve({\n                            error: {\n                              message: \"Register already in progress.\"\n                            }\n                          });\n                          return _context14.abrupt(\"return\");\n\n                        case 3:\n                          _this4.lock();\n\n                          _context14.next = 6;\n                          return SFJS.crypto.generateInitialKeysAndAuthParamsForUser(email, password);\n\n                        case 6:\n                          results = _context14.sent;\n                          keys = results.keys;\n                          authParams = results.authParams;\n                          requestUrl = url + \"/auth\";\n                          params = _.merge({\n                            password: keys.pw,\n                            email: email\n                          }, authParams);\n\n                          _this4.httpManager.postAbsolute(requestUrl, params, function () {\n                            var _ref14 = _asyncToGenerator(\n                            /*#__PURE__*/\n                            regeneratorRuntime.mark(function _callee13(response) {\n                              return regeneratorRuntime.wrap(function _callee13$(_context13) {\n                                while (1) {\n                                  switch (_context13.prev = _context13.next) {\n                                    case 0:\n                                      _context13.next = 2;\n                                      return _this4.handleAuthResponse(response, email, url, authParams, keys);\n\n                                    case 2:\n                                      _this4.unlockAndResolve(resolve, response);\n\n                                    case 3:\n                                    case \"end\":\n                                      return _context13.stop();\n                                  }\n                                }\n                              }, _callee13, _this4);\n                            }));\n\n                            return function (_x18) {\n                              return _ref14.apply(this, arguments);\n                            };\n                          }(), function (response) {\n                            console.error(\"Registration error\", response);\n\n                            if ((typeof response === \"undefined\" ? \"undefined\" : _typeof(response)) !== 'object') {\n                              response = {\n                                error: {\n                                  message: \"A server error occurred while trying to register. Please try again.\"\n                                }\n                              };\n                            }\n\n                            _this4.unlockAndResolve(resolve, response);\n                          });\n\n                        case 12:\n                        case \"end\":\n                          return _context14.stop();\n                      }\n                    }\n                  }, _callee14, _this4);\n                }));\n\n                return function (_x16, _x17) {\n                  return _ref13.apply(this, arguments);\n                };\n              }());\n            }\n          }, {\n            key: \"changePassword\",\n            value: function () {\n              var _ref15 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee17(url, email, current_server_pw, newKeys, newAuthParams) {\n                var _this5 = this;\n\n                return regeneratorRuntime.wrap(function _callee17$(_context17) {\n                  while (1) {\n                    switch (_context17.prev = _context17.next) {\n                      case 0:\n                        return _context17.abrupt(\"return\", new Promise(function () {\n                          var _ref16 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee16(resolve, reject) {\n                            var newServerPw, requestUrl, params;\n                            return regeneratorRuntime.wrap(function _callee16$(_context16) {\n                              while (1) {\n                                switch (_context16.prev = _context16.next) {\n                                  case 0:\n                                    if (!_this5.isLocked()) {\n                                      _context16.next = 3;\n                                      break;\n                                    }\n\n                                    resolve({\n                                      error: {\n                                        message: \"Change password already in progress.\"\n                                      }\n                                    });\n                                    return _context16.abrupt(\"return\");\n\n                                  case 3:\n                                    _this5.lock();\n\n                                    newServerPw = newKeys.pw;\n                                    requestUrl = url + \"/auth/change_pw\";\n                                    params = _.merge({\n                                      new_password: newServerPw,\n                                      current_password: current_server_pw\n                                    }, newAuthParams);\n\n                                    _this5.httpManager.postAbsolute(requestUrl, params, function () {\n                                      var _ref17 = _asyncToGenerator(\n                                      /*#__PURE__*/\n                                      regeneratorRuntime.mark(function _callee15(response) {\n                                        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n                                          while (1) {\n                                            switch (_context15.prev = _context15.next) {\n                                              case 0:\n                                                _context15.next = 2;\n                                                return _this5.handleAuthResponse(response, email, null, newAuthParams, newKeys);\n\n                                              case 2:\n                                                _this5.unlockAndResolve(resolve, response);\n\n                                              case 3:\n                                              case \"end\":\n                                                return _context15.stop();\n                                            }\n                                          }\n                                        }, _callee15, _this5);\n                                      }));\n\n                                      return function (_x26) {\n                                        return _ref17.apply(this, arguments);\n                                      };\n                                    }(), function (response) {\n                                      if ((typeof response === \"undefined\" ? \"undefined\" : _typeof(response)) !== 'object') {\n                                        response = {\n                                          error: {\n                                            message: \"Something went wrong while changing your password. Your password was not changed. Please try again.\"\n                                          }\n                                        };\n                                      }\n\n                                      _this5.unlockAndResolve(resolve, response);\n                                    });\n\n                                  case 8:\n                                  case \"end\":\n                                    return _context16.stop();\n                                }\n                              }\n                            }, _callee16, _this5);\n                          }));\n\n                          return function (_x24, _x25) {\n                            return _ref16.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 1:\n                      case \"end\":\n                        return _context17.stop();\n                    }\n                  }\n                }, _callee17, this);\n              }));\n\n              function changePassword(_x19, _x20, _x21, _x22, _x23) {\n                return _ref15.apply(this, arguments);\n              }\n\n              return changePassword;\n            }()\n          }, {\n            key: \"handleAuthResponse\",\n            value: function () {\n              var _ref18 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee18(response, email, url, authParams, keys) {\n                return regeneratorRuntime.wrap(function _callee18$(_context18) {\n                  while (1) {\n                    switch (_context18.prev = _context18.next) {\n                      case 0:\n                        if (!url) {\n                          _context18.next = 3;\n                          break;\n                        }\n\n                        _context18.next = 3;\n                        return this.storageManager.setItem(\"server\", url);\n\n                      case 3:\n                        this._authParams = authParams;\n                        _context18.next = 6;\n                        return this.storageManager.setItem(\"auth_params\", JSON.stringify(authParams));\n\n                      case 6:\n                        _context18.next = 8;\n                        return this.storageManager.setItem(\"jwt\", response.token);\n\n                      case 8:\n                        return _context18.abrupt(\"return\", this.saveKeys(keys));\n\n                      case 9:\n                      case \"end\":\n                        return _context18.stop();\n                    }\n                  }\n                }, _callee18, this);\n              }));\n\n              function handleAuthResponse(_x27, _x28, _x29, _x30, _x31) {\n                return _ref18.apply(this, arguments);\n              }\n\n              return handleAuthResponse;\n            }()\n          }]);\n\n          return SFAuthManager;\n        }();\n\n        ;\n        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;\n\n        var SFHttpManager = exports.SFHttpManager = function () {\n          function SFHttpManager(timeout) {\n            _classCallCheck(this, SFHttpManager); // calling callbacks in a $timeout allows UI to update\n\n\n            this.$timeout = timeout || setTimeout.bind(globalScope);\n          }\n\n          _createClass(SFHttpManager, [{\n            key: \"setJWTRequestHandler\",\n            value: function setJWTRequestHandler(handler) {\n              this.jwtRequestHandler = handler;\n            }\n          }, {\n            key: \"setAuthHeadersForRequest\",\n            value: function () {\n              var _ref19 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee19(request) {\n                var token;\n                return regeneratorRuntime.wrap(function _callee19$(_context19) {\n                  while (1) {\n                    switch (_context19.prev = _context19.next) {\n                      case 0:\n                        _context19.next = 2;\n                        return this.jwtRequestHandler();\n\n                      case 2:\n                        token = _context19.sent;\n\n                        if (token) {\n                          request.setRequestHeader('Authorization', 'Bearer ' + token);\n                        }\n\n                      case 4:\n                      case \"end\":\n                        return _context19.stop();\n                    }\n                  }\n                }, _callee19, this);\n              }));\n\n              function setAuthHeadersForRequest(_x32) {\n                return _ref19.apply(this, arguments);\n              }\n\n              return setAuthHeadersForRequest;\n            }()\n          }, {\n            key: \"postAbsolute\",\n            value: function () {\n              var _ref20 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee20(url, params, onsuccess, onerror) {\n                return regeneratorRuntime.wrap(function _callee20$(_context20) {\n                  while (1) {\n                    switch (_context20.prev = _context20.next) {\n                      case 0:\n                        return _context20.abrupt(\"return\", this.httpRequest(\"post\", url, params, onsuccess, onerror));\n\n                      case 1:\n                      case \"end\":\n                        return _context20.stop();\n                    }\n                  }\n                }, _callee20, this);\n              }));\n\n              function postAbsolute(_x33, _x34, _x35, _x36) {\n                return _ref20.apply(this, arguments);\n              }\n\n              return postAbsolute;\n            }()\n          }, {\n            key: \"patchAbsolute\",\n            value: function () {\n              var _ref21 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee21(url, params, onsuccess, onerror) {\n                return regeneratorRuntime.wrap(function _callee21$(_context21) {\n                  while (1) {\n                    switch (_context21.prev = _context21.next) {\n                      case 0:\n                        return _context21.abrupt(\"return\", this.httpRequest(\"patch\", url, params, onsuccess, onerror));\n\n                      case 1:\n                      case \"end\":\n                        return _context21.stop();\n                    }\n                  }\n                }, _callee21, this);\n              }));\n\n              function patchAbsolute(_x37, _x38, _x39, _x40) {\n                return _ref21.apply(this, arguments);\n              }\n\n              return patchAbsolute;\n            }()\n          }, {\n            key: \"getAbsolute\",\n            value: function () {\n              var _ref22 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee22(url, params, onsuccess, onerror) {\n                return regeneratorRuntime.wrap(function _callee22$(_context22) {\n                  while (1) {\n                    switch (_context22.prev = _context22.next) {\n                      case 0:\n                        return _context22.abrupt(\"return\", this.httpRequest(\"get\", url, params, onsuccess, onerror));\n\n                      case 1:\n                      case \"end\":\n                        return _context22.stop();\n                    }\n                  }\n                }, _callee22, this);\n              }));\n\n              function getAbsolute(_x41, _x42, _x43, _x44) {\n                return _ref22.apply(this, arguments);\n              }\n\n              return getAbsolute;\n            }()\n          }, {\n            key: \"httpRequest\",\n            value: function () {\n              var _ref23 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee24(verb, url, params, onsuccess, onerror) {\n                var _this6 = this;\n\n                return regeneratorRuntime.wrap(function _callee24$(_context24) {\n                  while (1) {\n                    switch (_context24.prev = _context24.next) {\n                      case 0:\n                        return _context24.abrupt(\"return\", new Promise(function () {\n                          var _ref24 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee23(resolve, reject) {\n                            var xmlhttp;\n                            return regeneratorRuntime.wrap(function _callee23$(_context23) {\n                              while (1) {\n                                switch (_context23.prev = _context23.next) {\n                                  case 0:\n                                    xmlhttp = new XMLHttpRequest();\n\n                                    xmlhttp.onreadystatechange = function () {\n                                      if (xmlhttp.readyState == 4) {\n                                        var response = xmlhttp.responseText;\n\n                                        if (response) {\n                                          try {\n                                            response = JSON.parse(response);\n                                          } catch (e) {}\n                                        }\n\n                                        if (xmlhttp.status >= 200 && xmlhttp.status <= 299) {\n                                          _this6.$timeout(function () {\n                                            onsuccess(response);\n                                            resolve(response);\n                                          });\n                                        } else {\n                                          console.error(\"Request error:\", response);\n\n                                          _this6.$timeout(function () {\n                                            onerror(response, xmlhttp.status);\n                                            reject(response);\n                                          });\n                                        }\n                                      }\n                                    };\n\n                                    if (verb == \"get\" && Object.keys(params).length > 0) {\n                                      url = url + _this6.formatParams(params);\n                                    }\n\n                                    xmlhttp.open(verb, url, true);\n                                    _context23.next = 6;\n                                    return _this6.setAuthHeadersForRequest(xmlhttp);\n\n                                  case 6:\n                                    xmlhttp.setRequestHeader('Content-type', 'application/json');\n\n                                    if (verb == \"post\" || verb == \"patch\") {\n                                      xmlhttp.send(JSON.stringify(params));\n                                    } else {\n                                      xmlhttp.send();\n                                    }\n\n                                  case 8:\n                                  case \"end\":\n                                    return _context23.stop();\n                                }\n                              }\n                            }, _callee23, _this6);\n                          }));\n\n                          return function (_x50, _x51) {\n                            return _ref24.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 1:\n                      case \"end\":\n                        return _context24.stop();\n                    }\n                  }\n                }, _callee24, this);\n              }));\n\n              function httpRequest(_x45, _x46, _x47, _x48, _x49) {\n                return _ref23.apply(this, arguments);\n              }\n\n              return httpRequest;\n            }()\n          }, {\n            key: \"formatParams\",\n            value: function formatParams(params) {\n              return \"?\" + Object.keys(params).map(function (key) {\n                return key + \"=\" + encodeURIComponent(params[key]);\n              }).join(\"&\");\n            }\n          }]);\n\n          return SFHttpManager;\n        }();\n\n        ;\n\n        var SFMigrationManager = exports.SFMigrationManager = function () {\n          function SFMigrationManager(modelManager, syncManager, storageManager, authManager) {\n            var _this7 = this;\n\n            _classCallCheck(this, SFMigrationManager);\n\n            this.modelManager = modelManager;\n            this.syncManager = syncManager;\n            this.storageManager = storageManager;\n            this.completionHandlers = [];\n            this.loadMigrations(); // The syncManager used to dispatch a param called 'initialSync' in the 'sync:completed' event\n            // to let us know of the first sync completion after login.\n            // however it was removed as it was deemed to be unreliable (returned wrong value when a single sync request repeats on completion for pagination)\n            // We'll now use authManager's events instead\n\n            var didReceiveSignInEvent = false;\n            var signInHandler = authManager.addEventHandler(function (event) {\n              if (event == SFAuthManager.DidSignInEvent) {\n                didReceiveSignInEvent = true;\n              }\n            });\n            this.syncManager.addEventHandler(function () {\n              var _ref25 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee25(event, data) {\n                var dataLoadedEvent, syncCompleteEvent, completedList, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, migrationName, migration;\n\n                return regeneratorRuntime.wrap(function _callee25$(_context25) {\n                  while (1) {\n                    switch (_context25.prev = _context25.next) {\n                      case 0:\n                        dataLoadedEvent = event == \"local-data-loaded\";\n                        syncCompleteEvent = event == \"sync:completed\";\n\n                        if (!(dataLoadedEvent || syncCompleteEvent)) {\n                          _context25.next = 40;\n                          break;\n                        }\n\n                        if (dataLoadedEvent) {\n                          _this7.receivedLocalDataEvent = true;\n                        } else if (syncCompleteEvent) {\n                          _this7.receivedSyncCompletedEvent = true;\n                        } // We want to run pending migrations only after local data has been loaded, and a sync has been completed.\n\n\n                        if (!(_this7.receivedLocalDataEvent && _this7.receivedSyncCompletedEvent)) {\n                          _context25.next = 40;\n                          break;\n                        }\n\n                        if (!didReceiveSignInEvent) {\n                          _context25.next = 39;\n                          break;\n                        } // Reset our collected state about sign in\n\n\n                        didReceiveSignInEvent = false;\n                        authManager.removeEventHandler(signInHandler); // If initial online sync, clear any completed migrations that occurred while offline,\n                        // so they can run again now that we have updated user items. Only clear migrations that\n                        // don't have `runOnlyOnce` set\n\n                        _context25.next = 10;\n                        return _this7.getCompletedMigrations();\n\n                      case 10:\n                        completedList = _context25.sent.slice();\n                        _iteratorNormalCompletion2 = true;\n                        _didIteratorError2 = false;\n                        _iteratorError2 = undefined;\n                        _context25.prev = 14;\n                        _iterator2 = completedList[Symbol.iterator]();\n\n                      case 16:\n                        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                          _context25.next = 25;\n                          break;\n                        }\n\n                        migrationName = _step2.value;\n                        _context25.next = 20;\n                        return _this7.migrationForEncodedName(migrationName);\n\n                      case 20:\n                        migration = _context25.sent;\n\n                        if (!migration.runOnlyOnce) {\n                          _.pull(_this7._completed, migrationName);\n                        }\n\n                      case 22:\n                        _iteratorNormalCompletion2 = true;\n                        _context25.next = 16;\n                        break;\n\n                      case 25:\n                        _context25.next = 31;\n                        break;\n\n                      case 27:\n                        _context25.prev = 27;\n                        _context25.t0 = _context25[\"catch\"](14);\n                        _didIteratorError2 = true;\n                        _iteratorError2 = _context25.t0;\n\n                      case 31:\n                        _context25.prev = 31;\n                        _context25.prev = 32;\n\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                          _iterator2.return();\n                        }\n\n                      case 34:\n                        _context25.prev = 34;\n\n                        if (!_didIteratorError2) {\n                          _context25.next = 37;\n                          break;\n                        }\n\n                        throw _iteratorError2;\n\n                      case 37:\n                        return _context25.finish(34);\n\n                      case 38:\n                        return _context25.finish(31);\n\n                      case 39:\n                        _this7.runPendingMigrations();\n\n                      case 40:\n                      case \"end\":\n                        return _context25.stop();\n                    }\n                  }\n                }, _callee25, _this7, [[14, 27, 31, 39], [32,, 34, 38]]);\n              }));\n\n              return function (_x52, _x53) {\n                return _ref25.apply(this, arguments);\n              };\n            }());\n          }\n\n          _createClass(SFMigrationManager, [{\n            key: \"addCompletionHandler\",\n            value: function addCompletionHandler(handler) {\n              this.completionHandlers.push(handler);\n            }\n          }, {\n            key: \"removeCompletionHandler\",\n            value: function removeCompletionHandler(handler) {\n              _.pull(this.completionHandlers, handler);\n            }\n          }, {\n            key: \"migrationForEncodedName\",\n            value: function () {\n              var _ref26 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee26(name) {\n                var decoded;\n                return regeneratorRuntime.wrap(function _callee26$(_context26) {\n                  while (1) {\n                    switch (_context26.prev = _context26.next) {\n                      case 0:\n                        _context26.next = 2;\n                        return this.decode(name);\n\n                      case 2:\n                        decoded = _context26.sent;\n                        return _context26.abrupt(\"return\", this.migrations.find(function (migration) {\n                          return migration.name == decoded;\n                        }));\n\n                      case 4:\n                      case \"end\":\n                        return _context26.stop();\n                    }\n                  }\n                }, _callee26, this);\n              }));\n\n              function migrationForEncodedName(_x54) {\n                return _ref26.apply(this, arguments);\n              }\n\n              return migrationForEncodedName;\n            }()\n          }, {\n            key: \"loadMigrations\",\n            value: function loadMigrations() {\n              this.migrations = this.registeredMigrations();\n            }\n          }, {\n            key: \"registeredMigrations\",\n            value: function registeredMigrations() {// Subclasses should return an array of migrations here.\n              // Migrations should have a unique `name`, `content_type`,\n              // and `handler`, which is a function that accepts an array of matching items to migration.\n            }\n          }, {\n            key: \"runPendingMigrations\",\n            value: function () {\n              var _ref27 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee27() {\n                var pending, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, migration, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, item, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, handler;\n\n                return regeneratorRuntime.wrap(function _callee27$(_context27) {\n                  while (1) {\n                    switch (_context27.prev = _context27.next) {\n                      case 0:\n                        _context27.next = 2;\n                        return this.getPendingMigrations();\n\n                      case 2:\n                        pending = _context27.sent; // run in pre loop, keeping in mind that a migration may be run twice: when offline then again when signing in.\n                        // we need to reset the items to a new array.\n\n                        _iteratorNormalCompletion3 = true;\n                        _didIteratorError3 = false;\n                        _iteratorError3 = undefined;\n                        _context27.prev = 6;\n\n                        for (_iterator3 = pending[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                          migration = _step3.value;\n                          migration.items = [];\n                        }\n\n                        _context27.next = 14;\n                        break;\n\n                      case 10:\n                        _context27.prev = 10;\n                        _context27.t0 = _context27[\"catch\"](6);\n                        _didIteratorError3 = true;\n                        _iteratorError3 = _context27.t0;\n\n                      case 14:\n                        _context27.prev = 14;\n                        _context27.prev = 15;\n\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                          _iterator3.return();\n                        }\n\n                      case 17:\n                        _context27.prev = 17;\n\n                        if (!_didIteratorError3) {\n                          _context27.next = 20;\n                          break;\n                        }\n\n                        throw _iteratorError3;\n\n                      case 20:\n                        return _context27.finish(17);\n\n                      case 21:\n                        return _context27.finish(14);\n\n                      case 22:\n                        _iteratorNormalCompletion4 = true;\n                        _didIteratorError4 = false;\n                        _iteratorError4 = undefined;\n                        _context27.prev = 25;\n                        _iterator4 = this.modelManager.allNondummyItems[Symbol.iterator]();\n\n                      case 27:\n                        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n                          _context27.next = 51;\n                          break;\n                        }\n\n                        item = _step4.value;\n                        _iteratorNormalCompletion7 = true;\n                        _didIteratorError7 = false;\n                        _iteratorError7 = undefined;\n                        _context27.prev = 32;\n\n                        for (_iterator7 = pending[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                          migration = _step7.value;\n\n                          if (item.content_type == migration.content_type) {\n                            migration.items.push(item);\n                          }\n                        }\n\n                        _context27.next = 40;\n                        break;\n\n                      case 36:\n                        _context27.prev = 36;\n                        _context27.t1 = _context27[\"catch\"](32);\n                        _didIteratorError7 = true;\n                        _iteratorError7 = _context27.t1;\n\n                      case 40:\n                        _context27.prev = 40;\n                        _context27.prev = 41;\n\n                        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                          _iterator7.return();\n                        }\n\n                      case 43:\n                        _context27.prev = 43;\n\n                        if (!_didIteratorError7) {\n                          _context27.next = 46;\n                          break;\n                        }\n\n                        throw _iteratorError7;\n\n                      case 46:\n                        return _context27.finish(43);\n\n                      case 47:\n                        return _context27.finish(40);\n\n                      case 48:\n                        _iteratorNormalCompletion4 = true;\n                        _context27.next = 27;\n                        break;\n\n                      case 51:\n                        _context27.next = 57;\n                        break;\n\n                      case 53:\n                        _context27.prev = 53;\n                        _context27.t2 = _context27[\"catch\"](25);\n                        _didIteratorError4 = true;\n                        _iteratorError4 = _context27.t2;\n\n                      case 57:\n                        _context27.prev = 57;\n                        _context27.prev = 58;\n\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                          _iterator4.return();\n                        }\n\n                      case 60:\n                        _context27.prev = 60;\n\n                        if (!_didIteratorError4) {\n                          _context27.next = 63;\n                          break;\n                        }\n\n                        throw _iteratorError4;\n\n                      case 63:\n                        return _context27.finish(60);\n\n                      case 64:\n                        return _context27.finish(57);\n\n                      case 65:\n                        _iteratorNormalCompletion5 = true;\n                        _didIteratorError5 = false;\n                        _iteratorError5 = undefined;\n                        _context27.prev = 68;\n                        _iterator5 = pending[Symbol.iterator]();\n\n                      case 70:\n                        if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {\n                          _context27.next = 81;\n                          break;\n                        }\n\n                        migration = _step5.value;\n\n                        if (!(migration.items && migration.items.length > 0 || migration.customHandler)) {\n                          _context27.next = 77;\n                          break;\n                        }\n\n                        _context27.next = 75;\n                        return this.runMigration(migration, migration.items);\n\n                      case 75:\n                        _context27.next = 78;\n                        break;\n\n                      case 77:\n                        this.markMigrationCompleted(migration);\n\n                      case 78:\n                        _iteratorNormalCompletion5 = true;\n                        _context27.next = 70;\n                        break;\n\n                      case 81:\n                        _context27.next = 87;\n                        break;\n\n                      case 83:\n                        _context27.prev = 83;\n                        _context27.t3 = _context27[\"catch\"](68);\n                        _didIteratorError5 = true;\n                        _iteratorError5 = _context27.t3;\n\n                      case 87:\n                        _context27.prev = 87;\n                        _context27.prev = 88;\n\n                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                          _iterator5.return();\n                        }\n\n                      case 90:\n                        _context27.prev = 90;\n\n                        if (!_didIteratorError5) {\n                          _context27.next = 93;\n                          break;\n                        }\n\n                        throw _iteratorError5;\n\n                      case 93:\n                        return _context27.finish(90);\n\n                      case 94:\n                        return _context27.finish(87);\n\n                      case 95:\n                        _iteratorNormalCompletion6 = true;\n                        _didIteratorError6 = false;\n                        _iteratorError6 = undefined;\n                        _context27.prev = 98;\n\n                        for (_iterator6 = this.completionHandlers[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                          handler = _step6.value;\n                          handler();\n                        }\n\n                        _context27.next = 106;\n                        break;\n\n                      case 102:\n                        _context27.prev = 102;\n                        _context27.t4 = _context27[\"catch\"](98);\n                        _didIteratorError6 = true;\n                        _iteratorError6 = _context27.t4;\n\n                      case 106:\n                        _context27.prev = 106;\n                        _context27.prev = 107;\n\n                        if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                          _iterator6.return();\n                        }\n\n                      case 109:\n                        _context27.prev = 109;\n\n                        if (!_didIteratorError6) {\n                          _context27.next = 112;\n                          break;\n                        }\n\n                        throw _iteratorError6;\n\n                      case 112:\n                        return _context27.finish(109);\n\n                      case 113:\n                        return _context27.finish(106);\n\n                      case 114:\n                      case \"end\":\n                        return _context27.stop();\n                    }\n                  }\n                }, _callee27, this, [[6, 10, 14, 22], [15,, 17, 21], [25, 53, 57, 65], [32, 36, 40, 48], [41,, 43, 47], [58,, 60, 64], [68, 83, 87, 95], [88,, 90, 94], [98, 102, 106, 114], [107,, 109, 113]]);\n              }));\n\n              function runPendingMigrations() {\n                return _ref27.apply(this, arguments);\n              }\n\n              return runPendingMigrations;\n            }()\n          }, {\n            key: \"encode\",\n            value: function () {\n              var _ref28 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee28(text) {\n                return regeneratorRuntime.wrap(function _callee28$(_context28) {\n                  while (1) {\n                    switch (_context28.prev = _context28.next) {\n                      case 0:\n                        return _context28.abrupt(\"return\", window.btoa(text));\n\n                      case 1:\n                      case \"end\":\n                        return _context28.stop();\n                    }\n                  }\n                }, _callee28, this);\n              }));\n\n              function encode(_x55) {\n                return _ref28.apply(this, arguments);\n              }\n\n              return encode;\n            }()\n          }, {\n            key: \"decode\",\n            value: function () {\n              var _ref29 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee29(text) {\n                return regeneratorRuntime.wrap(function _callee29$(_context29) {\n                  while (1) {\n                    switch (_context29.prev = _context29.next) {\n                      case 0:\n                        return _context29.abrupt(\"return\", window.atob(text));\n\n                      case 1:\n                      case \"end\":\n                        return _context29.stop();\n                    }\n                  }\n                }, _callee29, this);\n              }));\n\n              function decode(_x56) {\n                return _ref29.apply(this, arguments);\n              }\n\n              return decode;\n            }()\n          }, {\n            key: \"getCompletedMigrations\",\n            value: function () {\n              var _ref30 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee30() {\n                var rawCompleted;\n                return regeneratorRuntime.wrap(function _callee30$(_context30) {\n                  while (1) {\n                    switch (_context30.prev = _context30.next) {\n                      case 0:\n                        if (this._completed) {\n                          _context30.next = 5;\n                          break;\n                        }\n\n                        _context30.next = 3;\n                        return this.storageManager.getItem(\"migrations\");\n\n                      case 3:\n                        rawCompleted = _context30.sent;\n\n                        if (rawCompleted) {\n                          this._completed = JSON.parse(rawCompleted);\n                        } else {\n                          this._completed = [];\n                        }\n\n                      case 5:\n                        return _context30.abrupt(\"return\", this._completed);\n\n                      case 6:\n                      case \"end\":\n                        return _context30.stop();\n                    }\n                  }\n                }, _callee30, this);\n              }));\n\n              function getCompletedMigrations() {\n                return _ref30.apply(this, arguments);\n              }\n\n              return getCompletedMigrations;\n            }()\n          }, {\n            key: \"getPendingMigrations\",\n            value: function () {\n              var _ref31 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee31() {\n                var completed, pending, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, migration;\n\n                return regeneratorRuntime.wrap(function _callee31$(_context31) {\n                  while (1) {\n                    switch (_context31.prev = _context31.next) {\n                      case 0:\n                        _context31.next = 2;\n                        return this.getCompletedMigrations();\n\n                      case 2:\n                        completed = _context31.sent;\n                        pending = [];\n                        _iteratorNormalCompletion8 = true;\n                        _didIteratorError8 = false;\n                        _iteratorError8 = undefined;\n                        _context31.prev = 7;\n                        _iterator8 = this.migrations[Symbol.iterator]();\n\n                      case 9:\n                        if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {\n                          _context31.next = 22;\n                          break;\n                        }\n\n                        migration = _step8.value;\n                        _context31.t0 = completed;\n                        _context31.next = 14;\n                        return this.encode(migration.name);\n\n                      case 14:\n                        _context31.t1 = _context31.sent;\n                        _context31.t2 = _context31.t0.indexOf.call(_context31.t0, _context31.t1);\n                        _context31.t3 = -1;\n\n                        if (!(_context31.t2 == _context31.t3)) {\n                          _context31.next = 19;\n                          break;\n                        }\n\n                        pending.push(migration);\n\n                      case 19:\n                        _iteratorNormalCompletion8 = true;\n                        _context31.next = 9;\n                        break;\n\n                      case 22:\n                        _context31.next = 28;\n                        break;\n\n                      case 24:\n                        _context31.prev = 24;\n                        _context31.t4 = _context31[\"catch\"](7);\n                        _didIteratorError8 = true;\n                        _iteratorError8 = _context31.t4;\n\n                      case 28:\n                        _context31.prev = 28;\n                        _context31.prev = 29;\n\n                        if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                          _iterator8.return();\n                        }\n\n                      case 31:\n                        _context31.prev = 31;\n\n                        if (!_didIteratorError8) {\n                          _context31.next = 34;\n                          break;\n                        }\n\n                        throw _iteratorError8;\n\n                      case 34:\n                        return _context31.finish(31);\n\n                      case 35:\n                        return _context31.finish(28);\n\n                      case 36:\n                        return _context31.abrupt(\"return\", pending);\n\n                      case 37:\n                      case \"end\":\n                        return _context31.stop();\n                    }\n                  }\n                }, _callee31, this, [[7, 24, 28, 36], [29,, 31, 35]]);\n              }));\n\n              function getPendingMigrations() {\n                return _ref31.apply(this, arguments);\n              }\n\n              return getPendingMigrations;\n            }()\n          }, {\n            key: \"markMigrationCompleted\",\n            value: function () {\n              var _ref32 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee32(migration) {\n                var completed;\n                return regeneratorRuntime.wrap(function _callee32$(_context32) {\n                  while (1) {\n                    switch (_context32.prev = _context32.next) {\n                      case 0:\n                        _context32.next = 2;\n                        return this.getCompletedMigrations();\n\n                      case 2:\n                        completed = _context32.sent;\n                        _context32.t0 = completed;\n                        _context32.next = 6;\n                        return this.encode(migration.name);\n\n                      case 6:\n                        _context32.t1 = _context32.sent;\n\n                        _context32.t0.push.call(_context32.t0, _context32.t1);\n\n                        this.storageManager.setItem(\"migrations\", JSON.stringify(completed));\n                        migration.running = false;\n\n                      case 10:\n                      case \"end\":\n                        return _context32.stop();\n                    }\n                  }\n                }, _callee32, this);\n              }));\n\n              function markMigrationCompleted(_x57) {\n                return _ref32.apply(this, arguments);\n              }\n\n              return markMigrationCompleted;\n            }()\n          }, {\n            key: \"runMigration\",\n            value: function () {\n              var _ref33 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee33(migration, items) {\n                var _this8 = this;\n\n                return regeneratorRuntime.wrap(function _callee33$(_context33) {\n                  while (1) {\n                    switch (_context33.prev = _context33.next) {\n                      case 0:\n                        if (!migration.running) {\n                          _context33.next = 2;\n                          break;\n                        }\n\n                        return _context33.abrupt(\"return\");\n\n                      case 2:\n                        console.log(\"Running migration:\", migration.name);\n                        migration.running = true;\n\n                        if (!migration.customHandler) {\n                          _context33.next = 8;\n                          break;\n                        }\n\n                        return _context33.abrupt(\"return\", migration.customHandler().then(function () {\n                          _this8.markMigrationCompleted(migration);\n                        }));\n\n                      case 8:\n                        return _context33.abrupt(\"return\", migration.handler(items).then(function () {\n                          _this8.markMigrationCompleted(migration);\n                        }));\n\n                      case 9:\n                      case \"end\":\n                        return _context33.stop();\n                    }\n                  }\n                }, _callee33, this);\n              }));\n\n              function runMigration(_x58, _x59) {\n                return _ref33.apply(this, arguments);\n              }\n\n              return runMigration;\n            }()\n          }]);\n\n          return SFMigrationManager;\n        }();\n\n        ;\n\n        var SFModelManager = exports.SFModelManager = function () {\n          function SFModelManager(timeout) {\n            _classCallCheck(this, SFModelManager);\n\n            SFModelManager.MappingSourceRemoteRetrieved = \"MappingSourceRemoteRetrieved\";\n            SFModelManager.MappingSourceRemoteSaved = \"MappingSourceRemoteSaved\";\n            SFModelManager.MappingSourceLocalSaved = \"MappingSourceLocalSaved\";\n            SFModelManager.MappingSourceLocalRetrieved = \"MappingSourceLocalRetrieved\";\n            SFModelManager.MappingSourceComponentRetrieved = \"MappingSourceComponentRetrieved\";\n            SFModelManager.MappingSourceDesktopInstalled = \"MappingSourceDesktopInstalled\"; // When a component is installed by the desktop and some of its values change\n\n            SFModelManager.MappingSourceRemoteActionRetrieved = \"MappingSourceRemoteActionRetrieved\";\n            /* aciton-based Extensions like note history */\n\n            SFModelManager.MappingSourceFileImport = \"MappingSourceFileImport\";\n\n            SFModelManager.isMappingSourceRetrieved = function (source) {\n              return [SFModelManager.MappingSourceRemoteRetrieved, SFModelManager.MappingSourceComponentRetrieved, SFModelManager.MappingSourceRemoteActionRetrieved].includes(source);\n            };\n\n            this.$timeout = timeout || setTimeout.bind(window);\n            this.itemSyncObservers = [];\n            this.itemsPendingRemoval = [];\n            this.items = [];\n            this.itemsHash = {};\n            this.missedReferences = {};\n            this.uuidChangeObservers = [];\n          }\n\n          _createClass(SFModelManager, [{\n            key: \"handleSignout\",\n            value: function handleSignout() {\n              this.items.length = 0;\n              this.itemsHash = {};\n              this.itemsPendingRemoval.length = 0;\n              this.missedReferences = {};\n            }\n          }, {\n            key: \"addModelUuidChangeObserver\",\n            value: function addModelUuidChangeObserver(id, callback) {\n              this.uuidChangeObservers.push({\n                id: id,\n                callback: callback\n              });\n            }\n          }, {\n            key: \"notifyObserversOfUuidChange\",\n            value: function notifyObserversOfUuidChange(oldItem, newItem) {\n              var _iteratorNormalCompletion9 = true;\n              var _didIteratorError9 = false;\n              var _iteratorError9 = undefined;\n\n              try {\n                for (var _iterator9 = this.uuidChangeObservers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                  var observer = _step9.value;\n                  observer.callback(oldItem, newItem);\n                }\n              } catch (err) {\n                _didIteratorError9 = true;\n                _iteratorError9 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                    _iterator9.return();\n                  }\n                } finally {\n                  if (_didIteratorError9) {\n                    throw _iteratorError9;\n                  }\n                }\n              }\n            }\n          }, {\n            key: \"alternateUUIDForItem\",\n            value: function () {\n              var _ref34 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee34(item) {\n                var newItem, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, referencingObject;\n\n                return regeneratorRuntime.wrap(function _callee34$(_context34) {\n                  while (1) {\n                    switch (_context34.prev = _context34.next) {\n                      case 0:\n                        // We need to clone this item and give it a new uuid, then delete item with old uuid from db (you can't modify uuid's in our indexeddb setup)\n                        newItem = this.createItem(item, true);\n                        _context34.next = 3;\n                        return SFJS.crypto.generateUUID();\n\n                      case 3:\n                        newItem.uuid = _context34.sent; // Update uuids of relationships\n\n                        newItem.informReferencesOfUUIDChange(item.uuid, newItem.uuid);\n                        this.informModelsOfUUIDChangeForItem(newItem, item.uuid, newItem.uuid); // the new item should inherit the original's relationships\n\n                        _iteratorNormalCompletion10 = true;\n                        _didIteratorError10 = false;\n                        _iteratorError10 = undefined;\n                        _context34.prev = 9;\n\n                        for (_iterator10 = item.referencingObjects[Symbol.iterator](); !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                          referencingObject = _step10.value;\n                          referencingObject.setIsNoLongerBeingReferencedBy(item);\n                          item.setIsNoLongerBeingReferencedBy(referencingObject);\n                          referencingObject.addItemAsRelationship(newItem);\n                          referencingObject.setDirty(true);\n                        } // Used to set up referencingObjects for new item (so that other items can now properly reference this new item)\n\n\n                        _context34.next = 17;\n                        break;\n\n                      case 13:\n                        _context34.prev = 13;\n                        _context34.t0 = _context34[\"catch\"](9);\n                        _didIteratorError10 = true;\n                        _iteratorError10 = _context34.t0;\n\n                      case 17:\n                        _context34.prev = 17;\n                        _context34.prev = 18;\n\n                        if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                          _iterator10.return();\n                        }\n\n                      case 20:\n                        _context34.prev = 20;\n\n                        if (!_didIteratorError10) {\n                          _context34.next = 23;\n                          break;\n                        }\n\n                        throw _iteratorError10;\n\n                      case 23:\n                        return _context34.finish(20);\n\n                      case 24:\n                        return _context34.finish(17);\n\n                      case 25:\n                        this.resolveReferencesForItem(newItem);\n                        console.log(item.uuid, \"-->\", newItem.uuid); // Set to deleted, then run through mapping function so that observers can be notified\n\n                        item.deleted = true;\n                        item.content.references = []; // Don't set dirty, because we don't need to sync old item. alternating uuid only occurs in two cases:\n                        // signing in and merging offline data, or when a uuid-conflict occurs. In both cases, the original item never\n                        // saves to a server, so doesn't need to be synced.\n                        // informModelsOfUUIDChangeForItem may set this object to dirty, but we want to undo that here, so that the item gets deleted\n                        // right away through the mapping function.\n\n                        item.setDirty(false);\n                        this.mapResponseItemsToLocalModels([item], SFModelManager.MappingSourceLocalSaved); // add new item\n\n                        this.addItem(newItem);\n                        newItem.setDirty(true);\n                        this.notifyObserversOfUuidChange(item, newItem);\n                        return _context34.abrupt(\"return\", newItem);\n\n                      case 35:\n                      case \"end\":\n                        return _context34.stop();\n                    }\n                  }\n                }, _callee34, this, [[9, 13, 17, 25], [18,, 20, 24]]);\n              }));\n\n              function alternateUUIDForItem(_x60) {\n                return _ref34.apply(this, arguments);\n              }\n\n              return alternateUUIDForItem;\n            }()\n          }, {\n            key: \"informModelsOfUUIDChangeForItem\",\n            value: function informModelsOfUUIDChangeForItem(newItem, oldUUID, newUUID) {\n              // some models that only have one-way relationships might be interested to hear that an item has changed its uuid\n              // for example, editors have a one way relationship with notes. When a note changes its UUID, it has no way to inform the editor\n              // to update its relationships\n              var _iteratorNormalCompletion11 = true;\n              var _didIteratorError11 = false;\n              var _iteratorError11 = undefined;\n\n              try {\n                for (var _iterator11 = this.items[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                  var model = _step11.value;\n                  model.potentialItemOfInterestHasChangedItsUUID(newItem, oldUUID, newUUID);\n                }\n              } catch (err) {\n                _didIteratorError11 = true;\n                _iteratorError11 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                    _iterator11.return();\n                  }\n                } finally {\n                  if (_didIteratorError11) {\n                    throw _iteratorError11;\n                  }\n                }\n              }\n            }\n          }, {\n            key: \"didSyncModelsOffline\",\n            value: function didSyncModelsOffline(items) {\n              this.notifySyncObserversOfModels(items, SFModelManager.MappingSourceLocalSaved);\n            }\n          }, {\n            key: \"mapResponseItemsToLocalModels\",\n            value: function mapResponseItemsToLocalModels(items, source, sourceKey) {\n              return this.mapResponseItemsToLocalModelsWithOptions({\n                items: items,\n                source: source,\n                sourceKey: sourceKey\n              });\n            }\n          }, {\n            key: \"mapResponseItemsToLocalModelsOmittingFields\",\n            value: function mapResponseItemsToLocalModelsOmittingFields(items, omitFields, source, sourceKey) {\n              return this.mapResponseItemsToLocalModelsWithOptions({\n                items: items,\n                omitFields: omitFields,\n                source: source,\n                sourceKey: sourceKey\n              });\n            }\n          }, {\n            key: \"mapResponseItemsToLocalModelsWithOptions\",\n            value: function mapResponseItemsToLocalModelsWithOptions(_ref35) {\n              var items = _ref35.items,\n                  omitFields = _ref35.omitFields,\n                  source = _ref35.source,\n                  sourceKey = _ref35.sourceKey,\n                  options = _ref35.options;\n              var models = [],\n                  processedObjects = [],\n                  modelsToNotifyObserversOf = []; // first loop should add and process items\n\n              var _iteratorNormalCompletion12 = true;\n              var _didIteratorError12 = false;\n              var _iteratorError12 = undefined;\n\n              try {\n                for (var _iterator12 = items[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                  var json_obj = _step12.value;\n\n                  if (!json_obj) {\n                    continue;\n                  } // content is missing if it has been sucessfullly decrypted but no content\n\n\n                  var isMissingContent = !json_obj.content && !json_obj.errorDecrypting;\n                  var isCorrupt = !json_obj.content_type || !json_obj.uuid;\n\n                  if ((isCorrupt || isMissingContent) && !json_obj.deleted) {\n                    // An item that is not deleted should never have empty content\n                    console.error(\"Server response item is corrupt:\", json_obj);\n                    continue;\n                  } // Lodash's _.omit, which was previously used, seems to cause unexpected behavior\n                  // when json_obj is an ES6 item class. So we instead manually omit each key.\n\n\n                  if (Array.isArray(omitFields)) {\n                    var _iteratorNormalCompletion15 = true;\n                    var _didIteratorError15 = false;\n                    var _iteratorError15 = undefined;\n\n                    try {\n                      for (var _iterator15 = omitFields[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                        var key = _step15.value;\n                        delete json_obj[key];\n                      }\n                    } catch (err) {\n                      _didIteratorError15 = true;\n                      _iteratorError15 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                          _iterator15.return();\n                        }\n                      } finally {\n                        if (_didIteratorError15) {\n                          throw _iteratorError15;\n                        }\n                      }\n                    }\n                  }\n\n                  var item = this.findItem(json_obj.uuid);\n\n                  if (item) {\n                    item.updateFromJSON(json_obj); // If an item goes through mapping, it can no longer be a dummy.\n\n                    item.dummy = false;\n                  }\n\n                  if (this.itemsPendingRemoval.includes(json_obj.uuid)) {\n                    _.pull(this.itemsPendingRemoval, json_obj.uuid);\n\n                    continue;\n                  }\n\n                  var contentType = json_obj[\"content_type\"] || item && item.content_type;\n                  var unknownContentType = this.acceptableContentTypes && !this.acceptableContentTypes.includes(contentType);\n\n                  if (unknownContentType) {\n                    continue;\n                  }\n\n                  var isDirtyItemPendingDelete = false;\n\n                  if (json_obj.deleted == true) {\n                    if (json_obj.dirty) {\n                      // Item was marked as deleted but not yet synced\n                      // We need to create this item as usual, but just not add it to individual arrays\n                      // i.e add to this.items but not this.notes (so that it can be retrieved with getDirtyItems)\n                      isDirtyItemPendingDelete = true;\n                    } else {\n                      if (item) {\n                        modelsToNotifyObserversOf.push(item);\n                        this.removeItemLocally(item);\n                      }\n\n                      continue;\n                    }\n                  }\n\n                  if (!item) {\n                    item = this.createItem(json_obj, true);\n                  }\n\n                  this.addItem(item, isDirtyItemPendingDelete); // Observers do not need to handle items that errored while decrypting.\n\n                  if (!item.errorDecrypting) {\n                    modelsToNotifyObserversOf.push(item);\n                  }\n\n                  models.push(item);\n                  processedObjects.push(json_obj);\n                } // second loop should process references\n\n              } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                    _iterator12.return();\n                  }\n                } finally {\n                  if (_didIteratorError12) {\n                    throw _iteratorError12;\n                  }\n                }\n              }\n\n              var _iteratorNormalCompletion13 = true;\n              var _didIteratorError13 = false;\n              var _iteratorError13 = undefined;\n\n              try {\n                for (var _iterator13 = processedObjects.entries()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                  var _ref36 = _step13.value;\n\n                  var _ref37 = _slicedToArray(_ref36, 2);\n\n                  var index = _ref37[0];\n                  var _json_obj = _ref37[1];\n                  var model = models[index];\n\n                  if (_json_obj.content) {\n                    this.resolveReferencesForItem(model);\n                  }\n\n                  model.didFinishSyncing();\n                }\n              } catch (err) {\n                _didIteratorError13 = true;\n                _iteratorError13 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                    _iterator13.return();\n                  }\n                } finally {\n                  if (_didIteratorError13) {\n                    throw _iteratorError13;\n                  }\n                }\n              }\n\n              var missedRefs = this.popMissedReferenceStructsForObjects(processedObjects);\n\n              var _loop = function _loop(ref) {\n                var model = models.find(function (candidate) {\n                  return candidate.uuid == ref.reference_uuid;\n                }); // Model should 100% be defined here, but let's not be too overconfident\n\n                if (model) {\n                  var itemWaitingForTheValueInThisCurrentLoop = ref.for_item;\n                  itemWaitingForTheValueInThisCurrentLoop.addItemAsRelationship(model);\n                }\n              };\n\n              var _iteratorNormalCompletion14 = true;\n              var _didIteratorError14 = false;\n              var _iteratorError14 = undefined;\n\n              try {\n                for (var _iterator14 = missedRefs[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                  var ref = _step14.value;\n\n                  _loop(ref);\n                }\n              } catch (err) {\n                _didIteratorError14 = true;\n                _iteratorError14 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                    _iterator14.return();\n                  }\n                } finally {\n                  if (_didIteratorError14) {\n                    throw _iteratorError14;\n                  }\n                }\n              }\n\n              this.notifySyncObserversOfModels(modelsToNotifyObserversOf, source, sourceKey);\n              return models;\n            }\n          }, {\n            key: \"missedReferenceBuildKey\",\n            value: function missedReferenceBuildKey(referenceId, objectId) {\n              return referenceId + \":\" + objectId;\n            }\n          }, {\n            key: \"popMissedReferenceStructsForObjects\",\n            value: function popMissedReferenceStructsForObjects(objects) {\n              if (!objects || objects.length == 0) {\n                return [];\n              }\n\n              var results = [];\n              var toDelete = [];\n              var uuids = objects.map(function (item) {\n                return item.uuid;\n              });\n              var genericUuidLength = uuids[0].length;\n              var keys = Object.keys(this.missedReferences);\n              var _iteratorNormalCompletion16 = true;\n              var _didIteratorError16 = false;\n              var _iteratorError16 = undefined;\n\n              try {\n                for (var _iterator16 = keys[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                  var candidateKey = _step16.value;\n                  /*\n                  We used to do string.split to get at the UUID, but surprisingly,\n                  the performance of this was about 20x worse then just getting the substring.\n                   let matches = candidateKey.split(\":\")[0] == object.uuid;\n                  */\n\n                  var matches = uuids.includes(candidateKey.substring(0, genericUuidLength));\n\n                  if (matches) {\n                    results.push(this.missedReferences[candidateKey]);\n                    toDelete.push(candidateKey);\n                  }\n                } // remove from hash\n\n              } catch (err) {\n                _didIteratorError16 = true;\n                _iteratorError16 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                    _iterator16.return();\n                  }\n                } finally {\n                  if (_didIteratorError16) {\n                    throw _iteratorError16;\n                  }\n                }\n              }\n\n              var _iteratorNormalCompletion17 = true;\n              var _didIteratorError17 = false;\n              var _iteratorError17 = undefined;\n\n              try {\n                for (var _iterator17 = toDelete[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                  var key = _step17.value;\n                  delete this.missedReferences[key];\n                }\n              } catch (err) {\n                _didIteratorError17 = true;\n                _iteratorError17 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion17 && _iterator17.return) {\n                    _iterator17.return();\n                  }\n                } finally {\n                  if (_didIteratorError17) {\n                    throw _iteratorError17;\n                  }\n                }\n              }\n\n              return results;\n            }\n          }, {\n            key: \"resolveReferencesForItem\",\n            value: function resolveReferencesForItem(item) {\n              var markReferencesDirty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n              if (item.errorDecrypting) {\n                return;\n              } // console.log(\"resolveReferencesForItem\", item, \"references\", item.contentObject.references);\n\n\n              var contentObject = item.contentObject; // If another client removes an item's references, this client won't pick up the removal unless\n              // we remove everything not present in the current list of references\n\n              item.updateLocalRelationships();\n\n              if (!contentObject.references) {\n                return;\n              }\n\n              var references = contentObject.references.slice(); // make copy, references will be modified in array\n\n              var referencesIds = references.map(function (ref) {\n                return ref.uuid;\n              });\n              var includeBlanks = true;\n              var referencesObjectResults = this.findItems(referencesIds, includeBlanks);\n              var _iteratorNormalCompletion18 = true;\n              var _didIteratorError18 = false;\n              var _iteratorError18 = undefined;\n\n              try {\n                for (var _iterator18 = referencesObjectResults.entries()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n                  var _ref38 = _step18.value;\n\n                  var _ref39 = _slicedToArray(_ref38, 2);\n\n                  var index = _ref39[0];\n                  var referencedItem = _ref39[1];\n\n                  if (referencedItem) {\n                    item.addItemAsRelationship(referencedItem);\n\n                    if (markReferencesDirty) {\n                      referencedItem.setDirty(true);\n                    }\n                  } else {\n                    var missingRefId = referencesIds[index]; // Allows mapper to check when missing reference makes it through the loop,\n                    // and then runs resolveReferencesForItem again for the original item.\n\n                    var mappingKey = this.missedReferenceBuildKey(missingRefId, item.uuid);\n\n                    if (!this.missedReferences[mappingKey]) {\n                      var missedRef = {\n                        reference_uuid: missingRefId,\n                        for_item: item\n                      };\n                      this.missedReferences[mappingKey] = missedRef;\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError18 = true;\n                _iteratorError18 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion18 && _iterator18.return) {\n                    _iterator18.return();\n                  }\n                } finally {\n                  if (_didIteratorError18) {\n                    throw _iteratorError18;\n                  }\n                }\n              }\n            }\n            /* Note that this function is public, and can also be called manually (desktopManager uses it) */\n\n          }, {\n            key: \"notifySyncObserversOfModels\",\n            value: function notifySyncObserversOfModels(models, source, sourceKey) {\n              var _this9 = this; // Make sure `let` is used in the for loops instead of `var`, as we will be using a timeout below.\n\n\n              var observers = this.itemSyncObservers.sort(function (a, b) {\n                // sort by priority\n                return a.priority < b.priority ? -1 : 1;\n              });\n\n              var _loop2 = function _loop2(observer) {\n                var allRelevantItems = observer.types.includes(\"*\") ? models : models.filter(function (item) {\n                  return observer.types.includes(item.content_type);\n                });\n                var validItems = [],\n                    deletedItems = [];\n                var _iteratorNormalCompletion20 = true;\n                var _didIteratorError20 = false;\n                var _iteratorError20 = undefined;\n\n                try {\n                  for (var _iterator20 = allRelevantItems[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n                    var item = _step20.value;\n\n                    if (item.deleted) {\n                      deletedItems.push(item);\n                    } else {\n                      validItems.push(item);\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError20 = true;\n                  _iteratorError20 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion20 && _iterator20.return) {\n                      _iterator20.return();\n                    }\n                  } finally {\n                    if (_didIteratorError20) {\n                      throw _iteratorError20;\n                    }\n                  }\n                }\n\n                if (allRelevantItems.length > 0) {\n                  _this9._callSyncObserverCallbackWithTimeout(observer, allRelevantItems, validItems, deletedItems, source, sourceKey);\n                }\n              };\n\n              var _iteratorNormalCompletion19 = true;\n              var _didIteratorError19 = false;\n              var _iteratorError19 = undefined;\n\n              try {\n                for (var _iterator19 = observers[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n                  var observer = _step19.value;\n\n                  _loop2(observer);\n                }\n              } catch (err) {\n                _didIteratorError19 = true;\n                _iteratorError19 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion19 && _iterator19.return) {\n                    _iterator19.return();\n                  }\n                } finally {\n                  if (_didIteratorError19) {\n                    throw _iteratorError19;\n                  }\n                }\n              }\n            }\n            /*\n              Rather than running this inline in a for loop, which causes problems and requires all variables to be declared with `let`,\n              we'll do it here so it's more explicit and less confusing.\n             */\n\n          }, {\n            key: \"_callSyncObserverCallbackWithTimeout\",\n            value: function _callSyncObserverCallbackWithTimeout(observer, allRelevantItems, validItems, deletedItems, source, sourceKey) {\n              this.$timeout(function () {\n                observer.callback(allRelevantItems, validItems, deletedItems, source, sourceKey);\n              });\n            }\n          }, {\n            key: \"createItem\",\n            value: function createItem(json_obj, dontNotifyObservers) {\n              var itemClass = SFModelManager.ContentTypeClassMapping && SFModelManager.ContentTypeClassMapping[json_obj.content_type];\n\n              if (!itemClass) {\n                itemClass = SFItem;\n              }\n\n              var item = new itemClass(json_obj); // Some observers would be interested to know when an an item is locally created\n              // If we don't send this out, these observers would have to wait until MappingSourceRemoteSaved\n              // to hear about it, but sometimes, RemoveSaved is explicitly ignored by the observer to avoid\n              // recursive callbacks. See componentManager's syncObserver callback.\n              // dontNotifyObservers is currently only set true by modelManagers mapResponseItemsToLocalModels\n\n              if (!dontNotifyObservers) {\n                this.notifySyncObserversOfModels([item], SFModelManager.MappingSourceLocalSaved);\n              }\n\n              return item;\n            }\n            /*\n              Be sure itemResponse is a generic Javascript object, and not an Item.\n              An Item needs to collapse its properties into its content object before it can be duplicated.\n              Note: the reason we need this function is specificallty for the call to resolveReferencesForItem.\n              This method creates but does not add the item to the global inventory. It's used by syncManager\n              to check if this prospective duplicate item is identical to another item, including the references.\n             */\n\n          }, {\n            key: \"createConflictedItem\",\n            value: function () {\n              var _ref40 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee35(itemResponse) {\n                var uuid, dup;\n                return regeneratorRuntime.wrap(function _callee35$(_context35) {\n                  while (1) {\n                    switch (_context35.prev = _context35.next) {\n                      case 0:\n                        _context35.next = 2;\n                        return SFJS.crypto.generateUUID();\n\n                      case 2:\n                        uuid = _context35.sent;\n                        itemResponse = _.merge(itemResponse, {\n                          uuid: uuid\n                        });\n                        dup = this.createItem(itemResponse, true);\n                        return _context35.abrupt(\"return\", dup);\n\n                      case 6:\n                      case \"end\":\n                        return _context35.stop();\n                    }\n                  }\n                }, _callee35, this);\n              }));\n\n              function createConflictedItem(_x62) {\n                return _ref40.apply(this, arguments);\n              }\n\n              return createConflictedItem;\n            }()\n          }, {\n            key: \"addConflictedItem\",\n            value: function addConflictedItem(dup, original) {\n              this.addItem(dup); // the duplicate should inherit the original's relationships\n\n              var _iteratorNormalCompletion21 = true;\n              var _didIteratorError21 = false;\n              var _iteratorError21 = undefined;\n\n              try {\n                for (var _iterator21 = original.referencingObjects[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n                  var referencingObject = _step21.value;\n                  referencingObject.addItemAsRelationship(dup);\n                  referencingObject.setDirty(true);\n                }\n              } catch (err) {\n                _didIteratorError21 = true;\n                _iteratorError21 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion21 && _iterator21.return) {\n                    _iterator21.return();\n                  }\n                } finally {\n                  if (_didIteratorError21) {\n                    throw _iteratorError21;\n                  }\n                }\n              }\n\n              this.resolveReferencesForItem(dup);\n              dup.content.conflict_of = original.uuid;\n              dup.setDirty(true);\n            }\n          }, {\n            key: \"duplicateItem\",\n            value: function duplicateItem(item) {\n              var copy = new item.constructor({\n                content: item.content\n              });\n              copy.created_at = item.created_at;\n              copy.content_type = item.content_type;\n              this.addItem(copy); // the duplicate should inherit the original's relationships\n\n              var _iteratorNormalCompletion22 = true;\n              var _didIteratorError22 = false;\n              var _iteratorError22 = undefined;\n\n              try {\n                for (var _iterator22 = item.referencingObjects[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n                  var referencingObject = _step22.value;\n                  referencingObject.addItemAsRelationship(copy);\n                  referencingObject.setDirty(true);\n                }\n              } catch (err) {\n                _didIteratorError22 = true;\n                _iteratorError22 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion22 && _iterator22.return) {\n                    _iterator22.return();\n                  }\n                } finally {\n                  if (_didIteratorError22) {\n                    throw _iteratorError22;\n                  }\n                }\n              }\n\n              this.resolveReferencesForItem(copy);\n              copy.setDirty(true);\n              return copy;\n            }\n          }, {\n            key: \"addItem\",\n            value: function addItem(item) {\n              var globalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n              this.addItems([item], globalOnly);\n            }\n          }, {\n            key: \"addItems\",\n            value: function addItems(items) {\n              var _this10 = this;\n\n              var globalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n              items.forEach(function (item) {\n                if (!_this10.itemsHash[item.uuid]) {\n                  _this10.itemsHash[item.uuid] = item;\n\n                  _this10.items.push(item);\n                }\n              });\n            }\n            /* Notifies observers when an item has been synced or mapped from a remote response */\n\n          }, {\n            key: \"addItemSyncObserver\",\n            value: function addItemSyncObserver(id, types, callback) {\n              this.addItemSyncObserverWithPriority({\n                id: id,\n                types: types,\n                callback: callback,\n                priority: 1\n              });\n            }\n          }, {\n            key: \"addItemSyncObserverWithPriority\",\n            value: function addItemSyncObserverWithPriority(_ref41) {\n              var id = _ref41.id,\n                  priority = _ref41.priority,\n                  types = _ref41.types,\n                  callback = _ref41.callback;\n\n              if (!Array.isArray(types)) {\n                types = [types];\n              }\n\n              this.itemSyncObservers.push({\n                id: id,\n                types: types,\n                priority: priority,\n                callback: callback\n              });\n            }\n          }, {\n            key: \"removeItemSyncObserver\",\n            value: function removeItemSyncObserver(id) {\n              _.remove(this.itemSyncObservers, _.find(this.itemSyncObservers, {\n                id: id\n              }));\n            }\n          }, {\n            key: \"getDirtyItems\",\n            value: function getDirtyItems() {\n              return this.items.filter(function (item) {\n                // An item that has an error decrypting can be synced only if it is being deleted.\n                // Otherwise, we don't want to send corrupt content up to the server.\n                return item.dirty == true && !item.dummy && (!item.errorDecrypting || item.deleted);\n              });\n            }\n          }, {\n            key: \"clearDirtyItems\",\n            value: function clearDirtyItems(items) {\n              var _iteratorNormalCompletion23 = true;\n              var _didIteratorError23 = false;\n              var _iteratorError23 = undefined;\n\n              try {\n                for (var _iterator23 = items[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {\n                  var item = _step23.value;\n                  item.setDirty(false);\n                }\n              } catch (err) {\n                _didIteratorError23 = true;\n                _iteratorError23 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion23 && _iterator23.return) {\n                    _iterator23.return();\n                  }\n                } finally {\n                  if (_didIteratorError23) {\n                    throw _iteratorError23;\n                  }\n                }\n              }\n            }\n          }, {\n            key: \"setItemToBeDeleted\",\n            value: function setItemToBeDeleted(item) {\n              item.deleted = true;\n\n              if (!item.dummy) {\n                item.setDirty(true);\n              }\n\n              this.removeAndDirtyAllRelationshipsForItem(item);\n            }\n          }, {\n            key: \"removeAndDirtyAllRelationshipsForItem\",\n            value: function removeAndDirtyAllRelationshipsForItem(item) {\n              // Handle direct relationships\n              // An item with errorDecrypting will not have valid content field\n              if (!item.errorDecrypting) {\n                var _iteratorNormalCompletion24 = true;\n                var _didIteratorError24 = false;\n                var _iteratorError24 = undefined;\n\n                try {\n                  for (var _iterator24 = item.content.references[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {\n                    var reference = _step24.value;\n                    var relationship = this.findItem(reference.uuid);\n\n                    if (relationship) {\n                      item.removeItemAsRelationship(relationship);\n\n                      if (relationship.hasRelationshipWithItem(item)) {\n                        relationship.removeItemAsRelationship(item);\n                        relationship.setDirty(true);\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError24 = true;\n                  _iteratorError24 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion24 && _iterator24.return) {\n                      _iterator24.return();\n                    }\n                  } finally {\n                    if (_didIteratorError24) {\n                      throw _iteratorError24;\n                    }\n                  }\n                }\n              } // Handle indirect relationships\n\n\n              var _iteratorNormalCompletion25 = true;\n              var _didIteratorError25 = false;\n              var _iteratorError25 = undefined;\n\n              try {\n                for (var _iterator25 = item.referencingObjects[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {\n                  var object = _step25.value;\n                  object.removeItemAsRelationship(item);\n                  object.setDirty(true);\n                }\n              } catch (err) {\n                _didIteratorError25 = true;\n                _iteratorError25 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion25 && _iterator25.return) {\n                    _iterator25.return();\n                  }\n                } finally {\n                  if (_didIteratorError25) {\n                    throw _iteratorError25;\n                  }\n                }\n              }\n\n              item.referencingObjects = [];\n            }\n            /* Used when changing encryption key */\n\n          }, {\n            key: \"setAllItemsDirty\",\n            value: function setAllItemsDirty() {\n              var dontUpdateClientDates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n              var relevantItems = this.allItems;\n              var _iteratorNormalCompletion26 = true;\n              var _didIteratorError26 = false;\n              var _iteratorError26 = undefined;\n\n              try {\n                for (var _iterator26 = relevantItems[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {\n                  var item = _step26.value;\n                  item.setDirty(true, dontUpdateClientDates);\n                }\n              } catch (err) {\n                _didIteratorError26 = true;\n                _iteratorError26 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion26 && _iterator26.return) {\n                    _iterator26.return();\n                  }\n                } finally {\n                  if (_didIteratorError26) {\n                    throw _iteratorError26;\n                  }\n                }\n              }\n            }\n          }, {\n            key: \"removeItemLocally\",\n            value: function () {\n              var _ref42 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee36(item) {\n                return regeneratorRuntime.wrap(function _callee36$(_context36) {\n                  while (1) {\n                    switch (_context36.prev = _context36.next) {\n                      case 0:\n                        _.remove(this.items, {\n                          uuid: item.uuid\n                        });\n\n                        delete this.itemsHash[item.uuid];\n                        item.isBeingRemovedLocally();\n                        this.itemsPendingRemoval.push(item.uuid);\n\n                      case 4:\n                      case \"end\":\n                        return _context36.stop();\n                    }\n                  }\n                }, _callee36, this);\n              }));\n\n              function removeItemLocally(_x66) {\n                return _ref42.apply(this, arguments);\n              }\n\n              return removeItemLocally;\n            }()\n            /* Searching */\n\n          }, {\n            key: \"allItemsMatchingTypes\",\n            value: function allItemsMatchingTypes(contentTypes) {\n              return this.allItems.filter(function (item) {\n                return (_.includes(contentTypes, item.content_type) || _.includes(contentTypes, \"*\")) && !item.dummy;\n              });\n            }\n          }, {\n            key: \"invalidItems\",\n            value: function invalidItems() {\n              return this.allItems.filter(function (item) {\n                return item.errorDecrypting;\n              });\n            }\n          }, {\n            key: \"validItemsForContentType\",\n            value: function validItemsForContentType(contentType) {\n              return this.allItems.filter(function (item) {\n                return item.content_type == contentType && !item.errorDecrypting;\n              });\n            }\n          }, {\n            key: \"findItem\",\n            value: function findItem(itemId) {\n              return this.itemsHash[itemId];\n            }\n          }, {\n            key: \"findItems\",\n            value: function findItems(ids) {\n              var includeBlanks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n              var results = [];\n              var _iteratorNormalCompletion27 = true;\n              var _didIteratorError27 = false;\n              var _iteratorError27 = undefined;\n\n              try {\n                for (var _iterator27 = ids[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {\n                  var id = _step27.value;\n                  var item = this.itemsHash[id];\n\n                  if (item || includeBlanks) {\n                    results.push(item);\n                  }\n                }\n              } catch (err) {\n                _didIteratorError27 = true;\n                _iteratorError27 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion27 && _iterator27.return) {\n                    _iterator27.return();\n                  }\n                } finally {\n                  if (_didIteratorError27) {\n                    throw _iteratorError27;\n                  }\n                }\n              }\n\n              return results;\n            }\n          }, {\n            key: \"itemsMatchingPredicate\",\n            value: function itemsMatchingPredicate(predicate) {\n              return this.itemsMatchingPredicates([predicate]);\n            }\n          }, {\n            key: \"itemsMatchingPredicates\",\n            value: function itemsMatchingPredicates(predicates) {\n              return this.filterItemsWithPredicates(this.allItems, predicates);\n            }\n          }, {\n            key: \"filterItemsWithPredicates\",\n            value: function filterItemsWithPredicates(items, predicates) {\n              var results = items.filter(function (item) {\n                var _iteratorNormalCompletion28 = true;\n                var _didIteratorError28 = false;\n                var _iteratorError28 = undefined;\n\n                try {\n                  for (var _iterator28 = predicates[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {\n                    var predicate = _step28.value;\n\n                    if (!item.satisfiesPredicate(predicate)) {\n                      return false;\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError28 = true;\n                  _iteratorError28 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion28 && _iterator28.return) {\n                      _iterator28.return();\n                    }\n                  } finally {\n                    if (_didIteratorError28) {\n                      throw _iteratorError28;\n                    }\n                  }\n                }\n\n                return true;\n              });\n              return results;\n            }\n            /*\n            Archives\n            */\n\n          }, {\n            key: \"importItems\",\n            value: function () {\n              var _ref43 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee37(externalItems) {\n                var itemsToBeMapped, _iteratorNormalCompletion29, _didIteratorError29, _iteratorError29, _iterator29, _step29, itemData, existing, dup, items, _iteratorNormalCompletion30, _didIteratorError30, _iteratorError30, _iterator30, _step30, item;\n\n                return regeneratorRuntime.wrap(function _callee37$(_context37) {\n                  while (1) {\n                    switch (_context37.prev = _context37.next) {\n                      case 0:\n                        itemsToBeMapped = [];\n                        _iteratorNormalCompletion29 = true;\n                        _didIteratorError29 = false;\n                        _iteratorError29 = undefined;\n                        _context37.prev = 4;\n                        _iterator29 = externalItems[Symbol.iterator]();\n\n                      case 6:\n                        if (_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done) {\n                          _context37.next = 21;\n                          break;\n                        }\n\n                        itemData = _step29.value;\n                        existing = this.findItem(itemData.uuid);\n\n                        if (!(existing && !existing.errorDecrypting)) {\n                          _context37.next = 16;\n                          break;\n                        }\n\n                        _context37.next = 12;\n                        return this.createConflictedItem(itemData);\n\n                      case 12:\n                        dup = _context37.sent;\n\n                        if (!itemData.deleted && !existing.isItemContentEqualWith(dup)) {\n                          // Data differs\n                          this.addConflictedItem(dup, existing);\n                          itemsToBeMapped.push(dup);\n                        }\n\n                        _context37.next = 18;\n                        break;\n\n                      case 16:\n                        // it doesn't exist, push it into items to be mapped\n                        itemsToBeMapped.push(itemData);\n\n                        if (existing && existing.errorDecrypting) {\n                          existing.errorDecrypting = false;\n                        }\n\n                      case 18:\n                        _iteratorNormalCompletion29 = true;\n                        _context37.next = 6;\n                        break;\n\n                      case 21:\n                        _context37.next = 27;\n                        break;\n\n                      case 23:\n                        _context37.prev = 23;\n                        _context37.t0 = _context37[\"catch\"](4);\n                        _didIteratorError29 = true;\n                        _iteratorError29 = _context37.t0;\n\n                      case 27:\n                        _context37.prev = 27;\n                        _context37.prev = 28;\n\n                        if (!_iteratorNormalCompletion29 && _iterator29.return) {\n                          _iterator29.return();\n                        }\n\n                      case 30:\n                        _context37.prev = 30;\n\n                        if (!_didIteratorError29) {\n                          _context37.next = 33;\n                          break;\n                        }\n\n                        throw _iteratorError29;\n\n                      case 33:\n                        return _context37.finish(30);\n\n                      case 34:\n                        return _context37.finish(27);\n\n                      case 35:\n                        items = this.mapResponseItemsToLocalModels(itemsToBeMapped, SFModelManager.MappingSourceFileImport);\n                        _iteratorNormalCompletion30 = true;\n                        _didIteratorError30 = false;\n                        _iteratorError30 = undefined;\n                        _context37.prev = 39;\n\n                        for (_iterator30 = items[Symbol.iterator](); !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {\n                          item = _step30.value;\n                          item.setDirty(true, true);\n                          item.deleted = false;\n                        }\n\n                        _context37.next = 47;\n                        break;\n\n                      case 43:\n                        _context37.prev = 43;\n                        _context37.t1 = _context37[\"catch\"](39);\n                        _didIteratorError30 = true;\n                        _iteratorError30 = _context37.t1;\n\n                      case 47:\n                        _context37.prev = 47;\n                        _context37.prev = 48;\n\n                        if (!_iteratorNormalCompletion30 && _iterator30.return) {\n                          _iterator30.return();\n                        }\n\n                      case 50:\n                        _context37.prev = 50;\n\n                        if (!_didIteratorError30) {\n                          _context37.next = 53;\n                          break;\n                        }\n\n                        throw _iteratorError30;\n\n                      case 53:\n                        return _context37.finish(50);\n\n                      case 54:\n                        return _context37.finish(47);\n\n                      case 55:\n                        return _context37.abrupt(\"return\", items);\n\n                      case 56:\n                      case \"end\":\n                        return _context37.stop();\n                    }\n                  }\n                }, _callee37, this, [[4, 23, 27, 35], [28,, 30, 34], [39, 43, 47, 55], [48,, 50, 54]]);\n              }));\n\n              function importItems(_x68) {\n                return _ref43.apply(this, arguments);\n              }\n\n              return importItems;\n            }()\n          }, {\n            key: \"getAllItemsJSONData\",\n            value: function () {\n              var _ref44 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee38(keys, authParams, returnNullIfEmpty) {\n                return regeneratorRuntime.wrap(function _callee38$(_context38) {\n                  while (1) {\n                    switch (_context38.prev = _context38.next) {\n                      case 0:\n                        return _context38.abrupt(\"return\", this.getJSONDataForItems(this.allItems, keys, authParams, returnNullIfEmpty));\n\n                      case 1:\n                      case \"end\":\n                        return _context38.stop();\n                    }\n                  }\n                }, _callee38, this);\n              }));\n\n              function getAllItemsJSONData(_x69, _x70, _x71) {\n                return _ref44.apply(this, arguments);\n              }\n\n              return getAllItemsJSONData;\n            }()\n          }, {\n            key: \"getJSONDataForItems\",\n            value: function () {\n              var _ref45 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee39(items, keys, authParams, returnNullIfEmpty) {\n                return regeneratorRuntime.wrap(function _callee39$(_context39) {\n                  while (1) {\n                    switch (_context39.prev = _context39.next) {\n                      case 0:\n                        return _context39.abrupt(\"return\", Promise.all(items.map(function (item) {\n                          var itemParams = new SFItemParams(item, keys, authParams);\n                          return itemParams.paramsForExportFile();\n                        })).then(function (items) {\n                          if (returnNullIfEmpty && items.length == 0) {\n                            return null;\n                          }\n\n                          var data = {\n                            items: items\n                          };\n\n                          if (keys) {\n                            // auth params are only needed when encrypted with a standard file key\n                            data[\"auth_params\"] = authParams;\n                          }\n\n                          return JSON.stringify(data, null, 2\n                          /* pretty print */\n                          );\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context39.stop();\n                    }\n                  }\n                }, _callee39, this);\n              }));\n\n              function getJSONDataForItems(_x72, _x73, _x74, _x75) {\n                return _ref45.apply(this, arguments);\n              }\n\n              return getJSONDataForItems;\n            }()\n          }, {\n            key: \"computeDataIntegrityHash\",\n            value: function () {\n              var _ref46 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee40() {\n                var items, dates, string, hash;\n                return regeneratorRuntime.wrap(function _callee40$(_context40) {\n                  while (1) {\n                    switch (_context40.prev = _context40.next) {\n                      case 0:\n                        _context40.prev = 0;\n                        items = this.allNondummyItems.sort(function (a, b) {\n                          return b.updated_at - a.updated_at;\n                        });\n                        dates = items.map(function (item) {\n                          return item.updatedAtTimestamp();\n                        });\n                        string = dates.join(\",\");\n                        _context40.next = 6;\n                        return SFJS.crypto.sha256(string);\n\n                      case 6:\n                        hash = _context40.sent;\n                        return _context40.abrupt(\"return\", hash);\n\n                      case 10:\n                        _context40.prev = 10;\n                        _context40.t0 = _context40[\"catch\"](0);\n                        console.error(\"Error computing data integrity hash\", _context40.t0);\n                        return _context40.abrupt(\"return\", null);\n\n                      case 14:\n                      case \"end\":\n                        return _context40.stop();\n                    }\n                  }\n                }, _callee40, this, [[0, 10]]);\n              }));\n\n              function computeDataIntegrityHash() {\n                return _ref46.apply(this, arguments);\n              }\n\n              return computeDataIntegrityHash;\n            }()\n          }, {\n            key: \"allItems\",\n            get: function get() {\n              return this.items.slice();\n            }\n          }, {\n            key: \"allNondummyItems\",\n            get: function get() {\n              return this.items.filter(function (item) {\n                return !item.dummy;\n              });\n            }\n          }]);\n\n          return SFModelManager;\n        }();\n\n        ;\n\n        var SFPrivilegesManager = exports.SFPrivilegesManager = function () {\n          function SFPrivilegesManager(modelManager, syncManager, singletonManager) {\n            _classCallCheck(this, SFPrivilegesManager);\n\n            this.modelManager = modelManager;\n            this.syncManager = syncManager;\n            this.singletonManager = singletonManager;\n            this.loadPrivileges();\n            SFPrivilegesManager.CredentialAccountPassword = \"CredentialAccountPassword\";\n            SFPrivilegesManager.CredentialLocalPasscode = \"CredentialLocalPasscode\";\n            SFPrivilegesManager.ActionManageExtensions = \"ActionManageExtensions\";\n            SFPrivilegesManager.ActionManageBackups = \"ActionManageBackups\";\n            SFPrivilegesManager.ActionViewProtectedNotes = \"ActionViewProtectedNotes\";\n            SFPrivilegesManager.ActionManagePrivileges = \"ActionManagePrivileges\";\n            SFPrivilegesManager.ActionManagePasscode = \"ActionManagePasscode\";\n            SFPrivilegesManager.ActionDeleteNote = \"ActionDeleteNote\";\n            SFPrivilegesManager.SessionExpiresAtKey = \"SessionExpiresAtKey\";\n            SFPrivilegesManager.SessionLengthKey = \"SessionLengthKey\";\n            SFPrivilegesManager.SessionLengthNone = 0;\n            SFPrivilegesManager.SessionLengthFiveMinutes = 300;\n            SFPrivilegesManager.SessionLengthOneHour = 3600;\n            SFPrivilegesManager.SessionLengthOneWeek = 604800;\n            this.availableActions = [SFPrivilegesManager.ActionViewProtectedNotes, SFPrivilegesManager.ActionDeleteNote, SFPrivilegesManager.ActionManagePasscode, SFPrivilegesManager.ActionManageBackups, SFPrivilegesManager.ActionManageExtensions, SFPrivilegesManager.ActionManagePrivileges];\n            this.availableCredentials = [SFPrivilegesManager.CredentialAccountPassword, SFPrivilegesManager.CredentialLocalPasscode];\n            this.sessionLengths = [SFPrivilegesManager.SessionLengthNone, SFPrivilegesManager.SessionLengthFiveMinutes, SFPrivilegesManager.SessionLengthOneHour, SFPrivilegesManager.SessionLengthOneWeek, SFPrivilegesManager.SessionLengthIndefinite];\n          }\n          /*\n          async delegate.isOffline()\n          async delegate.hasLocalPasscode()\n          async delegate.saveToStorage(key, value)\n          async delegate.getFromStorage(key)\n          async delegate.verifyAccountPassword\n          async delegate.verifyLocalPasscode\n          */\n\n\n          _createClass(SFPrivilegesManager, [{\n            key: \"setDelegate\",\n            value: function setDelegate(delegate) {\n              this.delegate = delegate;\n            }\n          }, {\n            key: \"getAvailableActions\",\n            value: function getAvailableActions() {\n              return this.availableActions;\n            }\n          }, {\n            key: \"getAvailableCredentials\",\n            value: function getAvailableCredentials() {\n              return this.availableCredentials;\n            }\n          }, {\n            key: \"netCredentialsForAction\",\n            value: function () {\n              var _ref47 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee41(action) {\n                var credentials, netCredentials, _iteratorNormalCompletion31, _didIteratorError31, _iteratorError31, _iterator31, _step31, cred, isOffline, hasLocalPasscode;\n\n                return regeneratorRuntime.wrap(function _callee41$(_context41) {\n                  while (1) {\n                    switch (_context41.prev = _context41.next) {\n                      case 0:\n                        _context41.next = 2;\n                        return this.getPrivileges();\n\n                      case 2:\n                        _context41.t0 = action;\n                        credentials = _context41.sent.getCredentialsForAction(_context41.t0);\n                        netCredentials = [];\n                        _iteratorNormalCompletion31 = true;\n                        _didIteratorError31 = false;\n                        _iteratorError31 = undefined;\n                        _context41.prev = 8;\n                        _iterator31 = credentials[Symbol.iterator]();\n\n                      case 10:\n                        if (_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done) {\n                          _context41.next = 27;\n                          break;\n                        }\n\n                        cred = _step31.value;\n\n                        if (!(cred == SFPrivilegesManager.CredentialAccountPassword)) {\n                          _context41.next = 19;\n                          break;\n                        }\n\n                        _context41.next = 15;\n                        return this.delegate.isOffline();\n\n                      case 15:\n                        isOffline = _context41.sent;\n\n                        if (!isOffline) {\n                          netCredentials.push(cred);\n                        }\n\n                        _context41.next = 24;\n                        break;\n\n                      case 19:\n                        if (!(cred == SFPrivilegesManager.CredentialLocalPasscode)) {\n                          _context41.next = 24;\n                          break;\n                        }\n\n                        _context41.next = 22;\n                        return this.delegate.hasLocalPasscode();\n\n                      case 22:\n                        hasLocalPasscode = _context41.sent;\n\n                        if (hasLocalPasscode) {\n                          netCredentials.push(cred);\n                        }\n\n                      case 24:\n                        _iteratorNormalCompletion31 = true;\n                        _context41.next = 10;\n                        break;\n\n                      case 27:\n                        _context41.next = 33;\n                        break;\n\n                      case 29:\n                        _context41.prev = 29;\n                        _context41.t1 = _context41[\"catch\"](8);\n                        _didIteratorError31 = true;\n                        _iteratorError31 = _context41.t1;\n\n                      case 33:\n                        _context41.prev = 33;\n                        _context41.prev = 34;\n\n                        if (!_iteratorNormalCompletion31 && _iterator31.return) {\n                          _iterator31.return();\n                        }\n\n                      case 36:\n                        _context41.prev = 36;\n\n                        if (!_didIteratorError31) {\n                          _context41.next = 39;\n                          break;\n                        }\n\n                        throw _iteratorError31;\n\n                      case 39:\n                        return _context41.finish(36);\n\n                      case 40:\n                        return _context41.finish(33);\n\n                      case 41:\n                        return _context41.abrupt(\"return\", netCredentials);\n\n                      case 42:\n                      case \"end\":\n                        return _context41.stop();\n                    }\n                  }\n                }, _callee41, this, [[8, 29, 33, 41], [34,, 36, 40]]);\n              }));\n\n              function netCredentialsForAction(_x76) {\n                return _ref47.apply(this, arguments);\n              }\n\n              return netCredentialsForAction;\n            }()\n          }, {\n            key: \"loadPrivileges\",\n            value: function () {\n              var _ref48 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee43() {\n                var _this11 = this;\n\n                return regeneratorRuntime.wrap(function _callee43$(_context43) {\n                  while (1) {\n                    switch (_context43.prev = _context43.next) {\n                      case 0:\n                        if (!this.loadPromise) {\n                          _context43.next = 2;\n                          break;\n                        }\n\n                        return _context43.abrupt(\"return\", this.loadPromise);\n\n                      case 2:\n                        this.loadPromise = new Promise(function (resolve, reject) {\n                          var privsContentType = SFPrivileges.contentType();\n                          var contentTypePredicate = new SFPredicate(\"content_type\", \"=\", privsContentType);\n\n                          _this11.singletonManager.registerSingleton([contentTypePredicate], function (resolvedSingleton) {\n                            _this11.privileges = resolvedSingleton;\n                            resolve(resolvedSingleton);\n                          }, function () {\n                            var _ref49 = _asyncToGenerator(\n                            /*#__PURE__*/\n                            regeneratorRuntime.mark(function _callee42(valueCallback) {\n                              var privs;\n                              return regeneratorRuntime.wrap(function _callee42$(_context42) {\n                                while (1) {\n                                  switch (_context42.prev = _context42.next) {\n                                    case 0:\n                                      // Safe to create. Create and return object.\n                                      privs = new SFPrivileges({\n                                        content_type: privsContentType\n                                      });\n\n                                      if (SFJS.crypto.generateUUIDSync) {\n                                        _context42.next = 4;\n                                        break;\n                                      }\n\n                                      _context42.next = 4;\n                                      return privs.initUUID();\n\n                                    case 4:\n                                      _this11.modelManager.addItem(privs);\n\n                                      privs.setDirty(true);\n\n                                      _this11.syncManager.sync();\n\n                                      valueCallback(privs);\n                                      resolve(privs);\n\n                                    case 9:\n                                    case \"end\":\n                                      return _context42.stop();\n                                  }\n                                }\n                              }, _callee42, _this11);\n                            }));\n\n                            return function (_x77) {\n                              return _ref49.apply(this, arguments);\n                            };\n                          }());\n                        });\n                        return _context43.abrupt(\"return\", this.loadPromise);\n\n                      case 4:\n                      case \"end\":\n                        return _context43.stop();\n                    }\n                  }\n                }, _callee43, this);\n              }));\n\n              function loadPrivileges() {\n                return _ref48.apply(this, arguments);\n              }\n\n              return loadPrivileges;\n            }()\n          }, {\n            key: \"getPrivileges\",\n            value: function () {\n              var _ref50 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee44() {\n                return regeneratorRuntime.wrap(function _callee44$(_context44) {\n                  while (1) {\n                    switch (_context44.prev = _context44.next) {\n                      case 0:\n                        if (!this.privileges) {\n                          _context44.next = 4;\n                          break;\n                        }\n\n                        return _context44.abrupt(\"return\", this.privileges);\n\n                      case 4:\n                        return _context44.abrupt(\"return\", this.loadPrivileges());\n\n                      case 5:\n                      case \"end\":\n                        return _context44.stop();\n                    }\n                  }\n                }, _callee44, this);\n              }));\n\n              function getPrivileges() {\n                return _ref50.apply(this, arguments);\n              }\n\n              return getPrivileges;\n            }()\n          }, {\n            key: \"displayInfoForCredential\",\n            value: function displayInfoForCredential(credential) {\n              var metadata = {};\n              metadata[SFPrivilegesManager.CredentialAccountPassword] = {\n                label: \"Account Password\",\n                prompt: \"Please enter your account password.\"\n              };\n              metadata[SFPrivilegesManager.CredentialLocalPasscode] = {\n                label: \"Local Passcode\",\n                prompt: \"Please enter your local passcode.\"\n              };\n              return metadata[credential];\n            }\n          }, {\n            key: \"displayInfoForAction\",\n            value: function displayInfoForAction(action) {\n              var metadata = {};\n              metadata[SFPrivilegesManager.ActionManageExtensions] = {\n                label: \"Manage Extensions\"\n              };\n              metadata[SFPrivilegesManager.ActionManageBackups] = {\n                label: \"Download/Import Backups\"\n              };\n              metadata[SFPrivilegesManager.ActionViewProtectedNotes] = {\n                label: \"View Protected Notes\"\n              };\n              metadata[SFPrivilegesManager.ActionManagePrivileges] = {\n                label: \"Manage Privileges\"\n              };\n              metadata[SFPrivilegesManager.ActionManagePasscode] = {\n                label: \"Manage Passcode\"\n              };\n              metadata[SFPrivilegesManager.ActionDeleteNote] = {\n                label: \"Delete Notes\"\n              };\n              return metadata[action];\n            }\n          }, {\n            key: \"getSessionLengthOptions\",\n            value: function getSessionLengthOptions() {\n              return [{\n                value: SFPrivilegesManager.SessionLengthNone,\n                label: \"Don't Remember\"\n              }, {\n                value: SFPrivilegesManager.SessionLengthFiveMinutes,\n                label: \"5 Minutes\"\n              }, {\n                value: SFPrivilegesManager.SessionLengthOneHour,\n                label: \"1 Hour\"\n              }, {\n                value: SFPrivilegesManager.SessionLengthOneWeek,\n                label: \"1 Week\"\n              }];\n            }\n          }, {\n            key: \"setSessionLength\",\n            value: function () {\n              var _ref51 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee45(length) {\n                var addToNow, expiresAt;\n                return regeneratorRuntime.wrap(function _callee45$(_context45) {\n                  while (1) {\n                    switch (_context45.prev = _context45.next) {\n                      case 0:\n                        addToNow = function addToNow(seconds) {\n                          var date = new Date();\n                          date.setSeconds(date.getSeconds() + seconds);\n                          return date;\n                        };\n\n                        expiresAt = addToNow(length);\n                        return _context45.abrupt(\"return\", Promise.all([this.delegate.saveToStorage(SFPrivilegesManager.SessionExpiresAtKey, JSON.stringify(expiresAt)), this.delegate.saveToStorage(SFPrivilegesManager.SessionLengthKey, JSON.stringify(length))]));\n\n                      case 3:\n                      case \"end\":\n                        return _context45.stop();\n                    }\n                  }\n                }, _callee45, this);\n              }));\n\n              function setSessionLength(_x78) {\n                return _ref51.apply(this, arguments);\n              }\n\n              return setSessionLength;\n            }()\n          }, {\n            key: \"clearSession\",\n            value: function () {\n              var _ref52 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee46() {\n                return regeneratorRuntime.wrap(function _callee46$(_context46) {\n                  while (1) {\n                    switch (_context46.prev = _context46.next) {\n                      case 0:\n                        return _context46.abrupt(\"return\", this.setSessionLength(SFPrivilegesManager.SessionLengthNone));\n\n                      case 1:\n                      case \"end\":\n                        return _context46.stop();\n                    }\n                  }\n                }, _callee46, this);\n              }));\n\n              function clearSession() {\n                return _ref52.apply(this, arguments);\n              }\n\n              return clearSession;\n            }()\n          }, {\n            key: \"getSelectedSessionLength\",\n            value: function () {\n              var _ref53 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee47() {\n                var length;\n                return regeneratorRuntime.wrap(function _callee47$(_context47) {\n                  while (1) {\n                    switch (_context47.prev = _context47.next) {\n                      case 0:\n                        _context47.next = 2;\n                        return this.delegate.getFromStorage(SFPrivilegesManager.SessionLengthKey);\n\n                      case 2:\n                        length = _context47.sent;\n\n                        if (!length) {\n                          _context47.next = 7;\n                          break;\n                        }\n\n                        return _context47.abrupt(\"return\", JSON.parse(length));\n\n                      case 7:\n                        return _context47.abrupt(\"return\", SFPrivilegesManager.SessionLengthNone);\n\n                      case 8:\n                      case \"end\":\n                        return _context47.stop();\n                    }\n                  }\n                }, _callee47, this);\n              }));\n\n              function getSelectedSessionLength() {\n                return _ref53.apply(this, arguments);\n              }\n\n              return getSelectedSessionLength;\n            }()\n          }, {\n            key: \"getSessionExpirey\",\n            value: function () {\n              var _ref54 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee48() {\n                var expiresAt;\n                return regeneratorRuntime.wrap(function _callee48$(_context48) {\n                  while (1) {\n                    switch (_context48.prev = _context48.next) {\n                      case 0:\n                        _context48.next = 2;\n                        return this.delegate.getFromStorage(SFPrivilegesManager.SessionExpiresAtKey);\n\n                      case 2:\n                        expiresAt = _context48.sent;\n\n                        if (!expiresAt) {\n                          _context48.next = 7;\n                          break;\n                        }\n\n                        return _context48.abrupt(\"return\", new Date(JSON.parse(expiresAt)));\n\n                      case 7:\n                        return _context48.abrupt(\"return\", new Date());\n\n                      case 8:\n                      case \"end\":\n                        return _context48.stop();\n                    }\n                  }\n                }, _callee48, this);\n              }));\n\n              function getSessionExpirey() {\n                return _ref54.apply(this, arguments);\n              }\n\n              return getSessionExpirey;\n            }()\n          }, {\n            key: \"actionHasPrivilegesConfigured\",\n            value: function () {\n              var _ref55 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee49(action) {\n                return regeneratorRuntime.wrap(function _callee49$(_context49) {\n                  while (1) {\n                    switch (_context49.prev = _context49.next) {\n                      case 0:\n                        _context49.next = 2;\n                        return this.netCredentialsForAction(action);\n\n                      case 2:\n                        _context49.t0 = _context49.sent.length;\n                        return _context49.abrupt(\"return\", _context49.t0 > 0);\n\n                      case 4:\n                      case \"end\":\n                        return _context49.stop();\n                    }\n                  }\n                }, _callee49, this);\n              }));\n\n              function actionHasPrivilegesConfigured(_x79) {\n                return _ref55.apply(this, arguments);\n              }\n\n              return actionHasPrivilegesConfigured;\n            }()\n          }, {\n            key: \"actionRequiresPrivilege\",\n            value: function () {\n              var _ref56 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee50(action) {\n                var expiresAt, netCredentials;\n                return regeneratorRuntime.wrap(function _callee50$(_context50) {\n                  while (1) {\n                    switch (_context50.prev = _context50.next) {\n                      case 0:\n                        _context50.next = 2;\n                        return this.getSessionExpirey();\n\n                      case 2:\n                        expiresAt = _context50.sent;\n\n                        if (!(expiresAt > new Date())) {\n                          _context50.next = 5;\n                          break;\n                        }\n\n                        return _context50.abrupt(\"return\", false);\n\n                      case 5:\n                        _context50.next = 7;\n                        return this.netCredentialsForAction(action);\n\n                      case 7:\n                        netCredentials = _context50.sent;\n                        return _context50.abrupt(\"return\", netCredentials.length > 0);\n\n                      case 9:\n                      case \"end\":\n                        return _context50.stop();\n                    }\n                  }\n                }, _callee50, this);\n              }));\n\n              function actionRequiresPrivilege(_x80) {\n                return _ref56.apply(this, arguments);\n              }\n\n              return actionRequiresPrivilege;\n            }()\n          }, {\n            key: \"savePrivileges\",\n            value: function () {\n              var _ref57 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee51() {\n                var privs;\n                return regeneratorRuntime.wrap(function _callee51$(_context51) {\n                  while (1) {\n                    switch (_context51.prev = _context51.next) {\n                      case 0:\n                        _context51.next = 2;\n                        return this.getPrivileges();\n\n                      case 2:\n                        privs = _context51.sent;\n                        privs.setDirty(true);\n                        this.syncManager.sync();\n\n                      case 5:\n                      case \"end\":\n                        return _context51.stop();\n                    }\n                  }\n                }, _callee51, this);\n              }));\n\n              function savePrivileges() {\n                return _ref57.apply(this, arguments);\n              }\n\n              return savePrivileges;\n            }()\n          }, {\n            key: \"authenticateAction\",\n            value: function () {\n              var _ref58 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee52(action, credentialAuthMapping) {\n                var requiredCredentials, successfulCredentials, failedCredentials, _iteratorNormalCompletion32, _didIteratorError32, _iteratorError32, _iterator32, _step32, requiredCredential, passesAuth;\n\n                return regeneratorRuntime.wrap(function _callee52$(_context52) {\n                  while (1) {\n                    switch (_context52.prev = _context52.next) {\n                      case 0:\n                        _context52.next = 2;\n                        return this.netCredentialsForAction(action);\n\n                      case 2:\n                        requiredCredentials = _context52.sent;\n                        successfulCredentials = [], failedCredentials = [];\n                        _iteratorNormalCompletion32 = true;\n                        _didIteratorError32 = false;\n                        _iteratorError32 = undefined;\n                        _context52.prev = 7;\n                        _iterator32 = requiredCredentials[Symbol.iterator]();\n\n                      case 9:\n                        if (_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done) {\n                          _context52.next = 18;\n                          break;\n                        }\n\n                        requiredCredential = _step32.value;\n                        _context52.next = 13;\n                        return this._verifyAuthenticationParameters(requiredCredential, credentialAuthMapping[requiredCredential]);\n\n                      case 13:\n                        passesAuth = _context52.sent;\n\n                        if (passesAuth) {\n                          successfulCredentials.push(requiredCredential);\n                        } else {\n                          failedCredentials.push(requiredCredential);\n                        }\n\n                      case 15:\n                        _iteratorNormalCompletion32 = true;\n                        _context52.next = 9;\n                        break;\n\n                      case 18:\n                        _context52.next = 24;\n                        break;\n\n                      case 20:\n                        _context52.prev = 20;\n                        _context52.t0 = _context52[\"catch\"](7);\n                        _didIteratorError32 = true;\n                        _iteratorError32 = _context52.t0;\n\n                      case 24:\n                        _context52.prev = 24;\n                        _context52.prev = 25;\n\n                        if (!_iteratorNormalCompletion32 && _iterator32.return) {\n                          _iterator32.return();\n                        }\n\n                      case 27:\n                        _context52.prev = 27;\n\n                        if (!_didIteratorError32) {\n                          _context52.next = 30;\n                          break;\n                        }\n\n                        throw _iteratorError32;\n\n                      case 30:\n                        return _context52.finish(27);\n\n                      case 31:\n                        return _context52.finish(24);\n\n                      case 32:\n                        return _context52.abrupt(\"return\", {\n                          success: failedCredentials.length == 0,\n                          successfulCredentials: successfulCredentials,\n                          failedCredentials: failedCredentials\n                        });\n\n                      case 33:\n                      case \"end\":\n                        return _context52.stop();\n                    }\n                  }\n                }, _callee52, this, [[7, 20, 24, 32], [25,, 27, 31]]);\n              }));\n\n              function authenticateAction(_x81, _x82) {\n                return _ref58.apply(this, arguments);\n              }\n\n              return authenticateAction;\n            }()\n          }, {\n            key: \"_verifyAuthenticationParameters\",\n            value: function () {\n              var _ref59 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee55(credential, value) {\n                var _this12 = this;\n\n                var verifyAccountPassword, verifyLocalPasscode;\n                return regeneratorRuntime.wrap(function _callee55$(_context55) {\n                  while (1) {\n                    switch (_context55.prev = _context55.next) {\n                      case 0:\n                        verifyAccountPassword = function () {\n                          var _ref60 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee53(password) {\n                            return regeneratorRuntime.wrap(function _callee53$(_context53) {\n                              while (1) {\n                                switch (_context53.prev = _context53.next) {\n                                  case 0:\n                                    return _context53.abrupt(\"return\", _this12.delegate.verifyAccountPassword(password));\n\n                                  case 1:\n                                  case \"end\":\n                                    return _context53.stop();\n                                }\n                              }\n                            }, _callee53, _this12);\n                          }));\n\n                          return function verifyAccountPassword(_x85) {\n                            return _ref60.apply(this, arguments);\n                          };\n                        }();\n\n                        verifyLocalPasscode = function () {\n                          var _ref61 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee54(passcode) {\n                            return regeneratorRuntime.wrap(function _callee54$(_context54) {\n                              while (1) {\n                                switch (_context54.prev = _context54.next) {\n                                  case 0:\n                                    return _context54.abrupt(\"return\", _this12.delegate.verifyLocalPasscode(passcode));\n\n                                  case 1:\n                                  case \"end\":\n                                    return _context54.stop();\n                                }\n                              }\n                            }, _callee54, _this12);\n                          }));\n\n                          return function verifyLocalPasscode(_x86) {\n                            return _ref61.apply(this, arguments);\n                          };\n                        }();\n\n                        if (!(credential == SFPrivilegesManager.CredentialAccountPassword)) {\n                          _context55.next = 6;\n                          break;\n                        }\n\n                        return _context55.abrupt(\"return\", verifyAccountPassword(value));\n\n                      case 6:\n                        if (!(credential == SFPrivilegesManager.CredentialLocalPasscode)) {\n                          _context55.next = 8;\n                          break;\n                        }\n\n                        return _context55.abrupt(\"return\", verifyLocalPasscode(value));\n\n                      case 8:\n                      case \"end\":\n                        return _context55.stop();\n                    }\n                  }\n                }, _callee55, this);\n              }));\n\n              function _verifyAuthenticationParameters(_x83, _x84) {\n                return _ref59.apply(this, arguments);\n              }\n\n              return _verifyAuthenticationParameters;\n            }()\n          }]);\n\n          return SFPrivilegesManager;\n        }();\n\n        ;\n        var SessionHistoryPersistKey = \"sessionHistory_persist\";\n        var SessionHistoryRevisionsKey = \"sessionHistory_revisions\";\n        var SessionHistoryAutoOptimizeKey = \"sessionHistory_autoOptimize\";\n\n        var SFSessionHistoryManager = exports.SFSessionHistoryManager = function () {\n          function SFSessionHistoryManager(modelManager, storageManager, keyRequestHandler, contentTypes, timeout) {\n            var _this13 = this;\n\n            _classCallCheck(this, SFSessionHistoryManager);\n\n            this.modelManager = modelManager;\n            this.storageManager = storageManager;\n            this.$timeout = timeout || setTimeout.bind(window); // Required to persist the encrypted form of SFHistorySession\n\n            this.keyRequestHandler = keyRequestHandler;\n            this.loadFromDisk().then(function () {\n              _this13.modelManager.addItemSyncObserver(\"session-history\", contentTypes, function (allItems, validItems, deletedItems, source, sourceKey) {\n                var _iteratorNormalCompletion33 = true;\n                var _didIteratorError33 = false;\n                var _iteratorError33 = undefined;\n\n                try {\n                  for (var _iterator33 = allItems[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {\n                    var item = _step33.value;\n\n                    try {\n                      _this13.addHistoryEntryForItem(item);\n                    } catch (e) {\n                      console.log(\"Caught exception while trying to add item history entry\", e);\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError33 = true;\n                  _iteratorError33 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion33 && _iterator33.return) {\n                      _iterator33.return();\n                    }\n                  } finally {\n                    if (_didIteratorError33) {\n                      throw _iteratorError33;\n                    }\n                  }\n                }\n              });\n            });\n          }\n\n          _createClass(SFSessionHistoryManager, [{\n            key: \"encryptionParams\",\n            value: function () {\n              var _ref62 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee56() {\n                return regeneratorRuntime.wrap(function _callee56$(_context56) {\n                  while (1) {\n                    switch (_context56.prev = _context56.next) {\n                      case 0:\n                        return _context56.abrupt(\"return\", this.keyRequestHandler());\n\n                      case 1:\n                      case \"end\":\n                        return _context56.stop();\n                    }\n                  }\n                }, _callee56, this);\n              }));\n\n              function encryptionParams() {\n                return _ref62.apply(this, arguments);\n              }\n\n              return encryptionParams;\n            }()\n          }, {\n            key: \"addHistoryEntryForItem\",\n            value: function addHistoryEntryForItem(item) {\n              var _this14 = this;\n\n              var persistableItemParams = {\n                uuid: item.uuid,\n                content_type: item.content_type,\n                updated_at: item.updated_at,\n                content: item.content\n              };\n              var entry = this.historySession.addEntryForItem(persistableItemParams);\n\n              if (this.autoOptimize) {\n                this.historySession.optimizeHistoryForItem(item);\n              }\n\n              if (entry && this.diskEnabled) {\n                // Debounce, clear existing timeout\n                if (this.diskTimeout) {\n                  if (this.$timeout.hasOwnProperty(\"cancel\")) {\n                    this.$timeout.cancel(this.diskTimeout);\n                  } else {\n                    clearTimeout(this.diskTimeout);\n                  }\n                }\n\n                ;\n                this.diskTimeout = this.$timeout(function () {\n                  _this14.saveToDisk();\n                }, 2000);\n              }\n            }\n          }, {\n            key: \"historyForItem\",\n            value: function historyForItem(item) {\n              return this.historySession.historyForItem(item);\n            }\n          }, {\n            key: \"clearHistoryForItem\",\n            value: function () {\n              var _ref63 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee57(item) {\n                return regeneratorRuntime.wrap(function _callee57$(_context57) {\n                  while (1) {\n                    switch (_context57.prev = _context57.next) {\n                      case 0:\n                        this.historySession.clearItemHistory(item);\n                        return _context57.abrupt(\"return\", this.saveToDisk());\n\n                      case 2:\n                      case \"end\":\n                        return _context57.stop();\n                    }\n                  }\n                }, _callee57, this);\n              }));\n\n              function clearHistoryForItem(_x87) {\n                return _ref63.apply(this, arguments);\n              }\n\n              return clearHistoryForItem;\n            }()\n          }, {\n            key: \"clearAllHistory\",\n            value: function () {\n              var _ref64 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee58() {\n                return regeneratorRuntime.wrap(function _callee58$(_context58) {\n                  while (1) {\n                    switch (_context58.prev = _context58.next) {\n                      case 0:\n                        this.historySession.clearAllHistory();\n                        return _context58.abrupt(\"return\", this.storageManager.removeItem(SessionHistoryRevisionsKey));\n\n                      case 2:\n                      case \"end\":\n                        return _context58.stop();\n                    }\n                  }\n                }, _callee58, this);\n              }));\n\n              function clearAllHistory() {\n                return _ref64.apply(this, arguments);\n              }\n\n              return clearAllHistory;\n            }()\n          }, {\n            key: \"toggleDiskSaving\",\n            value: function () {\n              var _ref65 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee59() {\n                return regeneratorRuntime.wrap(function _callee59$(_context59) {\n                  while (1) {\n                    switch (_context59.prev = _context59.next) {\n                      case 0:\n                        this.diskEnabled = !this.diskEnabled;\n\n                        if (!this.diskEnabled) {\n                          _context59.next = 6;\n                          break;\n                        }\n\n                        this.storageManager.setItem(SessionHistoryPersistKey, JSON.stringify(true));\n                        this.saveToDisk();\n                        _context59.next = 8;\n                        break;\n\n                      case 6:\n                        this.storageManager.setItem(SessionHistoryPersistKey, JSON.stringify(false));\n                        return _context59.abrupt(\"return\", this.storageManager.removeItem(SessionHistoryRevisionsKey));\n\n                      case 8:\n                      case \"end\":\n                        return _context59.stop();\n                    }\n                  }\n                }, _callee59, this);\n              }));\n\n              function toggleDiskSaving() {\n                return _ref65.apply(this, arguments);\n              }\n\n              return toggleDiskSaving;\n            }()\n          }, {\n            key: \"saveToDisk\",\n            value: function () {\n              var _ref66 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee60() {\n                var _this15 = this;\n\n                var encryptionParams, itemParams;\n                return regeneratorRuntime.wrap(function _callee60$(_context60) {\n                  while (1) {\n                    switch (_context60.prev = _context60.next) {\n                      case 0:\n                        if (this.diskEnabled) {\n                          _context60.next = 2;\n                          break;\n                        }\n\n                        return _context60.abrupt(\"return\");\n\n                      case 2:\n                        _context60.next = 4;\n                        return this.encryptionParams();\n\n                      case 4:\n                        encryptionParams = _context60.sent;\n                        itemParams = new SFItemParams(this.historySession, encryptionParams.keys, encryptionParams.auth_params);\n                        itemParams.paramsForSync().then(function (syncParams) {\n                          // console.log(\"Saving to disk\", syncParams);\n                          _this15.storageManager.setItem(SessionHistoryRevisionsKey, JSON.stringify(syncParams));\n                        });\n\n                      case 7:\n                      case \"end\":\n                        return _context60.stop();\n                    }\n                  }\n                }, _callee60, this);\n              }));\n\n              function saveToDisk() {\n                return _ref66.apply(this, arguments);\n              }\n\n              return saveToDisk;\n            }()\n          }, {\n            key: \"loadFromDisk\",\n            value: function () {\n              var _ref67 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee61() {\n                var diskValue, historyValue, encryptionParams, historySession, autoOptimizeValue;\n                return regeneratorRuntime.wrap(function _callee61$(_context61) {\n                  while (1) {\n                    switch (_context61.prev = _context61.next) {\n                      case 0:\n                        _context61.next = 2;\n                        return this.storageManager.getItem(SessionHistoryPersistKey);\n\n                      case 2:\n                        diskValue = _context61.sent;\n\n                        if (diskValue) {\n                          this.diskEnabled = JSON.parse(diskValue);\n                        }\n\n                        _context61.next = 6;\n                        return this.storageManager.getItem(SessionHistoryRevisionsKey);\n\n                      case 6:\n                        historyValue = _context61.sent;\n\n                        if (!historyValue) {\n                          _context61.next = 18;\n                          break;\n                        }\n\n                        historyValue = JSON.parse(historyValue);\n                        _context61.next = 11;\n                        return this.encryptionParams();\n\n                      case 11:\n                        encryptionParams = _context61.sent;\n                        _context61.next = 14;\n                        return SFJS.itemTransformer.decryptItem(historyValue, encryptionParams.keys);\n\n                      case 14:\n                        historySession = new SFHistorySession(historyValue);\n                        this.historySession = historySession;\n                        _context61.next = 19;\n                        break;\n\n                      case 18:\n                        this.historySession = new SFHistorySession();\n\n                      case 19:\n                        _context61.next = 21;\n                        return this.storageManager.getItem(SessionHistoryAutoOptimizeKey);\n\n                      case 21:\n                        autoOptimizeValue = _context61.sent;\n\n                        if (autoOptimizeValue) {\n                          this.autoOptimize = JSON.parse(autoOptimizeValue);\n                        } else {\n                          // default value is true\n                          this.autoOptimize = true;\n                        }\n\n                      case 23:\n                      case \"end\":\n                        return _context61.stop();\n                    }\n                  }\n                }, _callee61, this);\n              }));\n\n              function loadFromDisk() {\n                return _ref67.apply(this, arguments);\n              }\n\n              return loadFromDisk;\n            }()\n          }, {\n            key: \"toggleAutoOptimize\",\n            value: function () {\n              var _ref68 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee62() {\n                return regeneratorRuntime.wrap(function _callee62$(_context62) {\n                  while (1) {\n                    switch (_context62.prev = _context62.next) {\n                      case 0:\n                        this.autoOptimize = !this.autoOptimize;\n\n                        if (this.autoOptimize) {\n                          this.storageManager.setItem(SessionHistoryAutoOptimizeKey, JSON.stringify(true));\n                        } else {\n                          this.storageManager.setItem(SessionHistoryAutoOptimizeKey, JSON.stringify(false));\n                        }\n\n                      case 2:\n                      case \"end\":\n                        return _context62.stop();\n                    }\n                  }\n                }, _callee62, this);\n              }));\n\n              function toggleAutoOptimize() {\n                return _ref68.apply(this, arguments);\n              }\n\n              return toggleAutoOptimize;\n            }()\n          }]);\n\n          return SFSessionHistoryManager;\n        }();\n\n        ;\n        /*\n         The SingletonManager allows controllers to register an item as a singleton, which means only one instance of that model\n         should exist, both on the server and on the client. When the SingletonManager detects multiple items matching the singleton predicate,\n         the oldest ones will be deleted, leaving the newest ones. (See 4/28/18 update. We now choose the earliest created one as the winner.).\n          (This no longer fully applies, See 4/28/18 update.) We will treat the model most recently arrived from the server as the most recent one. The reason for this is,\n         if you're offline, a singleton can be created, as in the case of UserPreferneces. Then when you sign in, you'll retrieve your actual user preferences.\n         In that case, even though the offline singleton has a more recent updated_at, the server retreived value is the one we care more about.\n          4/28/18: I'm seeing this issue: if you have the app open in one window, then in another window sign in, and during sign in,\n         click Refresh (or autorefresh occurs) in the original signed in window, then you will happen to receive from the server the newly created\n         Extensions singleton, and it will be mistaken (it just looks like a regular retrieved item, since nothing is in saved) for a fresh, latest copy, and replace the current instance.\n         This has happened to me and many users.\n         A puzzling issue, but what if instead of resolving singletons by choosing the one most recently modified, we choose the one with the earliest create date?\n         This way, we don't care when it was modified, but we always, always choose the item that was created first. This way, we always deal with the same item.\n        */\n\n        var SFSingletonManager = exports.SFSingletonManager = function () {\n          function SFSingletonManager(modelManager, syncManager) {\n            var _this16 = this;\n\n            _classCallCheck(this, SFSingletonManager);\n\n            this.syncManager = syncManager;\n            this.modelManager = modelManager;\n            this.singletonHandlers = []; // We use sync observer instead of syncEvent `local-data-incremental-load`, because we want singletons\n            // to resolve with the first priority, because they generally dictate app state.\n            // If we used local-data-incremental-load, and 1 item was important singleton and 99 were heavy components,\n            // then given the random nature of notifiying observers, the heavy components would spend a lot of time loading first,\n            // here, we priortize ours loading as most important\n\n            modelManager.addItemSyncObserverWithPriority({\n              id: \"sf-singleton-manager\",\n              types: \"*\",\n              priority: -1,\n              callback: function callback() {\n                _this16.resolveSingletons(modelManager.allNondummyItems, null, true);\n              }\n            });\n            syncManager.addEventHandler(function (syncEvent, data) {\n              if (syncEvent == \"local-data-loaded\") {\n                _this16.resolveSingletons(modelManager.allNondummyItems, null, true);\n\n                _this16.initialDataLoaded = true;\n              } else if (syncEvent == \"sync:completed\") {\n                // Wait for initial data load before handling any sync. If we don't want for initial data load,\n                // then the singleton resolver won't have the proper items to work with to determine whether to resolve or create.\n                if (!_this16.initialDataLoaded) {\n                  return;\n                } // The reason we also need to consider savedItems in consolidating singletons is in case of sync conflicts,\n                // a new item can be created, but is never processed through \"retrievedItems\" since it is only created locally then saved.\n                // HOWEVER, by considering savedItems, we are now ruining everything, especially during sign in. A singleton can be created\n                // offline, and upon sign in, will sync all items to the server, and by combining retrievedItems & savedItems, and only choosing\n                // the latest, you are now resolving to the most recent one, which is in the savedItems list and not retrieved items, defeating\n                // the whole purpose of this thing.\n                // Updated solution: resolveSingletons will now evaluate both of these arrays separately.\n\n\n                _this16.resolveSingletons(data.retrievedItems, data.savedItems);\n              }\n            });\n            /*\n              If an item alternates its uuid on registration, singletonHandlers might need to update\n              their local reference to the object, since the object reference will change on uuid alternation\n            */\n\n            modelManager.addModelUuidChangeObserver(\"singleton-manager\", function (oldModel, newModel) {\n              var _iteratorNormalCompletion34 = true;\n              var _didIteratorError34 = false;\n              var _iteratorError34 = undefined;\n\n              try {\n                for (var _iterator34 = _this16.singletonHandlers[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {\n                  var handler = _step34.value;\n\n                  if (handler.singleton && SFPredicate.ItemSatisfiesPredicates(newModel, handler.predicates)) {\n                    // Reference is now invalid, calling resolveSingleton should update it\n                    handler.singleton = null;\n\n                    _this16.resolveSingletons([newModel]);\n                  }\n                }\n              } catch (err) {\n                _didIteratorError34 = true;\n                _iteratorError34 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion34 && _iterator34.return) {\n                    _iterator34.return();\n                  }\n                } finally {\n                  if (_didIteratorError34) {\n                    throw _iteratorError34;\n                  }\n                }\n              }\n            });\n          }\n\n          _createClass(SFSingletonManager, [{\n            key: \"registerSingleton\",\n            value: function registerSingleton(predicates, resolveCallback, createBlock) {\n              /*\n              predicate: a key/value pair that specifies properties that should match in order for an item to be considered a predicate\n              resolveCallback: called when one or more items are deleted and a new item becomes the reigning singleton\n              createBlock: called when a sync is complete and no items are found. The createBlock should create the item and return it.\n              */\n              this.singletonHandlers.push({\n                predicates: predicates,\n                resolutionCallback: resolveCallback,\n                createBlock: createBlock\n              });\n            }\n          }, {\n            key: \"resolveSingletons\",\n            value: function resolveSingletons(retrievedItems, savedItems, initialLoad) {\n              var _this17 = this;\n\n              retrievedItems = retrievedItems || [];\n              savedItems = savedItems || [];\n\n              var _loop3 = function _loop3(singletonHandler) {\n                var predicates = singletonHandler.predicates.slice();\n\n                var retrievedSingletonItems = _this17.modelManager.filterItemsWithPredicates(retrievedItems, predicates);\n\n                var handleCreation = function handleCreation() {\n                  if (singletonHandler.createBlock) {\n                    singletonHandler.pendingCreateBlockCallback = true;\n                    singletonHandler.createBlock(function (created) {\n                      singletonHandler.singleton = created;\n                      singletonHandler.pendingCreateBlockCallback = false;\n                      singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(created);\n                    });\n                  }\n                }; // We only want to consider saved items count to see if it's more than 0, and do nothing else with it.\n                // This way we know there was some action and things need to be resolved. The saved items will come up\n                // in filterItemsWithPredicate(this.modelManager.allNondummyItems) and be deleted anyway\n\n\n                var savedSingletonItemsCount = _this17.modelManager.filterItemsWithPredicates(savedItems, predicates).length;\n\n                if (retrievedSingletonItems.length > 0 || savedSingletonItemsCount > 0) {\n                  /*\n                    Check local inventory and make sure only 1 similar item exists. If more than 1, delete newest\n                    Note that this local inventory will also contain whatever is in retrievedItems.\n                  */\n                  var allExtantItemsMatchingPredicate = _this17.modelManager.itemsMatchingPredicates(predicates);\n                  /*\n                    Delete all but the earliest created\n                  */\n\n\n                  if (allExtantItemsMatchingPredicate.length >= 2) {\n                    var sorted = allExtantItemsMatchingPredicate.sort(function (a, b) {\n                      /*\n                        If compareFunction(a, b) is less than 0, sort a to an index lower than b, i.e. a comes first.\n                        If compareFunction(a, b) is greater than 0, sort b to an index lower than a, i.e. b comes first.\n                      */\n                      if (a.errorDecrypting) {\n                        return 1;\n                      }\n\n                      if (b.errorDecrypting) {\n                        return -1;\n                      }\n\n                      return a.created_at < b.created_at ? -1 : 1;\n                    }); // The item that will be chosen to be kept\n\n                    var winningItem = sorted[0]; // Items that will be deleted\n                    // Delete everything but the first one\n\n                    var toDelete = sorted.slice(1, sorted.length);\n                    var _iteratorNormalCompletion36 = true;\n                    var _didIteratorError36 = false;\n                    var _iteratorError36 = undefined;\n\n                    try {\n                      for (var _iterator36 = toDelete[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {\n                        var d = _step36.value;\n\n                        _this17.modelManager.setItemToBeDeleted(d);\n                      }\n                    } catch (err) {\n                      _didIteratorError36 = true;\n                      _iteratorError36 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion36 && _iterator36.return) {\n                          _iterator36.return();\n                        }\n                      } finally {\n                        if (_didIteratorError36) {\n                          throw _iteratorError36;\n                        }\n                      }\n                    }\n\n                    _this17.syncManager.sync(); // Send remaining item to callback\n\n\n                    singletonHandler.singleton = winningItem;\n                    singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(winningItem);\n                  } else if (allExtantItemsMatchingPredicate.length == 1) {\n                    var singleton = allExtantItemsMatchingPredicate[0];\n\n                    if (singleton.errorDecrypting) {\n                      // Delete the current singleton and create a new one\n                      _this17.modelManager.setItemToBeDeleted(singleton);\n\n                      handleCreation();\n                    } else if (!singletonHandler.singleton || singletonHandler.singleton !== singleton) {\n                      // Not yet notified interested parties of object\n                      singletonHandler.singleton = singleton;\n                      singletonHandler.resolutionCallback && singletonHandler.resolutionCallback(singleton);\n                    }\n                  }\n                } else {\n                  // Retrieved items does not include any items of interest. If we don't have a singleton registered to this handler,\n                  // we need to create one. Only do this on actual sync completetions and not on initial data load. Because we want\n                  // to get the latest from the server before making the decision to create a new item\n                  if (!singletonHandler.singleton && !initialLoad && !singletonHandler.pendingCreateBlockCallback) {\n                    handleCreation();\n                  }\n                }\n              };\n\n              var _iteratorNormalCompletion35 = true;\n              var _didIteratorError35 = false;\n              var _iteratorError35 = undefined;\n\n              try {\n                for (var _iterator35 = this.singletonHandlers[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {\n                  var singletonHandler = _step35.value;\n\n                  _loop3(singletonHandler);\n                }\n              } catch (err) {\n                _didIteratorError35 = true;\n                _iteratorError35 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion35 && _iterator35.return) {\n                    _iterator35.return();\n                  }\n                } finally {\n                  if (_didIteratorError35) {\n                    throw _iteratorError35;\n                  }\n                }\n              }\n            }\n          }]);\n\n          return SFSingletonManager;\n        }();\n\n        ; // SFStorageManager should be subclassed, and all the methods below overwritten.\n\n        var SFStorageManager = exports.SFStorageManager = function () {\n          function SFStorageManager() {\n            _classCallCheck(this, SFStorageManager);\n          }\n\n          _createClass(SFStorageManager, [{\n            key: \"setItem\",\n\n            /* Simple Key/Value Storage */\n            value: function () {\n              var _ref69 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee63(key, value) {\n                return regeneratorRuntime.wrap(function _callee63$(_context63) {\n                  while (1) {\n                    switch (_context63.prev = _context63.next) {\n                      case 0:\n                      case \"end\":\n                        return _context63.stop();\n                    }\n                  }\n                }, _callee63, this);\n              }));\n\n              function setItem(_x88, _x89) {\n                return _ref69.apply(this, arguments);\n              }\n\n              return setItem;\n            }()\n          }, {\n            key: \"getItem\",\n            value: function () {\n              var _ref70 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee64(key) {\n                return regeneratorRuntime.wrap(function _callee64$(_context64) {\n                  while (1) {\n                    switch (_context64.prev = _context64.next) {\n                      case 0:\n                      case \"end\":\n                        return _context64.stop();\n                    }\n                  }\n                }, _callee64, this);\n              }));\n\n              function getItem(_x90) {\n                return _ref70.apply(this, arguments);\n              }\n\n              return getItem;\n            }()\n          }, {\n            key: \"removeItem\",\n            value: function () {\n              var _ref71 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee65(key) {\n                return regeneratorRuntime.wrap(function _callee65$(_context65) {\n                  while (1) {\n                    switch (_context65.prev = _context65.next) {\n                      case 0:\n                      case \"end\":\n                        return _context65.stop();\n                    }\n                  }\n                }, _callee65, this);\n              }));\n\n              function removeItem(_x91) {\n                return _ref71.apply(this, arguments);\n              }\n\n              return removeItem;\n            }()\n          }, {\n            key: \"clear\",\n            value: function () {\n              var _ref72 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee66() {\n                return regeneratorRuntime.wrap(function _callee66$(_context66) {\n                  while (1) {\n                    switch (_context66.prev = _context66.next) {\n                      case 0:\n                      case \"end\":\n                        return _context66.stop();\n                    }\n                  }\n                }, _callee66, this);\n              }));\n\n              function clear() {\n                return _ref72.apply(this, arguments);\n              }\n\n              return clear;\n            }()\n          }, {\n            key: \"getAllModels\",\n\n            /*\n            Model Storage\n            */\n            value: function () {\n              var _ref73 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee67() {\n                return regeneratorRuntime.wrap(function _callee67$(_context67) {\n                  while (1) {\n                    switch (_context67.prev = _context67.next) {\n                      case 0:\n                      case \"end\":\n                        return _context67.stop();\n                    }\n                  }\n                }, _callee67, this);\n              }));\n\n              function getAllModels() {\n                return _ref73.apply(this, arguments);\n              }\n\n              return getAllModels;\n            }()\n          }, {\n            key: \"saveModel\",\n            value: function () {\n              var _ref74 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee68(item) {\n                return regeneratorRuntime.wrap(function _callee68$(_context68) {\n                  while (1) {\n                    switch (_context68.prev = _context68.next) {\n                      case 0:\n                        return _context68.abrupt(\"return\", this.saveModels([item]));\n\n                      case 1:\n                      case \"end\":\n                        return _context68.stop();\n                    }\n                  }\n                }, _callee68, this);\n              }));\n\n              function saveModel(_x92) {\n                return _ref74.apply(this, arguments);\n              }\n\n              return saveModel;\n            }()\n          }, {\n            key: \"saveModels\",\n            value: function () {\n              var _ref75 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee69(items) {\n                return regeneratorRuntime.wrap(function _callee69$(_context69) {\n                  while (1) {\n                    switch (_context69.prev = _context69.next) {\n                      case 0:\n                      case \"end\":\n                        return _context69.stop();\n                    }\n                  }\n                }, _callee69, this);\n              }));\n\n              function saveModels(_x93) {\n                return _ref75.apply(this, arguments);\n              }\n\n              return saveModels;\n            }()\n          }, {\n            key: \"deleteModel\",\n            value: function () {\n              var _ref76 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee70(item) {\n                return regeneratorRuntime.wrap(function _callee70$(_context70) {\n                  while (1) {\n                    switch (_context70.prev = _context70.next) {\n                      case 0:\n                      case \"end\":\n                        return _context70.stop();\n                    }\n                  }\n                }, _callee70, this);\n              }));\n\n              function deleteModel(_x94) {\n                return _ref76.apply(this, arguments);\n              }\n\n              return deleteModel;\n            }()\n          }, {\n            key: \"clearAllModels\",\n            value: function () {\n              var _ref77 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee71() {\n                return regeneratorRuntime.wrap(function _callee71$(_context71) {\n                  while (1) {\n                    switch (_context71.prev = _context71.next) {\n                      case 0:\n                      case \"end\":\n                        return _context71.stop();\n                    }\n                  }\n                }, _callee71, this);\n              }));\n\n              function clearAllModels() {\n                return _ref77.apply(this, arguments);\n              }\n\n              return clearAllModels;\n            }()\n          }, {\n            key: \"clearAllData\",\n\n            /* General */\n            value: function () {\n              var _ref78 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee72() {\n                return regeneratorRuntime.wrap(function _callee72$(_context72) {\n                  while (1) {\n                    switch (_context72.prev = _context72.next) {\n                      case 0:\n                        return _context72.abrupt(\"return\", Promise.all([this.clear(), this.clearAllModels()]));\n\n                      case 1:\n                      case \"end\":\n                        return _context72.stop();\n                    }\n                  }\n                }, _callee72, this);\n              }));\n\n              function clearAllData() {\n                return _ref78.apply(this, arguments);\n              }\n\n              return clearAllData;\n            }()\n          }]);\n\n          return SFStorageManager;\n        }();\n\n        ;\n\n        var SFSyncManager = exports.SFSyncManager = function () {\n          function SFSyncManager(modelManager, storageManager, httpManager, timeout, interval) {\n            _classCallCheck(this, SFSyncManager);\n\n            SFSyncManager.KeyRequestLoadLocal = \"KeyRequestLoadLocal\";\n            SFSyncManager.KeyRequestSaveLocal = \"KeyRequestSaveLocal\";\n            SFSyncManager.KeyRequestLoadSaveAccount = \"KeyRequestLoadSaveAccount\";\n            this.httpManager = httpManager;\n            this.modelManager = modelManager;\n            this.storageManager = storageManager; // Allows you to et your own interval/timeout function (i.e if you're using angular and want to use $timeout)\n\n            this.$interval = interval || setInterval.bind(window);\n            this.$timeout = timeout || setTimeout.bind(window);\n            this.syncStatus = {};\n            this.syncStatusObservers = [];\n            this.eventHandlers = [];\n            this.PerSyncItemUploadLimit = 100; // The number of changed items that constitute a major change\n            // This is used by the desktop app to create backups\n\n            this.MajorDataChangeThreshold = 15; // Sync integrity checking\n            // If X consective sync requests return mismatching hashes, then we officially enter out-of-sync.\n\n            this.MaxDiscordanceBeforeOutOfSync = 5; // How many consective sync results have had mismatching hashes. This value can never exceed this.MaxDiscordanceBeforeOutOfSync.\n\n            this.syncDiscordance = 0;\n            this.outOfSync = false;\n          }\n\n          _createClass(SFSyncManager, [{\n            key: \"handleServerIntegrityHash\",\n            value: function () {\n              var _ref79 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee73(serverHash) {\n                var localHash;\n                return regeneratorRuntime.wrap(function _callee73$(_context73) {\n                  while (1) {\n                    switch (_context73.prev = _context73.next) {\n                      case 0:\n                        if (!(!serverHash || serverHash.length == 0)) {\n                          _context73.next = 2;\n                          break;\n                        }\n\n                        return _context73.abrupt(\"return\", true);\n\n                      case 2:\n                        _context73.next = 4;\n                        return this.modelManager.computeDataIntegrityHash();\n\n                      case 4:\n                        localHash = _context73.sent;\n\n                        if (localHash) {\n                          _context73.next = 7;\n                          break;\n                        }\n\n                        return _context73.abrupt(\"return\", true);\n\n                      case 7:\n                        if (!(localHash !== serverHash)) {\n                          _context73.next = 13;\n                          break;\n                        }\n\n                        this.syncDiscordance++;\n\n                        if (this.syncDiscordance >= this.MaxDiscordanceBeforeOutOfSync) {\n                          if (!this.outOfSync) {\n                            this.outOfSync = true;\n                            this.notifyEvent(\"enter-out-of-sync\");\n                          }\n                        }\n\n                        return _context73.abrupt(\"return\", false);\n\n                      case 13:\n                        // Integrity matches\n                        if (this.outOfSync) {\n                          this.outOfSync = false;\n                          this.notifyEvent(\"exit-out-of-sync\");\n                        }\n\n                        this.syncDiscordance = 0;\n                        return _context73.abrupt(\"return\", true);\n\n                      case 16:\n                      case \"end\":\n                        return _context73.stop();\n                    }\n                  }\n                }, _callee73, this);\n              }));\n\n              function handleServerIntegrityHash(_x95) {\n                return _ref79.apply(this, arguments);\n              }\n\n              return handleServerIntegrityHash;\n            }()\n          }, {\n            key: \"isOutOfSync\",\n            value: function isOutOfSync() {\n              // Once we are outOfSync, it's up to the client to display UI to the user to instruct them\n              // to take action. The client should present a reconciliation wizard.\n              return this.outOfSync;\n            }\n          }, {\n            key: \"getServerURL\",\n            value: function () {\n              var _ref80 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee74() {\n                return regeneratorRuntime.wrap(function _callee74$(_context74) {\n                  while (1) {\n                    switch (_context74.prev = _context74.next) {\n                      case 0:\n                        _context74.next = 2;\n                        return this.storageManager.getItem(\"server\");\n\n                      case 2:\n                        _context74.t0 = _context74.sent;\n\n                        if (_context74.t0) {\n                          _context74.next = 5;\n                          break;\n                        }\n\n                        _context74.t0 = window._default_sf_server;\n\n                      case 5:\n                        return _context74.abrupt(\"return\", _context74.t0);\n\n                      case 6:\n                      case \"end\":\n                        return _context74.stop();\n                    }\n                  }\n                }, _callee74, this);\n              }));\n\n              function getServerURL() {\n                return _ref80.apply(this, arguments);\n              }\n\n              return getServerURL;\n            }()\n          }, {\n            key: \"getSyncURL\",\n            value: function () {\n              var _ref81 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee75() {\n                return regeneratorRuntime.wrap(function _callee75$(_context75) {\n                  while (1) {\n                    switch (_context75.prev = _context75.next) {\n                      case 0:\n                        _context75.next = 2;\n                        return this.getServerURL();\n\n                      case 2:\n                        _context75.t0 = _context75.sent;\n                        return _context75.abrupt(\"return\", _context75.t0 + \"/items/sync\");\n\n                      case 4:\n                      case \"end\":\n                        return _context75.stop();\n                    }\n                  }\n                }, _callee75, this);\n              }));\n\n              function getSyncURL() {\n                return _ref81.apply(this, arguments);\n              }\n\n              return getSyncURL;\n            }()\n          }, {\n            key: \"registerSyncStatusObserver\",\n            value: function registerSyncStatusObserver(callback) {\n              var observer = {\n                key: new Date(),\n                callback: callback\n              };\n              this.syncStatusObservers.push(observer);\n              return observer;\n            }\n          }, {\n            key: \"removeSyncStatusObserver\",\n            value: function removeSyncStatusObserver(observer) {\n              _.pull(this.syncStatusObservers, observer);\n            }\n          }, {\n            key: \"syncStatusDidChange\",\n            value: function syncStatusDidChange() {\n              var _this18 = this;\n\n              this.syncStatusObservers.forEach(function (observer) {\n                observer.callback(_this18.syncStatus);\n              });\n            }\n          }, {\n            key: \"addEventHandler\",\n            value: function addEventHandler(handler) {\n              /*\n              Possible Events:\n              sync:completed\n              sync:taking-too-long\n              sync:updated_token\n              sync:error\n              major-data-change\n              local-data-loaded\n              sync-session-invalid\n              sync-exception\n               */\n              this.eventHandlers.push(handler);\n              return handler;\n            }\n          }, {\n            key: \"removeEventHandler\",\n            value: function removeEventHandler(handler) {\n              _.pull(this.eventHandlers, handler);\n            }\n          }, {\n            key: \"notifyEvent\",\n            value: function notifyEvent(syncEvent, data) {\n              var _iteratorNormalCompletion37 = true;\n              var _didIteratorError37 = false;\n              var _iteratorError37 = undefined;\n\n              try {\n                for (var _iterator37 = this.eventHandlers[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {\n                  var handler = _step37.value;\n                  handler(syncEvent, data || {});\n                }\n              } catch (err) {\n                _didIteratorError37 = true;\n                _iteratorError37 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion37 && _iterator37.return) {\n                    _iterator37.return();\n                  }\n                } finally {\n                  if (_didIteratorError37) {\n                    throw _iteratorError37;\n                  }\n                }\n              }\n            }\n          }, {\n            key: \"setKeyRequestHandler\",\n            value: function setKeyRequestHandler(handler) {\n              this.keyRequestHandler = handler;\n            }\n          }, {\n            key: \"getActiveKeyInfo\",\n            value: function () {\n              var _ref82 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee76(request) {\n                return regeneratorRuntime.wrap(function _callee76$(_context76) {\n                  while (1) {\n                    switch (_context76.prev = _context76.next) {\n                      case 0:\n                        return _context76.abrupt(\"return\", this.keyRequestHandler(request));\n\n                      case 1:\n                      case \"end\":\n                        return _context76.stop();\n                    }\n                  }\n                }, _callee76, this);\n              }));\n\n              function getActiveKeyInfo(_x96) {\n                return _ref82.apply(this, arguments);\n              }\n\n              return getActiveKeyInfo;\n            }()\n          }, {\n            key: \"initialDataLoaded\",\n            value: function initialDataLoaded() {\n              return this._initialDataLoaded;\n            }\n          }, {\n            key: \"loadLocalItems\",\n            value: function () {\n              var _ref83 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee78(incrementalCallback) {\n                var _this19 = this;\n\n                var batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return regeneratorRuntime.wrap(function _callee78$(_context78) {\n                  while (1) {\n                    switch (_context78.prev = _context78.next) {\n                      case 0:\n                        return _context78.abrupt(\"return\", this.storageManager.getAllModels().then(function (items) {\n                          // put most recently updated at beginning, sorted by priority\n                          items = items.sort(function (a, b) {\n                            var dateResult = new Date(b.updated_at) - new Date(a.updated_at);\n                            var priorityList = _this19.contentTypeLoadPriority;\n                            var aPriority = 0,\n                                bPriority = 0;\n\n                            if (priorityList) {\n                              aPriority = priorityList.indexOf(a.content_type);\n                              bPriority = priorityList.indexOf(b.content_type);\n\n                              if (aPriority == -1) {\n                                // Not found in list, not prioritized. Set it to max value\n                                aPriority = priorityList.length;\n                              }\n\n                              if (bPriority == -1) {\n                                // Not found in list, not prioritized. Set it to max value\n                                bPriority = priorityList.length;\n                              }\n                            }\n\n                            if (aPriority == bPriority) {\n                              return dateResult;\n                            }\n\n                            if (aPriority < bPriority) {\n                              return -1;\n                            } else {\n                              return 1;\n                            } // aPriority < bPriority means a should come first\n\n\n                            return aPriority < bPriority ? -1 : 1;\n                          }); // break it up into chunks to make interface more responsive for large item counts\n\n                          var total = items.length;\n                          var current = 0;\n                          var processed = [];\n\n                          var decryptNext = function () {\n                            var _ref84 = _asyncToGenerator(\n                            /*#__PURE__*/\n                            regeneratorRuntime.mark(function _callee77() {\n                              var subitems, processedSubitems;\n                              return regeneratorRuntime.wrap(function _callee77$(_context77) {\n                                while (1) {\n                                  switch (_context77.prev = _context77.next) {\n                                    case 0:\n                                      subitems = items.slice(current, current + batchSize);\n                                      _context77.next = 3;\n                                      return _this19.handleItemsResponse(subitems, null, SFModelManager.MappingSourceLocalRetrieved, SFSyncManager.KeyRequestLoadLocal);\n\n                                    case 3:\n                                      processedSubitems = _context77.sent;\n                                      processed.push(processedSubitems);\n                                      current += subitems.length;\n\n                                      if (!(current < total)) {\n                                        _context77.next = 10;\n                                        break;\n                                      }\n\n                                      return _context77.abrupt(\"return\", new Promise(function (innerResolve, innerReject) {\n                                        _this19.$timeout(function () {\n                                          _this19.notifyEvent(\"local-data-incremental-load\");\n\n                                          incrementalCallback && incrementalCallback(current, total);\n                                          decryptNext().then(innerResolve);\n                                        });\n                                      }));\n\n                                    case 10:\n                                      // Completed\n                                      _this19.notifyEvent(\"local-data-loaded\");\n\n                                      _this19._initialDataLoaded = true;\n\n                                    case 12:\n                                    case \"end\":\n                                      return _context77.stop();\n                                  }\n                                }\n                              }, _callee77, _this19);\n                            }));\n\n                            return function decryptNext() {\n                              return _ref84.apply(this, arguments);\n                            };\n                          }();\n\n                          return decryptNext();\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context78.stop();\n                    }\n                  }\n                }, _callee78, this);\n              }));\n\n              function loadLocalItems(_x98) {\n                return _ref83.apply(this, arguments);\n              }\n\n              return loadLocalItems;\n            }()\n          }, {\n            key: \"writeItemsToLocalStorage\",\n            value: function () {\n              var _ref85 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee81(items, offlineOnly) {\n                var _this20 = this;\n\n                return regeneratorRuntime.wrap(function _callee81$(_context81) {\n                  while (1) {\n                    switch (_context81.prev = _context81.next) {\n                      case 0:\n                        return _context81.abrupt(\"return\", new Promise(function () {\n                          var _ref86 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee80(resolve, reject) {\n                            var info;\n                            return regeneratorRuntime.wrap(function _callee80$(_context80) {\n                              while (1) {\n                                switch (_context80.prev = _context80.next) {\n                                  case 0:\n                                    if (!(items.length == 0)) {\n                                      _context80.next = 3;\n                                      break;\n                                    }\n\n                                    resolve();\n                                    return _context80.abrupt(\"return\");\n\n                                  case 3:\n                                    _context80.next = 5;\n                                    return _this20.getActiveKeyInfo(SFSyncManager.KeyRequestSaveLocal);\n\n                                  case 5:\n                                    info = _context80.sent;\n                                    Promise.all(items.map(function () {\n                                      var _ref87 = _asyncToGenerator(\n                                      /*#__PURE__*/\n                                      regeneratorRuntime.mark(function _callee79(item) {\n                                        var itemParams;\n                                        return regeneratorRuntime.wrap(function _callee79$(_context79) {\n                                          while (1) {\n                                            switch (_context79.prev = _context79.next) {\n                                              case 0:\n                                                itemParams = new SFItemParams(item, info.keys, info.auth_params);\n                                                _context79.next = 3;\n                                                return itemParams.paramsForLocalStorage();\n\n                                              case 3:\n                                                itemParams = _context79.sent;\n\n                                                if (offlineOnly) {\n                                                  delete itemParams.dirty;\n                                                }\n\n                                                return _context79.abrupt(\"return\", itemParams);\n\n                                              case 6:\n                                              case \"end\":\n                                                return _context79.stop();\n                                            }\n                                          }\n                                        }, _callee79, _this20);\n                                      }));\n\n                                      return function (_x103) {\n                                        return _ref87.apply(this, arguments);\n                                      };\n                                    }())).then(function (params) {\n                                      _this20.storageManager.saveModels(params).then(function () {\n                                        // on success\n                                        if (_this20.syncStatus.localError) {\n                                          _this20.syncStatus.localError = null;\n\n                                          _this20.syncStatusDidChange();\n                                        }\n\n                                        resolve();\n                                      }).catch(function (error) {\n                                        // on error\n                                        console.error(\"Error writing items\", error);\n                                        _this20.syncStatus.localError = error;\n\n                                        _this20.syncStatusDidChange();\n\n                                        reject();\n                                      });\n                                    }).catch(function (e) {\n                                      reject(e);\n                                    });\n\n                                  case 7:\n                                  case \"end\":\n                                    return _context80.stop();\n                                }\n                              }\n                            }, _callee80, _this20);\n                          }));\n\n                          return function (_x101, _x102) {\n                            return _ref86.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 1:\n                      case \"end\":\n                        return _context81.stop();\n                    }\n                  }\n                }, _callee81, this);\n              }));\n\n              function writeItemsToLocalStorage(_x99, _x100) {\n                return _ref85.apply(this, arguments);\n              }\n\n              return writeItemsToLocalStorage;\n            }()\n          }, {\n            key: \"syncOffline\",\n            value: function () {\n              var _ref88 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee82(items) {\n                var _this21 = this;\n\n                var _iteratorNormalCompletion38, _didIteratorError38, _iteratorError38, _iterator38, _step38, item;\n\n                return regeneratorRuntime.wrap(function _callee82$(_context82) {\n                  while (1) {\n                    switch (_context82.prev = _context82.next) {\n                      case 0:\n                        // Update all items updated_at to now\n                        _iteratorNormalCompletion38 = true;\n                        _didIteratorError38 = false;\n                        _iteratorError38 = undefined;\n                        _context82.prev = 3;\n\n                        for (_iterator38 = items[Symbol.iterator](); !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {\n                          item = _step38.value;\n                          item.updated_at = new Date();\n                        }\n\n                        _context82.next = 11;\n                        break;\n\n                      case 7:\n                        _context82.prev = 7;\n                        _context82.t0 = _context82[\"catch\"](3);\n                        _didIteratorError38 = true;\n                        _iteratorError38 = _context82.t0;\n\n                      case 11:\n                        _context82.prev = 11;\n                        _context82.prev = 12;\n\n                        if (!_iteratorNormalCompletion38 && _iterator38.return) {\n                          _iterator38.return();\n                        }\n\n                      case 14:\n                        _context82.prev = 14;\n\n                        if (!_didIteratorError38) {\n                          _context82.next = 17;\n                          break;\n                        }\n\n                        throw _iteratorError38;\n\n                      case 17:\n                        return _context82.finish(14);\n\n                      case 18:\n                        return _context82.finish(11);\n\n                      case 19:\n                        return _context82.abrupt(\"return\", this.writeItemsToLocalStorage(items, true).then(function (responseItems) {\n                          // delete anything needing to be deleted\n                          var _iteratorNormalCompletion39 = true;\n                          var _didIteratorError39 = false;\n                          var _iteratorError39 = undefined;\n\n                          try {\n                            for (var _iterator39 = items[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {\n                              var _item = _step39.value;\n\n                              if (_item.deleted) {\n                                _this21.modelManager.removeItemLocally(_item);\n                              }\n                            }\n                          } catch (err) {\n                            _didIteratorError39 = true;\n                            _iteratorError39 = err;\n                          } finally {\n                            try {\n                              if (!_iteratorNormalCompletion39 && _iterator39.return) {\n                                _iterator39.return();\n                              }\n                            } finally {\n                              if (_didIteratorError39) {\n                                throw _iteratorError39;\n                              }\n                            }\n                          }\n\n                          _this21.notifyEvent(\"sync:completed\", {\n                            savedItems: items\n                          }); // Required in order for modelManager to notify sync observers\n\n\n                          _this21.modelManager.didSyncModelsOffline(items);\n\n                          return {\n                            saved_items: items\n                          };\n                        }));\n\n                      case 20:\n                      case \"end\":\n                        return _context82.stop();\n                    }\n                  }\n                }, _callee82, this, [[3, 7, 11, 19], [12,, 14, 18]]);\n              }));\n\n              function syncOffline(_x104) {\n                return _ref88.apply(this, arguments);\n              }\n\n              return syncOffline;\n            }()\n            /*\n              In the case of signing in and merging local data, we alternative UUIDs\n              to avoid overwriting data a user may retrieve that has the same UUID.\n              Alternating here forces us to to create duplicates of the items instead.\n             */\n\n          }, {\n            key: \"markAllItemsDirtyAndSaveOffline\",\n            value: function () {\n              var _ref89 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee83(alternateUUIDs) {\n                var originalItems, _iteratorNormalCompletion40, _didIteratorError40, _iteratorError40, _iterator40, _step40, item, allItems, _iteratorNormalCompletion41, _didIteratorError41, _iteratorError41, _iterator41, _step41, _item2;\n\n                return regeneratorRuntime.wrap(function _callee83$(_context83) {\n                  while (1) {\n                    switch (_context83.prev = _context83.next) {\n                      case 0:\n                        // use a copy, as alternating uuid will affect array\n                        originalItems = this.modelManager.allNondummyItems.filter(function (item) {\n                          return !item.errorDecrypting;\n                        }).slice();\n\n                        if (!alternateUUIDs) {\n                          _context83.next = 28;\n                          break;\n                        }\n\n                        _iteratorNormalCompletion40 = true;\n                        _didIteratorError40 = false;\n                        _iteratorError40 = undefined;\n                        _context83.prev = 5;\n                        _iterator40 = originalItems[Symbol.iterator]();\n\n                      case 7:\n                        if (_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done) {\n                          _context83.next = 14;\n                          break;\n                        }\n\n                        item = _step40.value;\n                        _context83.next = 11;\n                        return this.modelManager.alternateUUIDForItem(item);\n\n                      case 11:\n                        _iteratorNormalCompletion40 = true;\n                        _context83.next = 7;\n                        break;\n\n                      case 14:\n                        _context83.next = 20;\n                        break;\n\n                      case 16:\n                        _context83.prev = 16;\n                        _context83.t0 = _context83[\"catch\"](5);\n                        _didIteratorError40 = true;\n                        _iteratorError40 = _context83.t0;\n\n                      case 20:\n                        _context83.prev = 20;\n                        _context83.prev = 21;\n\n                        if (!_iteratorNormalCompletion40 && _iterator40.return) {\n                          _iterator40.return();\n                        }\n\n                      case 23:\n                        _context83.prev = 23;\n\n                        if (!_didIteratorError40) {\n                          _context83.next = 26;\n                          break;\n                        }\n\n                        throw _iteratorError40;\n\n                      case 26:\n                        return _context83.finish(23);\n\n                      case 27:\n                        return _context83.finish(20);\n\n                      case 28:\n                        allItems = this.modelManager.allNondummyItems;\n                        _iteratorNormalCompletion41 = true;\n                        _didIteratorError41 = false;\n                        _iteratorError41 = undefined;\n                        _context83.prev = 32;\n\n                        for (_iterator41 = allItems[Symbol.iterator](); !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {\n                          _item2 = _step41.value;\n\n                          _item2.setDirty(true);\n                        }\n\n                        _context83.next = 40;\n                        break;\n\n                      case 36:\n                        _context83.prev = 36;\n                        _context83.t1 = _context83[\"catch\"](32);\n                        _didIteratorError41 = true;\n                        _iteratorError41 = _context83.t1;\n\n                      case 40:\n                        _context83.prev = 40;\n                        _context83.prev = 41;\n\n                        if (!_iteratorNormalCompletion41 && _iterator41.return) {\n                          _iterator41.return();\n                        }\n\n                      case 43:\n                        _context83.prev = 43;\n\n                        if (!_didIteratorError41) {\n                          _context83.next = 46;\n                          break;\n                        }\n\n                        throw _iteratorError41;\n\n                      case 46:\n                        return _context83.finish(43);\n\n                      case 47:\n                        return _context83.finish(40);\n\n                      case 48:\n                        return _context83.abrupt(\"return\", this.writeItemsToLocalStorage(allItems, false));\n\n                      case 49:\n                      case \"end\":\n                        return _context83.stop();\n                    }\n                  }\n                }, _callee83, this, [[5, 16, 20, 28], [21,, 23, 27], [32, 36, 40, 48], [41,, 43, 47]]);\n              }));\n\n              function markAllItemsDirtyAndSaveOffline(_x105) {\n                return _ref89.apply(this, arguments);\n              }\n\n              return markAllItemsDirtyAndSaveOffline;\n            }()\n          }, {\n            key: \"setSyncToken\",\n            value: function () {\n              var _ref90 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee84(token) {\n                return regeneratorRuntime.wrap(function _callee84$(_context84) {\n                  while (1) {\n                    switch (_context84.prev = _context84.next) {\n                      case 0:\n                        this._syncToken = token;\n                        _context84.next = 3;\n                        return this.storageManager.setItem(\"syncToken\", token);\n\n                      case 3:\n                      case \"end\":\n                        return _context84.stop();\n                    }\n                  }\n                }, _callee84, this);\n              }));\n\n              function setSyncToken(_x106) {\n                return _ref90.apply(this, arguments);\n              }\n\n              return setSyncToken;\n            }()\n          }, {\n            key: \"getSyncToken\",\n            value: function () {\n              var _ref91 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee85() {\n                return regeneratorRuntime.wrap(function _callee85$(_context85) {\n                  while (1) {\n                    switch (_context85.prev = _context85.next) {\n                      case 0:\n                        if (this._syncToken) {\n                          _context85.next = 4;\n                          break;\n                        }\n\n                        _context85.next = 3;\n                        return this.storageManager.getItem(\"syncToken\");\n\n                      case 3:\n                        this._syncToken = _context85.sent;\n\n                      case 4:\n                        return _context85.abrupt(\"return\", this._syncToken);\n\n                      case 5:\n                      case \"end\":\n                        return _context85.stop();\n                    }\n                  }\n                }, _callee85, this);\n              }));\n\n              function getSyncToken() {\n                return _ref91.apply(this, arguments);\n              }\n\n              return getSyncToken;\n            }()\n          }, {\n            key: \"setCursorToken\",\n            value: function () {\n              var _ref92 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee86(token) {\n                return regeneratorRuntime.wrap(function _callee86$(_context86) {\n                  while (1) {\n                    switch (_context86.prev = _context86.next) {\n                      case 0:\n                        this._cursorToken = token;\n\n                        if (!token) {\n                          _context86.next = 6;\n                          break;\n                        }\n\n                        _context86.next = 4;\n                        return this.storageManager.setItem(\"cursorToken\", token);\n\n                      case 4:\n                        _context86.next = 8;\n                        break;\n\n                      case 6:\n                        _context86.next = 8;\n                        return this.storageManager.removeItem(\"cursorToken\");\n\n                      case 8:\n                      case \"end\":\n                        return _context86.stop();\n                    }\n                  }\n                }, _callee86, this);\n              }));\n\n              function setCursorToken(_x107) {\n                return _ref92.apply(this, arguments);\n              }\n\n              return setCursorToken;\n            }()\n          }, {\n            key: \"getCursorToken\",\n            value: function () {\n              var _ref93 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee87() {\n                return regeneratorRuntime.wrap(function _callee87$(_context87) {\n                  while (1) {\n                    switch (_context87.prev = _context87.next) {\n                      case 0:\n                        if (this._cursorToken) {\n                          _context87.next = 4;\n                          break;\n                        }\n\n                        _context87.next = 3;\n                        return this.storageManager.getItem(\"cursorToken\");\n\n                      case 3:\n                        this._cursorToken = _context87.sent;\n\n                      case 4:\n                        return _context87.abrupt(\"return\", this._cursorToken);\n\n                      case 5:\n                      case \"end\":\n                        return _context87.stop();\n                    }\n                  }\n                }, _callee87, this);\n              }));\n\n              function getCursorToken() {\n                return _ref93.apply(this, arguments);\n              }\n\n              return getCursorToken;\n            }()\n          }, {\n            key: \"clearQueuedCallbacks\",\n            value: function clearQueuedCallbacks() {\n              this._queuedCallbacks = [];\n            }\n          }, {\n            key: \"callQueuedCallbacks\",\n            value: function callQueuedCallbacks(response) {\n              var allCallbacks = this.queuedCallbacks;\n\n              if (allCallbacks.length) {\n                var _iteratorNormalCompletion42 = true;\n                var _didIteratorError42 = false;\n                var _iteratorError42 = undefined;\n\n                try {\n                  for (var _iterator42 = allCallbacks[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {\n                    var eachCallback = _step42.value;\n                    eachCallback(response);\n                  }\n                } catch (err) {\n                  _didIteratorError42 = true;\n                  _iteratorError42 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion42 && _iterator42.return) {\n                      _iterator42.return();\n                    }\n                  } finally {\n                    if (_didIteratorError42) {\n                      throw _iteratorError42;\n                    }\n                  }\n                }\n\n                this.clearQueuedCallbacks();\n              }\n            }\n          }, {\n            key: \"beginCheckingIfSyncIsTakingTooLong\",\n            value: function beginCheckingIfSyncIsTakingTooLong() {\n              if (this.syncStatus.checker) {\n                this.stopCheckingIfSyncIsTakingTooLong();\n              }\n\n              this.syncStatus.checker = this.$interval(function () {\n                // check to see if the ongoing sync is taking too long, alert the user\n                var secondsPassed = (new Date() - this.syncStatus.syncStart) / 1000;\n                var warningThreshold = 5.0; // seconds\n\n                if (secondsPassed > warningThreshold) {\n                  this.notifyEvent(\"sync:taking-too-long\");\n                  this.stopCheckingIfSyncIsTakingTooLong();\n                }\n              }.bind(this), 500);\n            }\n          }, {\n            key: \"stopCheckingIfSyncIsTakingTooLong\",\n            value: function stopCheckingIfSyncIsTakingTooLong() {\n              if (this.$interval.hasOwnProperty(\"cancel\")) {\n                this.$interval.cancel(this.syncStatus.checker);\n              } else {\n                clearInterval(this.syncStatus.checker);\n              }\n\n              this.syncStatus.checker = null;\n            }\n          }, {\n            key: \"lockSyncing\",\n            value: function lockSyncing() {\n              this.syncLocked = true;\n            }\n          }, {\n            key: \"unlockSyncing\",\n            value: function unlockSyncing() {\n              this.syncLocked = false;\n            }\n          }, {\n            key: \"sync\",\n            value: function () {\n              var _ref94 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee89() {\n                var _this22 = this;\n\n                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                return regeneratorRuntime.wrap(function _callee89$(_context89) {\n                  while (1) {\n                    switch (_context89.prev = _context89.next) {\n                      case 0:\n                        return _context89.abrupt(\"return\", new Promise(function () {\n                          var _ref95 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee88(resolve, reject) {\n                            var allDirtyItems, dirtyItemsNotYetSaved, info, isContinuationSync, submitLimit, subItems, params, _iteratorNormalCompletion43, _didIteratorError43, _iteratorError43, _iterator43, _step43, item;\n\n                            return regeneratorRuntime.wrap(function _callee88$(_context88) {\n                              while (1) {\n                                switch (_context88.prev = _context88.next) {\n                                  case 0:\n                                    if (!_this22.syncLocked) {\n                                      _context88.next = 4;\n                                      break;\n                                    }\n\n                                    console.log(\"Sync Locked, Returning;\");\n                                    resolve();\n                                    return _context88.abrupt(\"return\");\n\n                                  case 4:\n                                    if (!options) options = {};\n                                    allDirtyItems = _this22.modelManager.getDirtyItems();\n                                    /*\n                                      When it comes to saving to disk before the sync request (both in syncOpInProgress and preSyncSave),\n                                      you only want to save items that have a dirty count > 0. That's because, if for example, you're syncing\n                                      2000 items, and every sync request handles only 150 items at a time, then every sync request will\n                                      be writing the same thousand items to storage every time. Writing a thousand items to storage can take 10s.\n                                      So, save to local storage only items with dirtyCount > 0, then, after saving, set dirtyCount to 0.\n                                      This way, if an item changes again, it will be saved next sync.\n                                    */\n\n                                    dirtyItemsNotYetSaved = allDirtyItems.filter(function (candidate) {\n                                      if (candidate.dirtyCount > 0) {\n                                        candidate.dirtyCount = 0;\n                                        return true;\n                                      } else {\n                                        return false;\n                                      }\n                                    }); // When a user hits the physical refresh button, we want to force refresh, in case\n                                    // the sync engine is stuck in some inProgress loop.\n\n                                    if (!(_this22.syncStatus.syncOpInProgress && !options.force)) {\n                                      _context88.next = 14;\n                                      break;\n                                    }\n\n                                    _this22.repeatOnCompletion = true;\n\n                                    _this22.queuedCallbacks.push(resolve);\n\n                                    _context88.next = 12;\n                                    return _this22.writeItemsToLocalStorage(dirtyItemsNotYetSaved, false);\n\n                                  case 12:\n                                    console.log(\"Sync op in progress; returning.\");\n                                    return _context88.abrupt(\"return\");\n\n                                  case 14:\n                                    _context88.next = 16;\n                                    return _this22.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);\n\n                                  case 16:\n                                    info = _context88.sent;\n\n                                    if (!info.offline) {\n                                      _context88.next = 20;\n                                      break;\n                                    }\n\n                                    _this22.syncOffline(allDirtyItems).then(function (response) {\n                                      _this22.modelManager.clearDirtyItems(allDirtyItems);\n\n                                      resolve(response);\n                                    }).catch(function (e) {\n                                      _this22.notifyEvent(\"sync-exception\", e);\n                                    });\n\n                                    return _context88.abrupt(\"return\");\n\n                                  case 20:\n                                    isContinuationSync = _this22.syncStatus.needsMoreSync;\n                                    _this22.syncStatus.syncOpInProgress = true;\n                                    _this22.syncStatus.syncStart = new Date();\n\n                                    _this22.beginCheckingIfSyncIsTakingTooLong();\n\n                                    submitLimit = _this22.PerSyncItemUploadLimit;\n                                    subItems = allDirtyItems.slice(0, submitLimit);\n\n                                    if (subItems.length < allDirtyItems.length) {\n                                      // more items left to be synced, repeat\n                                      _this22.syncStatus.needsMoreSync = true;\n                                    } else {\n                                      _this22.syncStatus.needsMoreSync = false;\n                                    }\n\n                                    if (!isContinuationSync) {\n                                      _this22.syncStatus.total = allDirtyItems.length;\n                                      _this22.syncStatus.current = 0;\n                                    } // If items are marked as dirty during a long running sync request, total isn't updated\n                                    // This happens mostly in the case of large imports and sync conflicts where duplicated items are created\n\n\n                                    if (_this22.syncStatus.current > _this22.syncStatus.total) {\n                                      _this22.syncStatus.total = _this22.syncStatus.current;\n                                    }\n\n                                    _this22.syncStatusDidChange(); // Perform save after you've updated all status signals above. Presync save can take several seconds in some cases.\n                                    // Write to local storage before beginning sync.\n                                    // This way, if they close the browser before the sync request completes, local changes will not be lost\n\n\n                                    _context88.next = 32;\n                                    return _this22.writeItemsToLocalStorage(dirtyItemsNotYetSaved, false);\n\n                                  case 32:\n                                    if (options.onPreSyncSave) {\n                                      options.onPreSyncSave();\n                                    } // when doing a sync request that returns items greater than the limit, and thus subsequent syncs are required,\n                                    // we want to keep track of all retreived items, then save to local storage only once all items have been retrieved,\n                                    // so that relationships remain intact\n                                    // Update 12/18: I don't think we need to do this anymore, since relationships will now retroactively resolve their relationships,\n                                    // if an item they were looking for hasn't been pulled in yet.\n\n\n                                    if (!_this22.allRetreivedItems) {\n                                      _this22.allRetreivedItems = [];\n                                    } // We also want to do this for savedItems\n\n\n                                    if (!_this22.allSavedItems) {\n                                      _this22.allSavedItems = [];\n                                    }\n\n                                    params = {};\n                                    params.limit = 150;\n\n                                    if (options.performIntegrityCheck) {\n                                      params.compute_integrity = true;\n                                    }\n\n                                    _context88.prev = 38;\n                                    _context88.next = 41;\n                                    return Promise.all(subItems.map(function (item) {\n                                      var itemParams = new SFItemParams(item, info.keys, info.auth_params);\n                                      itemParams.additionalFields = options.additionalFields;\n                                      return itemParams.paramsForSync();\n                                    })).then(function (itemsParams) {\n                                      params.items = itemsParams;\n                                    });\n\n                                  case 41:\n                                    _context88.next = 46;\n                                    break;\n\n                                  case 43:\n                                    _context88.prev = 43;\n                                    _context88.t0 = _context88[\"catch\"](38);\n\n                                    _this22.notifyEvent(\"sync-exception\", _context88.t0);\n\n                                  case 46:\n                                    _iteratorNormalCompletion43 = true;\n                                    _didIteratorError43 = false;\n                                    _iteratorError43 = undefined;\n                                    _context88.prev = 49;\n\n                                    for (_iterator43 = subItems[Symbol.iterator](); !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {\n                                      item = _step43.value; // Reset dirty counter to 0, since we're about to sync it.\n                                      // This means anyone marking the item as dirty after this will cause it so sync again and not be cleared on sync completion.\n\n                                      item.dirtyCount = 0;\n                                    }\n\n                                    _context88.next = 57;\n                                    break;\n\n                                  case 53:\n                                    _context88.prev = 53;\n                                    _context88.t1 = _context88[\"catch\"](49);\n                                    _didIteratorError43 = true;\n                                    _iteratorError43 = _context88.t1;\n\n                                  case 57:\n                                    _context88.prev = 57;\n                                    _context88.prev = 58;\n\n                                    if (!_iteratorNormalCompletion43 && _iterator43.return) {\n                                      _iterator43.return();\n                                    }\n\n                                  case 60:\n                                    _context88.prev = 60;\n\n                                    if (!_didIteratorError43) {\n                                      _context88.next = 63;\n                                      break;\n                                    }\n\n                                    throw _iteratorError43;\n\n                                  case 63:\n                                    return _context88.finish(60);\n\n                                  case 64:\n                                    return _context88.finish(57);\n\n                                  case 65:\n                                    _context88.next = 67;\n                                    return _this22.getSyncToken();\n\n                                  case 67:\n                                    params.sync_token = _context88.sent;\n                                    _context88.next = 70;\n                                    return _this22.getCursorToken();\n\n                                  case 70:\n                                    params.cursor_token = _context88.sent;\n                                    _context88.prev = 71;\n                                    _context88.t2 = _this22.httpManager;\n                                    _context88.next = 75;\n                                    return _this22.getSyncURL();\n\n                                  case 75:\n                                    _context88.t3 = _context88.sent;\n                                    _context88.t4 = params;\n\n                                    _context88.t5 = function (response) {\n                                      _this22.handleSyncSuccess(subItems, response, options).then(function () {\n                                        resolve(response);\n                                      }).catch(function (e) {\n                                        console.log(\"Caught sync success exception:\", e);\n\n                                        _this22.handleSyncError(null, null, allDirtyItems).then(function (errorResponse) {\n                                          resolve(errorResponse);\n                                        });\n                                      });\n                                    };\n\n                                    _context88.t6 = function (response, statusCode) {\n                                      _this22.handleSyncError(response, statusCode, allDirtyItems).then(function (errorResponse) {\n                                        resolve(errorResponse);\n                                      });\n                                    };\n\n                                    _context88.t2.postAbsolute.call(_context88.t2, _context88.t3, _context88.t4, _context88.t5, _context88.t6);\n\n                                    _context88.next = 85;\n                                    break;\n\n                                  case 82:\n                                    _context88.prev = 82;\n                                    _context88.t7 = _context88[\"catch\"](71);\n                                    console.log(\"Sync exception caught:\", _context88.t7);\n\n                                  case 85:\n                                  case \"end\":\n                                    return _context88.stop();\n                                }\n                              }\n                            }, _callee88, _this22, [[38, 43], [49, 53, 57, 65], [58,, 60, 64], [71, 82]]);\n                          }));\n\n                          return function (_x109, _x110) {\n                            return _ref95.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 1:\n                      case \"end\":\n                        return _context89.stop();\n                    }\n                  }\n                }, _callee89, this);\n              }));\n\n              function sync() {\n                return _ref94.apply(this, arguments);\n              }\n\n              return sync;\n            }()\n          }, {\n            key: \"handleSyncSuccess\",\n            value: function () {\n              var _ref96 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee90(syncedItems, response, options) {\n                var _this23 = this;\n\n                var itemsToClearAsDirty, _iteratorNormalCompletion44, _didIteratorError44, _iteratorError44, _iterator44, _step44, item, allSavedUUIDs, retrieved, omitFields, saved, unsaved, matches, cursorToken;\n\n                return regeneratorRuntime.wrap(function _callee90$(_context90) {\n                  while (1) {\n                    switch (_context90.prev = _context90.next) {\n                      case 0:\n                        // Check to make sure any subItem hasn't been marked as dirty again while a sync was ongoing\n                        itemsToClearAsDirty = [];\n                        _iteratorNormalCompletion44 = true;\n                        _didIteratorError44 = false;\n                        _iteratorError44 = undefined;\n                        _context90.prev = 4;\n\n                        for (_iterator44 = syncedItems[Symbol.iterator](); !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {\n                          item = _step44.value;\n\n                          if (item.dirtyCount == 0) {\n                            // Safe to clear as dirty\n                            itemsToClearAsDirty.push(item);\n                          }\n                        }\n\n                        _context90.next = 12;\n                        break;\n\n                      case 8:\n                        _context90.prev = 8;\n                        _context90.t0 = _context90[\"catch\"](4);\n                        _didIteratorError44 = true;\n                        _iteratorError44 = _context90.t0;\n\n                      case 12:\n                        _context90.prev = 12;\n                        _context90.prev = 13;\n\n                        if (!_iteratorNormalCompletion44 && _iterator44.return) {\n                          _iterator44.return();\n                        }\n\n                      case 15:\n                        _context90.prev = 15;\n\n                        if (!_didIteratorError44) {\n                          _context90.next = 18;\n                          break;\n                        }\n\n                        throw _iteratorError44;\n\n                      case 18:\n                        return _context90.finish(15);\n\n                      case 19:\n                        return _context90.finish(12);\n\n                      case 20:\n                        this.modelManager.clearDirtyItems(itemsToClearAsDirty);\n                        this.syncStatus.error = null; // Filter retrieved_items to remove any items that may be in saved_items for this complete sync operation\n                        // When signing in, and a user requires many round trips to complete entire retrieval of data, an item may be saved\n                        // on the first trip, then on subsequent trips using cursor_token, this same item may be returned, since it's date is\n                        // greater than cursor_token. We keep track of all saved items in whole sync operation with this.allSavedItems\n                        // We need this because singletonManager looks at retrievedItems as higher precendence than savedItems, but if it comes in both\n                        // then that's problematic.\n\n                        allSavedUUIDs = this.allSavedItems.map(function (item) {\n                          return item.uuid;\n                        });\n                        response.retrieved_items = response.retrieved_items.filter(function (candidate) {\n                          return !allSavedUUIDs.includes(candidate.uuid);\n                        }); // Map retrieved items to local data\n                        // Note that deleted items will not be returned\n\n                        _context90.next = 26;\n                        return this.handleItemsResponse(response.retrieved_items, null, SFModelManager.MappingSourceRemoteRetrieved, SFSyncManager.KeyRequestLoadSaveAccount);\n\n                      case 26:\n                        retrieved = _context90.sent; // Append items to master list of retrieved items for this ongoing sync operation\n\n                        this.allRetreivedItems = this.allRetreivedItems.concat(retrieved);\n                        this.syncStatus.retrievedCount = this.allRetreivedItems.length; // Merge only metadata for saved items\n                        // we write saved items to disk now because it clears their dirty status then saves\n                        // if we saved items before completion, we had have to save them as dirty and save them again on success as clean\n\n                        omitFields = [\"content\", \"auth_hash\"]; // Map saved items to local data\n\n                        _context90.next = 32;\n                        return this.handleItemsResponse(response.saved_items, omitFields, SFModelManager.MappingSourceRemoteSaved, SFSyncManager.KeyRequestLoadSaveAccount);\n\n                      case 32:\n                        saved = _context90.sent; // Append items to master list of saved items for this ongoing sync operation\n\n                        this.allSavedItems = this.allSavedItems.concat(saved); // Create copies of items or alternate their uuids if neccessary\n\n                        unsaved = response.unsaved; // don't `await`. This function calls sync, so if you wait, it will call sync without having completed the sync we're in.\n                        // On second thought, calling await will only await the local conflict resolution and not await the sync call.\n                        // We do need to wait here for sync duplication to finish. If we don't, there seems to be an issue where if you import a large\n                        // backup with uuid-conflcits (from another account), you'll see very confused duplication.\n\n                        _context90.next = 37;\n                        return this.handleUnsavedItemsResponse(unsaved);\n\n                      case 37:\n                        _context90.next = 39;\n                        return this.writeItemsToLocalStorage(saved, false);\n\n                      case 39:\n                        _context90.next = 41;\n                        return this.writeItemsToLocalStorage(retrieved, false);\n\n                      case 41:\n                        this.syncStatus.syncOpInProgress = false;\n                        this.syncStatus.current += syncedItems.length;\n                        this.syncStatusDidChange(); // set the sync token at the end, so that if any errors happen above, you can resync\n\n                        this.setSyncToken(response.sync_token);\n                        this.setCursorToken(response.cursor_token);\n                        this.stopCheckingIfSyncIsTakingTooLong(); // if a cursor token is available, dont perform integrity calculation,\n                        // as content is still on the server waiting to be downloaded\n\n                        if (!(response.integrity_hash && !response.cursor_token)) {\n                          _context90.next = 52;\n                          break;\n                        }\n\n                        _context90.next = 50;\n                        return this.handleServerIntegrityHash(response.integrity_hash);\n\n                      case 50:\n                        matches = _context90.sent;\n\n                        if (!matches) {\n                          // If the server hash doesn't match our local hash, we want to continue syncing until we reach\n                          // the max discordance threshold\n                          if (this.syncDiscordance < this.MaxDiscordanceBeforeOutOfSync) {\n                            this.repeatOnCompletion = true;\n                          }\n                        }\n\n                      case 52:\n                        _context90.next = 54;\n                        return this.getCursorToken();\n\n                      case 54:\n                        cursorToken = _context90.sent;\n\n                        if (!(cursorToken || this.syncStatus.needsMoreSync)) {\n                          _context90.next = 59;\n                          break;\n                        }\n\n                        return _context90.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          setTimeout(function () {\n                            this.sync(options).then(resolve);\n                          }.bind(_this23), 10); // wait 10ms to allow UI to update\n                        }));\n\n                      case 59:\n                        if (!this.repeatOnCompletion) {\n                          _context90.next = 64;\n                          break;\n                        }\n\n                        this.repeatOnCompletion = false;\n                        return _context90.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          setTimeout(function () {\n                            this.sync(options).then(resolve);\n                          }.bind(_this23), 10); // wait 10ms to allow UI to update\n                        }));\n\n                      case 64:\n                        /*\n                        // await this.writeItemsToLocalStorage(this.allRetreivedItems, false);\n                          We used to do this, but the problem is, if you're saving 2000 items at the end of a sign in,\n                          then refresh or close the page, the items will not be saved, and the sync token will be the lastest.\n                          So the data won't be downloaded again. Instead, we'll save retrieved as they come.\n                        */\n                        this.syncStatus.retrievedCount = 0;\n                        this.syncStatusDidChange();\n\n                        if (this.allRetreivedItems.length >= this.majorDataChangeThreshold || saved.length >= this.majorDataChangeThreshold || unsaved.length >= this.majorDataChangeThreshold) {\n                          this.notifyEvent(\"major-data-change\");\n                        }\n\n                        this.callQueuedCallbacks(response);\n                        this.notifyEvent(\"sync:completed\", {\n                          retrievedItems: this.allRetreivedItems,\n                          savedItems: this.allSavedItems,\n                          unsavedItems: unsaved\n                        });\n                        this.allRetreivedItems = [];\n                        this.allSavedItems = [];\n                        return _context90.abrupt(\"return\", response);\n\n                      case 72:\n                      case \"end\":\n                        return _context90.stop();\n                    }\n                  }\n                }, _callee90, this, [[4, 8, 12, 20], [13,, 15, 19]]);\n              }));\n\n              function handleSyncSuccess(_x111, _x112, _x113) {\n                return _ref96.apply(this, arguments);\n              }\n\n              return handleSyncSuccess;\n            }()\n          }, {\n            key: \"handleSyncError\",\n            value: function () {\n              var _ref97 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee91(response, statusCode, allDirtyItems) {\n                return regeneratorRuntime.wrap(function _callee91$(_context91) {\n                  while (1) {\n                    switch (_context91.prev = _context91.next) {\n                      case 0:\n                        console.log(\"Sync error: \", response);\n\n                        if (statusCode == 401) {\n                          this.notifyEvent(\"sync-session-invalid\");\n                        }\n\n                        if (!response) {\n                          response = {\n                            error: {\n                              message: \"Could not connect to server.\"\n                            }\n                          };\n                        } else if (typeof response == 'string') {\n                          response = {\n                            error: {\n                              message: response\n                            }\n                          };\n                        }\n\n                        this.syncStatus.syncOpInProgress = false;\n                        this.syncStatus.error = response.error;\n                        this.syncStatusDidChange();\n                        this.writeItemsToLocalStorage(allDirtyItems, false);\n                        this.modelManager.didSyncModelsOffline(allDirtyItems);\n                        this.stopCheckingIfSyncIsTakingTooLong();\n                        this.notifyEvent(\"sync:error\", response.error);\n                        this.callQueuedCallbacks({\n                          error: \"Sync error\"\n                        });\n                        return _context91.abrupt(\"return\", response);\n\n                      case 12:\n                      case \"end\":\n                        return _context91.stop();\n                    }\n                  }\n                }, _callee91, this);\n              }));\n\n              function handleSyncError(_x114, _x115, _x116) {\n                return _ref97.apply(this, arguments);\n              }\n\n              return handleSyncError;\n            }()\n          }, {\n            key: \"handleItemsResponse\",\n            value: function () {\n              var _ref98 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee92(responseItems, omitFields, source, keyRequest) {\n                var keys, items, itemsWithErrorStatusChange;\n                return regeneratorRuntime.wrap(function _callee92$(_context92) {\n                  while (1) {\n                    switch (_context92.prev = _context92.next) {\n                      case 0:\n                        _context92.next = 2;\n                        return this.getActiveKeyInfo(keyRequest);\n\n                      case 2:\n                        keys = _context92.sent.keys;\n                        _context92.next = 5;\n                        return SFJS.itemTransformer.decryptMultipleItems(responseItems, keys);\n\n                      case 5:\n                        items = this.modelManager.mapResponseItemsToLocalModelsOmittingFields(responseItems, omitFields, source); // During the decryption process, items may be marked as \"errorDecrypting\". If so, we want to be sure\n                        // to persist this new state by writing these items back to local storage. When an item's \"errorDecrypting\"\n                        // flag is changed, its \"errorDecryptingValueChanged\" flag will be set, so we can find these items by filtering (then unsetting) below:\n\n                        itemsWithErrorStatusChange = items.filter(function (item) {\n                          var valueChanged = item.errorDecryptingValueChanged; // unset after consuming value\n\n                          item.errorDecryptingValueChanged = false;\n                          return valueChanged;\n                        });\n\n                        if (itemsWithErrorStatusChange.length > 0) {\n                          this.writeItemsToLocalStorage(itemsWithErrorStatusChange, false);\n                        }\n\n                        return _context92.abrupt(\"return\", items);\n\n                      case 9:\n                      case \"end\":\n                        return _context92.stop();\n                    }\n                  }\n                }, _callee92, this);\n              }));\n\n              function handleItemsResponse(_x117, _x118, _x119, _x120) {\n                return _ref98.apply(this, arguments);\n              }\n\n              return handleItemsResponse;\n            }()\n          }, {\n            key: \"refreshErroredItems\",\n            value: function () {\n              var _ref99 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee93() {\n                var erroredItems;\n                return regeneratorRuntime.wrap(function _callee93$(_context93) {\n                  while (1) {\n                    switch (_context93.prev = _context93.next) {\n                      case 0:\n                        erroredItems = this.modelManager.allNondummyItems.filter(function (item) {\n                          return item.errorDecrypting == true;\n                        });\n\n                        if (!(erroredItems.length > 0)) {\n                          _context93.next = 3;\n                          break;\n                        }\n\n                        return _context93.abrupt(\"return\", this.handleItemsResponse(erroredItems, null, SFModelManager.MappingSourceLocalRetrieved, SFSyncManager.KeyRequestLoadSaveAccount));\n\n                      case 3:\n                      case \"end\":\n                        return _context93.stop();\n                    }\n                  }\n                }, _callee93, this);\n              }));\n\n              function refreshErroredItems() {\n                return _ref99.apply(this, arguments);\n              }\n\n              return refreshErroredItems;\n            }()\n          }, {\n            key: \"handleUnsavedItemsResponse\",\n            value: function () {\n              var _ref100 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee94(unsaved) {\n                var _iteratorNormalCompletion45, _didIteratorError45, _iteratorError45, _iterator45, _step45, mapping, itemResponse, item, error, dup;\n\n                return regeneratorRuntime.wrap(function _callee94$(_context94) {\n                  while (1) {\n                    switch (_context94.prev = _context94.next) {\n                      case 0:\n                        if (!(unsaved.length == 0)) {\n                          _context94.next = 2;\n                          break;\n                        }\n\n                        return _context94.abrupt(\"return\");\n\n                      case 2:\n                        console.log(\"Handle Conflicted Items:\", unsaved);\n                        _iteratorNormalCompletion45 = true;\n                        _didIteratorError45 = false;\n                        _iteratorError45 = undefined;\n                        _context94.prev = 6;\n                        _iterator45 = unsaved[Symbol.iterator]();\n\n                      case 8:\n                        if (_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done) {\n                          _context94.next = 35;\n                          break;\n                        }\n\n                        mapping = _step45.value;\n                        itemResponse = mapping.item;\n                        _context94.t0 = SFJS.itemTransformer;\n                        _context94.t1 = [itemResponse];\n                        _context94.next = 15;\n                        return this.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);\n\n                      case 15:\n                        _context94.t2 = _context94.sent.keys;\n                        _context94.next = 18;\n                        return _context94.t0.decryptMultipleItems.call(_context94.t0, _context94.t1, _context94.t2);\n\n                      case 18:\n                        item = this.modelManager.findItem(itemResponse.uuid); // Could be deleted\n\n                        if (item) {\n                          _context94.next = 21;\n                          break;\n                        }\n\n                        return _context94.abrupt(\"continue\", 32);\n\n                      case 21:\n                        error = mapping.error;\n\n                        if (!(error.tag === \"uuid_conflict\")) {\n                          _context94.next = 27;\n                          break;\n                        }\n\n                        _context94.next = 25;\n                        return this.modelManager.alternateUUIDForItem(item);\n\n                      case 25:\n                        _context94.next = 32;\n                        break;\n\n                      case 27:\n                        if (!(error.tag === \"sync_conflict\")) {\n                          _context94.next = 32;\n                          break;\n                        }\n\n                        _context94.next = 30;\n                        return this.modelManager.createConflictedItem(itemResponse);\n\n                      case 30:\n                        dup = _context94.sent;\n\n                        if (!itemResponse.deleted && !item.isItemContentEqualWith(dup)) {\n                          this.modelManager.addConflictedItem(dup, item);\n                        }\n\n                      case 32:\n                        _iteratorNormalCompletion45 = true;\n                        _context94.next = 8;\n                        break;\n\n                      case 35:\n                        _context94.next = 41;\n                        break;\n\n                      case 37:\n                        _context94.prev = 37;\n                        _context94.t3 = _context94[\"catch\"](6);\n                        _didIteratorError45 = true;\n                        _iteratorError45 = _context94.t3;\n\n                      case 41:\n                        _context94.prev = 41;\n                        _context94.prev = 42;\n\n                        if (!_iteratorNormalCompletion45 && _iterator45.return) {\n                          _iterator45.return();\n                        }\n\n                      case 44:\n                        _context94.prev = 44;\n\n                        if (!_didIteratorError45) {\n                          _context94.next = 47;\n                          break;\n                        }\n\n                        throw _iteratorError45;\n\n                      case 47:\n                        return _context94.finish(44);\n\n                      case 48:\n                        return _context94.finish(41);\n\n                      case 49:\n                        // This will immediately result in \"Sync op in progress\" and sync will be queued.\n                        // That's ok. You actually want a sync op in progress so that the new items are saved to disk right away.\n                        // If you add a timeout here of 100ms, you'll avoid sync op in progress, but it will be a few ms before the items\n                        // are saved to disk, meaning that the user may see All changes saved a few ms before changes are saved to disk.\n                        // You could also just write to disk manually here, but syncing here is 100% sure to trigger sync op in progress as that's\n                        // where it's being called from.\n                        this.sync(null, {\n                          additionalFields: [\"created_at\", \"updated_at\"]\n                        });\n\n                      case 50:\n                      case \"end\":\n                        return _context94.stop();\n                    }\n                  }\n                }, _callee94, this, [[6, 37, 41, 49], [42,, 44, 48]]);\n              }));\n\n              function handleUnsavedItemsResponse(_x121) {\n                return _ref100.apply(this, arguments);\n              }\n\n              return handleUnsavedItemsResponse;\n            }()\n            /*\n              Executes a sync request with a blank sync token and high download limit. It will download all items,\n              but won't do anything with them other than decrypting, creating respective objects, and returning them to caller. (it does not map them nor establish their relationships)\n              The use case came primarly for clients who had ignored a certain content_type in sync, but later issued an update\n              indicated they actually did want to start handling that content type. In that case, they would need to download all items\n              freshly from the server.\n            */\n\n          }, {\n            key: \"stateless_downloadAllItems\",\n            value: function stateless_downloadAllItems() {\n              var _this24 = this;\n\n              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n              return new Promise(function () {\n                var _ref101 = _asyncToGenerator(\n                /*#__PURE__*/\n                regeneratorRuntime.mark(function _callee96(resolve, reject) {\n                  var params;\n                  return regeneratorRuntime.wrap(function _callee96$(_context96) {\n                    while (1) {\n                      switch (_context96.prev = _context96.next) {\n                        case 0:\n                          params = {\n                            limit: options.limit || 500,\n                            sync_token: options.syncToken,\n                            cursor_token: options.cursorToken,\n                            content_type: options.contentType,\n                            event: options.event\n                          };\n                          _context96.prev = 1;\n                          _context96.t0 = _this24.httpManager;\n                          _context96.next = 5;\n                          return _this24.getSyncURL();\n\n                        case 5:\n                          _context96.t1 = _context96.sent;\n                          _context96.t2 = params;\n\n                          _context96.t3 = function () {\n                            var _ref102 = _asyncToGenerator(\n                            /*#__PURE__*/\n                            regeneratorRuntime.mark(function _callee95(response) {\n                              var incomingItems, keys;\n                              return regeneratorRuntime.wrap(function _callee95$(_context95) {\n                                while (1) {\n                                  switch (_context95.prev = _context95.next) {\n                                    case 0:\n                                      if (!options.retrievedItems) {\n                                        options.retrievedItems = [];\n                                      }\n\n                                      incomingItems = response.retrieved_items;\n                                      _context95.next = 4;\n                                      return _this24.getActiveKeyInfo(SFSyncManager.KeyRequestLoadSaveAccount);\n\n                                    case 4:\n                                      keys = _context95.sent.keys;\n                                      _context95.next = 7;\n                                      return SFJS.itemTransformer.decryptMultipleItems(incomingItems, keys);\n\n                                    case 7:\n                                      options.retrievedItems = options.retrievedItems.concat(incomingItems.map(function (incomingItem) {\n                                        // Create model classes\n                                        return _this24.modelManager.createItem(incomingItem, true\n                                        /* dontNotifyObservers */\n                                        );\n                                      }));\n                                      options.syncToken = response.sync_token;\n                                      options.cursorToken = response.cursor_token;\n\n                                      if (options.cursorToken) {\n                                        _this24.stateless_downloadAllItems(options).then(resolve);\n                                      } else {\n                                        resolve(options.retrievedItems);\n                                      }\n\n                                    case 11:\n                                    case \"end\":\n                                      return _context95.stop();\n                                  }\n                                }\n                              }, _callee95, _this24);\n                            }));\n\n                            return function (_x125) {\n                              return _ref102.apply(this, arguments);\n                            };\n                          }();\n\n                          _context96.t4 = function (response, statusCode) {\n                            reject(response);\n                          };\n\n                          _context96.t0.postAbsolute.call(_context96.t0, _context96.t1, _context96.t2, _context96.t3, _context96.t4);\n\n                          _context96.next = 16;\n                          break;\n\n                        case 12:\n                          _context96.prev = 12;\n                          _context96.t5 = _context96[\"catch\"](1);\n                          console.log(\"Download all items exception caught:\", _context96.t5);\n                          reject(_context96.t5);\n\n                        case 16:\n                        case \"end\":\n                          return _context96.stop();\n                      }\n                    }\n                  }, _callee96, _this24, [[1, 12]]);\n                }));\n\n                return function (_x123, _x124) {\n                  return _ref101.apply(this, arguments);\n                };\n              }());\n            }\n          }, {\n            key: \"resolveOutOfSync\",\n            value: function () {\n              var _ref103 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee98() {\n                var _this25 = this;\n\n                return regeneratorRuntime.wrap(function _callee98$(_context98) {\n                  while (1) {\n                    switch (_context98.prev = _context98.next) {\n                      case 0:\n                        return _context98.abrupt(\"return\", this.stateless_downloadAllItems({\n                          event: \"resolve-out-of-sync\"\n                        }).then(function () {\n                          var _ref104 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee97(downloadedItems) {\n                            var itemsToMap, _iteratorNormalCompletion46, _didIteratorError46, _iteratorError46, _iterator46, _step46, downloadedItem, existingItem, contentDoesntMatch, duplicate;\n\n                            return regeneratorRuntime.wrap(function _callee97$(_context97) {\n                              while (1) {\n                                switch (_context97.prev = _context97.next) {\n                                  case 0:\n                                    itemsToMap = [];\n                                    _iteratorNormalCompletion46 = true;\n                                    _didIteratorError46 = false;\n                                    _iteratorError46 = undefined;\n                                    _context97.prev = 4;\n                                    _iterator46 = downloadedItems[Symbol.iterator]();\n\n                                  case 6:\n                                    if (_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done) {\n                                      _context97.next = 20;\n                                      break;\n                                    }\n\n                                    downloadedItem = _step46.value; // Note that deleted items will not be sent back by the server.\n\n                                    existingItem = _this25.modelManager.findItem(downloadedItem.uuid);\n\n                                    if (!existingItem) {\n                                      _context97.next = 16;\n                                      break;\n                                    } // Check if the content differs. If it does, create a new item, and do not map downloadedItem.\n\n\n                                    contentDoesntMatch = !downloadedItem.isItemContentEqualWith(existingItem);\n\n                                    if (!contentDoesntMatch) {\n                                      _context97.next = 16;\n                                      break;\n                                    }\n\n                                    _context97.next = 14;\n                                    return _this25.modelManager.createConflictedItem(existingItem, existingItem);\n\n                                  case 14:\n                                    duplicate = _context97.sent;\n\n                                    _this25.modelManager.addConflictedItem(duplicate, existingItem);\n\n                                  case 16:\n                                    // Map the downloadedItem as authoritive content. If client copy at all differed, we would have created a duplicate of it above and synced it.\n                                    // This is also neccessary to map the updated_at value from the server\n                                    itemsToMap.push(downloadedItem);\n\n                                  case 17:\n                                    _iteratorNormalCompletion46 = true;\n                                    _context97.next = 6;\n                                    break;\n\n                                  case 20:\n                                    _context97.next = 26;\n                                    break;\n\n                                  case 22:\n                                    _context97.prev = 22;\n                                    _context97.t0 = _context97[\"catch\"](4);\n                                    _didIteratorError46 = true;\n                                    _iteratorError46 = _context97.t0;\n\n                                  case 26:\n                                    _context97.prev = 26;\n                                    _context97.prev = 27;\n\n                                    if (!_iteratorNormalCompletion46 && _iterator46.return) {\n                                      _iterator46.return();\n                                    }\n\n                                  case 29:\n                                    _context97.prev = 29;\n\n                                    if (!_didIteratorError46) {\n                                      _context97.next = 32;\n                                      break;\n                                    }\n\n                                    throw _iteratorError46;\n\n                                  case 32:\n                                    return _context97.finish(29);\n\n                                  case 33:\n                                    return _context97.finish(26);\n\n                                  case 34:\n                                    _this25.modelManager.mapResponseItemsToLocalModelsWithOptions({\n                                      items: itemsToMap,\n                                      source: SFModelManager.MappingSourceRemoteRetrieved\n                                    }); // Save all items locally. Usually sync() would save downloaded items locally, but we're using stateless_sync here, so we have to do it manually\n\n\n                                    _context97.next = 37;\n                                    return _this25.writeItemsToLocalStorage(_this25.modelManager.allNondummyItems);\n\n                                  case 37:\n                                    return _context97.abrupt(\"return\", _this25.sync({\n                                      performIntegrityCheck: true\n                                    }));\n\n                                  case 38:\n                                  case \"end\":\n                                    return _context97.stop();\n                                }\n                              }\n                            }, _callee97, _this25, [[4, 22, 26, 34], [27,, 29, 33]]);\n                          }));\n\n                          return function (_x126) {\n                            return _ref104.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 1:\n                      case \"end\":\n                        return _context98.stop();\n                    }\n                  }\n                }, _callee98, this);\n              }));\n\n              function resolveOutOfSync() {\n                return _ref103.apply(this, arguments);\n              }\n\n              return resolveOutOfSync;\n            }()\n          }, {\n            key: \"handleSignout\",\n            value: function () {\n              var _ref105 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee99() {\n                return regeneratorRuntime.wrap(function _callee99$(_context99) {\n                  while (1) {\n                    switch (_context99.prev = _context99.next) {\n                      case 0:\n                        this._syncToken = null;\n                        this._cursorToken = null;\n                        this._queuedCallbacks = [];\n                        this.syncStatus = {};\n\n                      case 4:\n                      case \"end\":\n                        return _context99.stop();\n                    }\n                  }\n                }, _callee99, this);\n              }));\n\n              function handleSignout() {\n                return _ref105.apply(this, arguments);\n              }\n\n              return handleSignout;\n            }()\n          }, {\n            key: \"clearSyncToken\",\n            value: function () {\n              var _ref106 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee100() {\n                return regeneratorRuntime.wrap(function _callee100$(_context100) {\n                  while (1) {\n                    switch (_context100.prev = _context100.next) {\n                      case 0:\n                        this._syncToken = null;\n                        this._cursorToken = null;\n                        return _context100.abrupt(\"return\", this.storageManager.removeItem(\"syncToken\"));\n\n                      case 3:\n                      case \"end\":\n                        return _context100.stop();\n                    }\n                  }\n                }, _callee100, this);\n              }));\n\n              function clearSyncToken() {\n                return _ref106.apply(this, arguments);\n              }\n\n              return clearSyncToken;\n            }()\n          }, {\n            key: \"queuedCallbacks\",\n            get: function get() {\n              if (!this._queuedCallbacks) {\n                this._queuedCallbacks = [];\n              }\n\n              return this._queuedCallbacks;\n            }\n          }]);\n\n          return SFSyncManager;\n        }();\n\n        ;\n        var dateFormatter;\n\n        var SFItem = exports.SFItem = function () {\n          function SFItem() {\n            var json_obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            _classCallCheck(this, SFItem);\n\n            this.content = {};\n            this.referencingObjects = [];\n            this.updateFromJSON(json_obj);\n\n            if (!this.uuid) {\n              // on React Native, this method will not exist. UUID gen will be handled manually via async methods.\n              if (typeof SFJS !== \"undefined\" && SFJS.crypto.generateUUIDSync) {\n                this.uuid = SFJS.crypto.generateUUIDSync();\n              }\n            }\n\n            if (_typeof(this.content) === 'object' && !this.content.references) {\n              this.content.references = [];\n            }\n          } // On some platforms, syncrounous uuid generation is not available.\n          // Those platforms (mobile) must call this function manually.\n\n\n          _createClass(SFItem, [{\n            key: \"initUUID\",\n            value: function () {\n              var _ref107 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee101() {\n                return regeneratorRuntime.wrap(function _callee101$(_context101) {\n                  while (1) {\n                    switch (_context101.prev = _context101.next) {\n                      case 0:\n                        if (this.uuid) {\n                          _context101.next = 4;\n                          break;\n                        }\n\n                        _context101.next = 3;\n                        return SFJS.crypto.generateUUID();\n\n                      case 3:\n                        this.uuid = _context101.sent;\n\n                      case 4:\n                      case \"end\":\n                        return _context101.stop();\n                    }\n                  }\n                }, _callee101, this);\n              }));\n\n              function initUUID() {\n                return _ref107.apply(this, arguments);\n              }\n\n              return initUUID;\n            }()\n          }, {\n            key: \"updateFromJSON\",\n            value: function updateFromJSON(json) {\n              // Don't expect this to ever be the case but we're having a crash with Android and this is the only suspect.\n              if (!json) {\n                return;\n              } // Manually merge top level data instead of wholesale merge\n\n\n              this.created_at = json.created_at;\n              this.updated_at = json.updated_at;\n              this.deleted = json.deleted;\n              this.uuid = json.uuid;\n              this.enc_item_key = json.enc_item_key;\n              this.auth_hash = json.auth_hash;\n              this.auth_params = json.auth_params; // When updating from server response (as opposed to local json response), these keys will be missing.\n              // So we only want to update these values if they are explicitly present.\n\n              var clientKeys = [\"errorDecrypting\", \"dirty\", \"dirtyCount\", \"dummy\"];\n              var _iteratorNormalCompletion47 = true;\n              var _didIteratorError47 = false;\n              var _iteratorError47 = undefined;\n\n              try {\n                for (var _iterator47 = clientKeys[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {\n                  var key = _step47.value;\n\n                  if (json[key] !== undefined) {\n                    this[key] = json[key];\n                  }\n                } // Check if object has getter for content_type, and if so, skip\n\n              } catch (err) {\n                _didIteratorError47 = true;\n                _iteratorError47 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion47 && _iterator47.return) {\n                    _iterator47.return();\n                  }\n                } finally {\n                  if (_didIteratorError47) {\n                    throw _iteratorError47;\n                  }\n                }\n              }\n\n              if (!this.content_type) {\n                this.content_type = json.content_type;\n              } // this.content = json.content will copy it by reference rather than value. So we need to do a deep merge after.\n              // json.content can still be a string here. We copy it to this.content, then do a deep merge to transfer over all values.\n\n\n              if (json.errorDecrypting) {\n                this.content = json.content;\n              } else {\n                try {\n                  var parsedContent = typeof json.content === 'string' ? JSON.parse(json.content) : json.content;\n                  SFItem.deepMerge(this.contentObject, parsedContent);\n                } catch (e) {\n                  console.log(\"Error while updating item from json\", e);\n                }\n              }\n\n              if (this.created_at) {\n                this.created_at = new Date(this.created_at);\n                this.updated_at = new Date(this.updated_at);\n              } else {\n                this.created_at = new Date();\n                this.updated_at = new Date();\n              } // Allows the getter to be re-invoked\n\n\n              this._client_updated_at = null;\n\n              if (json.content) {\n                this.mapContentToLocalProperties(this.contentObject);\n              } else if (json.deleted == true) {\n                this.handleDeletedContent();\n              }\n            }\n          }, {\n            key: \"mapContentToLocalProperties\",\n            value: function mapContentToLocalProperties(contentObj) {}\n          }, {\n            key: \"createContentJSONFromProperties\",\n            value: function createContentJSONFromProperties() {\n              /*\n              NOTE: This function does have side effects and WILL modify our content.\n               Subclasses will override structureParams, and add their own custom content and properties to the object returned from structureParams\n              These are properties that this superclass will not be aware of, like 'title' or 'text'\n               When we call createContentJSONFromProperties, we want to update our own inherit 'content' field with the values returned from structureParams,\n              so that our content field is up to date.\n               Each subclass will call super.structureParams and merge it with its own custom result object.\n              Since our own structureParams gets a real-time copy of our content, it should be safe to merge the aggregate value back into our own content field.\n              */\n              var content = this.structureParams();\n              SFItem.deepMerge(this.contentObject, content); // Return the content item copy and not our actual value, as we don't want it to be mutated outside our control.\n\n              return content;\n            }\n          }, {\n            key: \"structureParams\",\n            value: function structureParams() {\n              return this.getContentCopy();\n            }\n            /* Allows the item to handle the case where the item is deleted and the content is null */\n\n          }, {\n            key: \"handleDeletedContent\",\n            value: function handleDeletedContent() {// Subclasses can override\n            }\n          }, {\n            key: \"setDirty\",\n            value: function setDirty(dirty, dontUpdateClientDate) {\n              this.dirty = dirty; // Allows the syncManager to check if an item has been marked dirty after a sync has been started\n              // This prevents it from clearing it as a dirty item after sync completion, if someone else has marked it dirty\n              // again after an ongoing sync.\n\n              if (!this.dirtyCount) {\n                this.dirtyCount = 0;\n              }\n\n              if (dirty) {\n                this.dirtyCount++;\n              } else {\n                this.dirtyCount = 0;\n              }\n\n              if (dirty && !dontUpdateClientDate) {\n                // Set the client modified date to now if marking the item as dirty\n                this.client_updated_at = new Date();\n              } else if (!this.hasRawClientUpdatedAtValue()) {\n                // copy updated_at\n                this.client_updated_at = new Date(this.updated_at);\n              }\n            }\n          }, {\n            key: \"updateLocalRelationships\",\n            value: function updateLocalRelationships() {// optional override\n            }\n          }, {\n            key: \"addItemAsRelationship\",\n            value: function addItemAsRelationship(item) {\n              item.setIsBeingReferencedBy(this);\n\n              if (this.hasRelationshipWithItem(item)) {\n                return;\n              }\n\n              var references = this.content.references || [];\n              references.push({\n                uuid: item.uuid,\n                content_type: item.content_type\n              });\n              this.content.references = references;\n            }\n          }, {\n            key: \"removeItemAsRelationship\",\n            value: function removeItemAsRelationship(item) {\n              item.setIsNoLongerBeingReferencedBy(this);\n              this.removeReferenceWithUuid(item.uuid);\n            } // When another object has a relationship with us, we push that object into memory here.\n            // We use this so that when `this` is deleted, we're able to update the references of those other objects.\n\n          }, {\n            key: \"setIsBeingReferencedBy\",\n            value: function setIsBeingReferencedBy(item) {\n              if (!_.find(this.referencingObjects, {\n                uuid: item.uuid\n              })) {\n                this.referencingObjects.push(item);\n              }\n            }\n          }, {\n            key: \"setIsNoLongerBeingReferencedBy\",\n            value: function setIsNoLongerBeingReferencedBy(item) {\n              _.remove(this.referencingObjects, {\n                uuid: item.uuid\n              }); // Legacy two-way relationships should be handled here\n\n\n              if (this.hasRelationshipWithItem(item)) {\n                this.removeReferenceWithUuid(item.uuid); // We really shouldn't have the authority to set this item as dirty, but it's the only way to save this change.\n\n                this.setDirty(true);\n              }\n            }\n          }, {\n            key: \"removeReferenceWithUuid\",\n            value: function removeReferenceWithUuid(uuid) {\n              var references = this.content.references || [];\n              references = references.filter(function (r) {\n                return r.uuid != uuid;\n              });\n              this.content.references = references;\n            }\n          }, {\n            key: \"hasRelationshipWithItem\",\n            value: function hasRelationshipWithItem(item) {\n              var target = this.content.references.find(function (r) {\n                return r.uuid == item.uuid;\n              });\n              return target != null;\n            }\n          }, {\n            key: \"isBeingRemovedLocally\",\n            value: function isBeingRemovedLocally() {}\n          }, {\n            key: \"didFinishSyncing\",\n            value: function didFinishSyncing() {}\n          }, {\n            key: \"informReferencesOfUUIDChange\",\n            value: function informReferencesOfUUIDChange(oldUUID, newUUID) {// optional override\n            }\n          }, {\n            key: \"potentialItemOfInterestHasChangedItsUUID\",\n            value: function potentialItemOfInterestHasChangedItsUUID(newItem, oldUUID, newUUID) {\n              // optional override\n              var _iteratorNormalCompletion48 = true;\n              var _didIteratorError48 = false;\n              var _iteratorError48 = undefined;\n\n              try {\n                for (var _iterator48 = this.content.references[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {\n                  var reference = _step48.value;\n\n                  if (reference.uuid == oldUUID) {\n                    reference.uuid = newUUID;\n                    this.setDirty(true);\n                  }\n                }\n              } catch (err) {\n                _didIteratorError48 = true;\n                _iteratorError48 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion48 && _iterator48.return) {\n                    _iterator48.return();\n                  }\n                } finally {\n                  if (_didIteratorError48) {\n                    throw _iteratorError48;\n                  }\n                }\n              }\n            }\n          }, {\n            key: \"doNotEncrypt\",\n            value: function doNotEncrypt() {\n              return false;\n            }\n            /*\n            App Data\n            */\n\n          }, {\n            key: \"setDomainDataItem\",\n            value: function setDomainDataItem(key, value, domain) {\n              if (!domain) {\n                console.error(\"SFItem.AppDomain needs to be set.\");\n                return;\n              }\n\n              if (this.errorDecrypting) {\n                return;\n              }\n\n              if (!this.content.appData) {\n                this.content.appData = {};\n              }\n\n              var data = this.content.appData[domain];\n\n              if (!data) {\n                data = {};\n              }\n\n              data[key] = value;\n              this.content.appData[domain] = data;\n            }\n          }, {\n            key: \"getDomainDataItem\",\n            value: function getDomainDataItem(key, domain) {\n              if (!domain) {\n                console.error(\"SFItem.AppDomain needs to be set.\");\n                return;\n              }\n\n              if (this.errorDecrypting) {\n                return;\n              }\n\n              if (!this.content.appData) {\n                this.content.appData = {};\n              }\n\n              var data = this.content.appData[domain];\n\n              if (data) {\n                return data[key];\n              } else {\n                return null;\n              }\n            }\n          }, {\n            key: \"setAppDataItem\",\n            value: function setAppDataItem(key, value) {\n              this.setDomainDataItem(key, value, SFItem.AppDomain);\n            }\n          }, {\n            key: \"getAppDataItem\",\n            value: function getAppDataItem(key) {\n              return this.getDomainDataItem(key, SFItem.AppDomain);\n            }\n          }, {\n            key: \"hasRawClientUpdatedAtValue\",\n            value: function hasRawClientUpdatedAtValue() {\n              return this.getAppDataItem(\"client_updated_at\") != null;\n            }\n          }, {\n            key: \"keysToIgnoreWhenCheckingContentEquality\",\n\n            /*\n              During sync conflicts, when determing whether to create a duplicate for an item, we can omit keys that have no\n              meaningful weight and can be ignored. For example, if one component has active = true and another component has active = false,\n              it would be silly to duplicate them, so instead we ignore this.\n             */\n            value: function keysToIgnoreWhenCheckingContentEquality() {\n              return [];\n            } // Same as above, but keys inside appData[Item.AppDomain]\n\n          }, {\n            key: \"appDataKeysToIgnoreWhenCheckingContentEquality\",\n            value: function appDataKeysToIgnoreWhenCheckingContentEquality() {\n              return [\"client_updated_at\"];\n            }\n          }, {\n            key: \"getContentCopy\",\n            value: function getContentCopy() {\n              var contentCopy = JSON.parse(JSON.stringify(this.content));\n              return contentCopy;\n            }\n          }, {\n            key: \"isItemContentEqualWith\",\n            value: function isItemContentEqualWith(otherItem) {\n              var omit = function omit(obj, keys) {\n                if (!obj) {\n                  return obj;\n                }\n\n                var _iteratorNormalCompletion49 = true;\n                var _didIteratorError49 = false;\n                var _iteratorError49 = undefined;\n\n                try {\n                  for (var _iterator49 = keys[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {\n                    var key = _step49.value;\n                    delete obj[key];\n                  }\n                } catch (err) {\n                  _didIteratorError49 = true;\n                  _iteratorError49 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion49 && _iterator49.return) {\n                      _iterator49.return();\n                    }\n                  } finally {\n                    if (_didIteratorError49) {\n                      throw _iteratorError49;\n                    }\n                  }\n                }\n\n                return obj;\n              }; // Create copies of objects before running omit as not to modify source values directly.\n\n\n              var leftContent = this.getContentCopy();\n\n              if (leftContent.appData) {\n                omit(leftContent.appData[SFItem.AppDomain], this.appDataKeysToIgnoreWhenCheckingContentEquality());\n              }\n\n              leftContent = omit(leftContent, this.keysToIgnoreWhenCheckingContentEquality());\n              var rightContent = otherItem.getContentCopy();\n\n              if (rightContent.appData) {\n                omit(rightContent.appData[SFItem.AppDomain], otherItem.appDataKeysToIgnoreWhenCheckingContentEquality());\n              }\n\n              rightContent = omit(rightContent, otherItem.keysToIgnoreWhenCheckingContentEquality());\n              return JSON.stringify(leftContent) === JSON.stringify(rightContent);\n            }\n          }, {\n            key: \"satisfiesPredicate\",\n            value: function satisfiesPredicate(predicate) {\n              /*\n              Predicate is an SFPredicate having properties:\n              {\n                keypath: String,\n                operator: String,\n                value: object\n              }\n               */\n              return SFPredicate.ItemSatisfiesPredicate(this, predicate);\n            }\n            /*\n            Dates\n            */\n\n          }, {\n            key: \"createdAtString\",\n            value: function createdAtString() {\n              return this.dateToLocalizedString(this.created_at);\n            }\n          }, {\n            key: \"updatedAtString\",\n            value: function updatedAtString() {\n              return this.dateToLocalizedString(this.client_updated_at);\n            }\n          }, {\n            key: \"updatedAtTimestamp\",\n            value: function updatedAtTimestamp() {\n              return this.updated_at.getTime();\n            }\n          }, {\n            key: \"dateToLocalizedString\",\n            value: function dateToLocalizedString(date) {\n              if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {\n                if (!dateFormatter) {\n                  var locale = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language;\n                  dateFormatter = new Intl.DateTimeFormat(locale, {\n                    year: 'numeric',\n                    month: 'short',\n                    day: '2-digit',\n                    weekday: 'long',\n                    hour: '2-digit',\n                    minute: '2-digit'\n                  });\n                }\n\n                return dateFormatter.format(date);\n              } else {\n                // IE < 11, Safari <= 9.0.\n                // In English, this generates the string most similar to\n                // the toLocaleDateString() result above.\n                return date.toDateString() + ' ' + date.toLocaleTimeString();\n              }\n            }\n          }, {\n            key: \"contentObject\",\n            get: function get() {\n              if (this.errorDecrypting) {\n                return this.content;\n              }\n\n              if (!this.content) {\n                this.content = {};\n                return this.content;\n              }\n\n              if (this.content !== null && _typeof(this.content) === 'object') {\n                // this is the case when mapping localStorage content, in which case the content is already parsed\n                return this.content;\n              }\n\n              try {\n                var content = JSON.parse(this.content);\n                this.content = content;\n                return this.content;\n              } catch (e) {\n                console.log(\"Error parsing json\", e, this);\n                this.content = {};\n                return this.content;\n              }\n            }\n          }, {\n            key: \"pinned\",\n            get: function get() {\n              return this.getAppDataItem(\"pinned\");\n            }\n          }, {\n            key: \"archived\",\n            get: function get() {\n              return this.getAppDataItem(\"archived\");\n            }\n          }, {\n            key: \"locked\",\n            get: function get() {\n              return this.getAppDataItem(\"locked\");\n            } // May be used by clients to display the human readable type for this item. Should be overriden by subclasses.\n\n          }, {\n            key: \"displayName\",\n            get: function get() {\n              return \"Item\";\n            }\n          }, {\n            key: \"client_updated_at\",\n            get: function get() {\n              if (!this._client_updated_at) {\n                var saved = this.getAppDataItem(\"client_updated_at\");\n\n                if (saved) {\n                  this._client_updated_at = new Date(saved);\n                } else {\n                  this._client_updated_at = new Date(this.updated_at);\n                }\n              }\n\n              return this._client_updated_at;\n            },\n            set: function set(date) {\n              this._client_updated_at = date;\n              this.setAppDataItem(\"client_updated_at\", date);\n            }\n          }], [{\n            key: \"deepMerge\",\n            value: function deepMerge(a, b) {\n              // By default _.merge will not merge a full array with an empty one.\n              // We want to replace arrays wholesale\n              function mergeCopyArrays(objValue, srcValue) {\n                if (_.isArray(objValue)) {\n                  return srcValue;\n                }\n              }\n\n              _.mergeWith(a, b, mergeCopyArrays);\n\n              return a;\n            }\n          }]);\n\n          return SFItem;\n        }();\n\n        ;\n\n        var SFItemParams = exports.SFItemParams = function () {\n          function SFItemParams(item, keys, auth_params) {\n            _classCallCheck(this, SFItemParams);\n\n            this.item = item;\n            this.keys = keys;\n            this.auth_params = auth_params;\n\n            if (this.keys && !this.auth_params) {\n              throw \"SFItemParams.auth_params must be supplied if supplying keys.\";\n            }\n\n            if (this.auth_params && !this.auth_params.version) {\n              throw \"SFItemParams.auth_params is missing version\";\n            }\n          }\n\n          _createClass(SFItemParams, [{\n            key: \"paramsForExportFile\",\n            value: function () {\n              var _ref108 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee102(includeDeleted) {\n                var result;\n                return regeneratorRuntime.wrap(function _callee102$(_context102) {\n                  while (1) {\n                    switch (_context102.prev = _context102.next) {\n                      case 0:\n                        this.additionalFields = [\"updated_at\"];\n                        this.forExportFile = true;\n\n                        if (!includeDeleted) {\n                          _context102.next = 6;\n                          break;\n                        }\n\n                        return _context102.abrupt(\"return\", this.__params());\n\n                      case 6:\n                        _context102.next = 8;\n                        return this.__params();\n\n                      case 8:\n                        result = _context102.sent;\n                        return _context102.abrupt(\"return\", _.omit(result, [\"deleted\"]));\n\n                      case 10:\n                      case \"end\":\n                        return _context102.stop();\n                    }\n                  }\n                }, _callee102, this);\n              }));\n\n              function paramsForExportFile(_x128) {\n                return _ref108.apply(this, arguments);\n              }\n\n              return paramsForExportFile;\n            }()\n          }, {\n            key: \"paramsForExtension\",\n            value: function () {\n              var _ref109 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee103() {\n                return regeneratorRuntime.wrap(function _callee103$(_context103) {\n                  while (1) {\n                    switch (_context103.prev = _context103.next) {\n                      case 0:\n                        return _context103.abrupt(\"return\", this.paramsForExportFile());\n\n                      case 1:\n                      case \"end\":\n                        return _context103.stop();\n                    }\n                  }\n                }, _callee103, this);\n              }));\n\n              function paramsForExtension() {\n                return _ref109.apply(this, arguments);\n              }\n\n              return paramsForExtension;\n            }()\n          }, {\n            key: \"paramsForLocalStorage\",\n            value: function () {\n              var _ref110 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee104() {\n                return regeneratorRuntime.wrap(function _callee104$(_context104) {\n                  while (1) {\n                    switch (_context104.prev = _context104.next) {\n                      case 0:\n                        this.additionalFields = [\"updated_at\", \"dirty\", \"errorDecrypting\"];\n                        this.forExportFile = true;\n                        return _context104.abrupt(\"return\", this.__params());\n\n                      case 3:\n                      case \"end\":\n                        return _context104.stop();\n                    }\n                  }\n                }, _callee104, this);\n              }));\n\n              function paramsForLocalStorage() {\n                return _ref110.apply(this, arguments);\n              }\n\n              return paramsForLocalStorage;\n            }()\n          }, {\n            key: \"paramsForSync\",\n            value: function () {\n              var _ref111 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee105() {\n                return regeneratorRuntime.wrap(function _callee105$(_context105) {\n                  while (1) {\n                    switch (_context105.prev = _context105.next) {\n                      case 0:\n                        return _context105.abrupt(\"return\", this.__params());\n\n                      case 1:\n                      case \"end\":\n                        return _context105.stop();\n                    }\n                  }\n                }, _callee105, this);\n              }));\n\n              function paramsForSync() {\n                return _ref111.apply(this, arguments);\n              }\n\n              return paramsForSync;\n            }()\n          }, {\n            key: \"__params\",\n            value: function () {\n              var _ref112 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee106() {\n                var params, doNotEncrypt, encryptedParams;\n                return regeneratorRuntime.wrap(function _callee106$(_context106) {\n                  while (1) {\n                    switch (_context106.prev = _context106.next) {\n                      case 0:\n                        params = {\n                          uuid: this.item.uuid,\n                          content_type: this.item.content_type,\n                          deleted: this.item.deleted,\n                          created_at: this.item.created_at\n                        };\n\n                        if (this.item.errorDecrypting) {\n                          _context106.next = 23;\n                          break;\n                        } // Items should always be encrypted for export files. Only respect item.doNotEncrypt for remote sync params.\n\n\n                        doNotEncrypt = this.item.doNotEncrypt() && !this.forExportFile;\n\n                        if (!(this.keys && !doNotEncrypt)) {\n                          _context106.next = 11;\n                          break;\n                        }\n\n                        _context106.next = 6;\n                        return SFJS.itemTransformer.encryptItem(this.item, this.keys, this.auth_params);\n\n                      case 6:\n                        encryptedParams = _context106.sent;\n\n                        _.merge(params, encryptedParams);\n\n                        if (this.auth_params.version !== \"001\") {\n                          params.auth_hash = null;\n                        }\n\n                        _context106.next = 21;\n                        break;\n\n                      case 11:\n                        if (!this.forExportFile) {\n                          _context106.next = 15;\n                          break;\n                        }\n\n                        _context106.t0 = this.item.createContentJSONFromProperties();\n                        _context106.next = 19;\n                        break;\n\n                      case 15:\n                        _context106.next = 17;\n                        return SFJS.crypto.base64(JSON.stringify(this.item.createContentJSONFromProperties()));\n\n                      case 17:\n                        _context106.t1 = _context106.sent;\n                        _context106.t0 = \"000\" + _context106.t1;\n\n                      case 19:\n                        params.content = _context106.t0;\n\n                        if (!this.forExportFile) {\n                          params.enc_item_key = null;\n                          params.auth_hash = null;\n                        }\n\n                      case 21:\n                        _context106.next = 26;\n                        break;\n\n                      case 23:\n                        // Error decrypting, keep \"content\" and related fields as is (and do not try to encrypt, otherwise that would be undefined behavior)\n                        params.content = this.item.content;\n                        params.enc_item_key = this.item.enc_item_key;\n                        params.auth_hash = this.item.auth_hash;\n\n                      case 26:\n                        if (this.additionalFields) {\n                          _.merge(params, _.pick(this.item, this.additionalFields));\n                        }\n\n                        return _context106.abrupt(\"return\", params);\n\n                      case 28:\n                      case \"end\":\n                        return _context106.stop();\n                    }\n                  }\n                }, _callee106, this);\n              }));\n\n              function __params() {\n                return _ref112.apply(this, arguments);\n              }\n\n              return __params;\n            }()\n          }]);\n\n          return SFItemParams;\n        }();\n\n        ;\n\n        var SFPredicate = exports.SFPredicate = function () {\n          function SFPredicate(keypath, operator, value) {\n            _classCallCheck(this, SFPredicate);\n\n            this.keypath = keypath;\n            this.operator = operator;\n            this.value = value; // Preprocessing to make predicate evaluation faster.\n            // Won't recurse forever, but with arbitrarily large input could get stuck. Hope there are input size limits\n            // somewhere else.\n\n            if (SFPredicate.IsRecursiveOperator(this.operator)) {\n              this.value = this.value.map(SFPredicate.fromArray);\n            }\n          }\n\n          _createClass(SFPredicate, null, [{\n            key: \"fromArray\",\n            value: function fromArray(array) {\n              return new SFPredicate(array[0], array[1], array[2]);\n            }\n          }, {\n            key: \"ObjectSatisfiesPredicate\",\n            value: function ObjectSatisfiesPredicate(object, predicate) {\n              // Predicates may not always be created using the official constructor\n              // so if it's still an array here, convert to object\n              if (Array.isArray(predicate)) {\n                predicate = this.fromArray(predicate);\n              }\n\n              if (SFPredicate.IsRecursiveOperator(predicate.operator)) {\n                if (predicate.operator === \"and\") {\n                  var _iteratorNormalCompletion50 = true;\n                  var _didIteratorError50 = false;\n                  var _iteratorError50 = undefined;\n\n                  try {\n                    for (var _iterator50 = predicate.value[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {\n                      var subPredicate = _step50.value;\n\n                      if (!this.ObjectSatisfiesPredicate(object, subPredicate)) {\n                        return false;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError50 = true;\n                    _iteratorError50 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion50 && _iterator50.return) {\n                        _iterator50.return();\n                      }\n                    } finally {\n                      if (_didIteratorError50) {\n                        throw _iteratorError50;\n                      }\n                    }\n                  }\n\n                  return true;\n                }\n\n                if (predicate.operator === \"or\") {\n                  var _iteratorNormalCompletion51 = true;\n                  var _didIteratorError51 = false;\n                  var _iteratorError51 = undefined;\n\n                  try {\n                    for (var _iterator51 = predicate.value[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {\n                      var subPredicate = _step51.value;\n\n                      if (this.ObjectSatisfiesPredicate(object, subPredicate)) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError51 = true;\n                    _iteratorError51 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion51 && _iterator51.return) {\n                        _iterator51.return();\n                      }\n                    } finally {\n                      if (_didIteratorError51) {\n                        throw _iteratorError51;\n                      }\n                    }\n                  }\n\n                  return false;\n                }\n              }\n\n              var predicateValue = predicate.value;\n\n              if (typeof predicateValue == 'string' && predicateValue.includes(\".ago\")) {\n                predicateValue = this.DateFromString(predicateValue);\n              }\n\n              var valueAtKeyPath = predicate.keypath.split('.').reduce(function (previous, current) {\n                return previous && previous[current];\n              }, object);\n              var falseyValues = [false, \"\", null, undefined, NaN]; // If the value at keyPath is undefined, either because the property is nonexistent or the value is null.\n\n              if (valueAtKeyPath == undefined) {\n                if (predicate.operator == \"!=\") {\n                  return !falseyValues.includes(predicate.value);\n                } else {\n                  return falseyValues.includes(predicate.value);\n                }\n              }\n\n              if (predicate.operator == \"=\") {\n                // Use array comparison\n                if (Array.isArray(valueAtKeyPath)) {\n                  return JSON.stringify(valueAtKeyPath) == JSON.stringify(predicateValue);\n                } else {\n                  return valueAtKeyPath == predicateValue;\n                }\n              } else if (predicate.operator == \"!=\") {\n                // Use array comparison\n                if (Array.isArray(valueAtKeyPath)) {\n                  return JSON.stringify(valueAtKeyPath) != JSON.stringify(predicateValue);\n                } else {\n                  return valueAtKeyPath !== predicateValue;\n                }\n              } else if (predicate.operator == \"<\") {\n                return valueAtKeyPath < predicateValue;\n              } else if (predicate.operator == \">\") {\n                return valueAtKeyPath > predicateValue;\n              } else if (predicate.operator == \"<=\") {\n                return valueAtKeyPath <= predicateValue;\n              } else if (predicate.operator == \">=\") {\n                return valueAtKeyPath >= predicateValue;\n              } else if (predicate.operator == \"startsWith\") {\n                return valueAtKeyPath.startsWith(predicateValue);\n              } else if (predicate.operator == \"in\") {\n                return predicateValue.indexOf(valueAtKeyPath) != -1;\n              } else if (predicate.operator == \"includes\") {\n                return this.resolveIncludesPredicate(valueAtKeyPath, predicateValue);\n              } else if (predicate.operator == \"matches\") {\n                var regex = new RegExp(predicateValue);\n                return regex.test(valueAtKeyPath);\n              }\n\n              return false;\n            }\n          }, {\n            key: \"resolveIncludesPredicate\",\n            value: function resolveIncludesPredicate(valueAtKeyPath, predicateValue) {\n              // includes can be a string  or a predicate (in array form)\n              if (typeof predicateValue == 'string') {\n                // if string, simply check if the valueAtKeyPath includes the predicate value\n                return valueAtKeyPath.includes(predicateValue);\n              } else {\n                // is a predicate array or predicate object\n                var innerPredicate;\n\n                if (Array.isArray(predicateValue)) {\n                  innerPredicate = SFPredicate.fromArray(predicateValue);\n                } else {\n                  innerPredicate = predicateValue;\n                }\n\n                var _iteratorNormalCompletion52 = true;\n                var _didIteratorError52 = false;\n                var _iteratorError52 = undefined;\n\n                try {\n                  for (var _iterator52 = valueAtKeyPath[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {\n                    var obj = _step52.value;\n\n                    if (this.ObjectSatisfiesPredicate(obj, innerPredicate)) {\n                      return true;\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError52 = true;\n                  _iteratorError52 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion52 && _iterator52.return) {\n                      _iterator52.return();\n                    }\n                  } finally {\n                    if (_didIteratorError52) {\n                      throw _iteratorError52;\n                    }\n                  }\n                }\n\n                return false;\n              }\n            }\n          }, {\n            key: \"ItemSatisfiesPredicate\",\n            value: function ItemSatisfiesPredicate(item, predicate) {\n              if (Array.isArray(predicate)) {\n                predicate = SFPredicate.fromArray(predicate);\n              }\n\n              return this.ObjectSatisfiesPredicate(item, predicate);\n            }\n          }, {\n            key: \"ItemSatisfiesPredicates\",\n            value: function ItemSatisfiesPredicates(item, predicates) {\n              var _iteratorNormalCompletion53 = true;\n              var _didIteratorError53 = false;\n              var _iteratorError53 = undefined;\n\n              try {\n                for (var _iterator53 = predicates[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {\n                  var predicate = _step53.value;\n\n                  if (!this.ItemSatisfiesPredicate(item, predicate)) {\n                    return false;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError53 = true;\n                _iteratorError53 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion53 && _iterator53.return) {\n                    _iterator53.return();\n                  }\n                } finally {\n                  if (_didIteratorError53) {\n                    throw _iteratorError53;\n                  }\n                }\n              }\n\n              return true;\n            }\n          }, {\n            key: \"DateFromString\",\n            value: function DateFromString(string) {\n              // x.days.ago, x.hours.ago\n              var comps = string.split(\".\");\n              var unit = comps[1];\n              var date = new Date();\n              var offset = parseInt(comps[0]);\n\n              if (unit == \"days\") {\n                date.setDate(date.getDate() - offset);\n              } else if (unit == \"hours\") {\n                date.setHours(date.getHours() - offset);\n              }\n\n              return date;\n            }\n          }, {\n            key: \"IsRecursiveOperator\",\n            value: function IsRecursiveOperator(operator) {\n              return [\"and\", \"or\"].includes(operator);\n            }\n          }]);\n\n          return SFPredicate;\n        }();\n\n        ;\n\n        var SFPrivileges = exports.SFPrivileges = function (_SFItem) {\n          _inherits(SFPrivileges, _SFItem);\n\n          _createClass(SFPrivileges, null, [{\n            key: \"contentType\",\n            value: function contentType() {\n              // It has prefix SN since it was originally imported from SN codebase\n              return \"SN|Privileges\";\n            }\n          }]);\n\n          function SFPrivileges(json_obj) {\n            _classCallCheck(this, SFPrivileges);\n\n            var _this26 = _possibleConstructorReturn(this, (SFPrivileges.__proto__ || Object.getPrototypeOf(SFPrivileges)).call(this, json_obj));\n\n            if (!_this26.content.desktopPrivileges) {\n              _this26.content.desktopPrivileges = {};\n            }\n\n            return _this26;\n          }\n\n          _createClass(SFPrivileges, [{\n            key: \"setCredentialsForAction\",\n            value: function setCredentialsForAction(action, credentials) {\n              this.content.desktopPrivileges[action] = credentials;\n            }\n          }, {\n            key: \"getCredentialsForAction\",\n            value: function getCredentialsForAction(action) {\n              return this.content.desktopPrivileges[action] || [];\n            }\n          }, {\n            key: \"toggleCredentialForAction\",\n            value: function toggleCredentialForAction(action, credential) {\n              if (this.isCredentialRequiredForAction(action, credential)) {\n                this.removeCredentialForAction(action, credential);\n              } else {\n                this.addCredentialForAction(action, credential);\n              }\n            }\n          }, {\n            key: \"removeCredentialForAction\",\n            value: function removeCredentialForAction(action, credential) {\n              _.pull(this.content.desktopPrivileges[action], credential);\n            }\n          }, {\n            key: \"addCredentialForAction\",\n            value: function addCredentialForAction(action, credential) {\n              var credentials = this.getCredentialsForAction(action);\n              credentials.push(credential);\n              this.setCredentialsForAction(action, credentials);\n            }\n          }, {\n            key: \"isCredentialRequiredForAction\",\n            value: function isCredentialRequiredForAction(action, credential) {\n              var credentialsRequired = this.getCredentialsForAction(action);\n              return credentialsRequired.includes(credential);\n            }\n          }]);\n\n          return SFPrivileges;\n        }(SFItem);\n\n        ;\n        /*\n         Important: This is the only object in the session history domain that is persistable.\n          A history session contains one main content object:\n         the itemUUIDToItemHistoryMapping. This is a dictionary whose keys are item uuids,\n         and each value is an SFItemHistory object.\n          Each SFItemHistory object contains an array called `entires` which contain `SFItemHistory` entries (or subclasses, if the\n         `SFItemHistory.HistoryEntryClassMapping` class property value is set.)\n        */\n        // See default class values at bottom of this file, including `SFHistorySession.LargeItemEntryAmountThreshold`.\n\n        var SFHistorySession = exports.SFHistorySession = function (_SFItem2) {\n          _inherits(SFHistorySession, _SFItem2);\n\n          function SFHistorySession(json_obj) {\n            _classCallCheck(this, SFHistorySession);\n            /*\n              Our .content params:\n              {\n                itemUUIDToItemHistoryMapping\n              }\n             */\n\n\n            var _this27 = _possibleConstructorReturn(this, (SFHistorySession.__proto__ || Object.getPrototypeOf(SFHistorySession)).call(this, json_obj));\n\n            if (!_this27.content.itemUUIDToItemHistoryMapping) {\n              _this27.content.itemUUIDToItemHistoryMapping = {};\n            } // When initializing from a json_obj, we want to deserialize the item history JSON into SFItemHistory objects.\n\n\n            var uuids = Object.keys(_this27.content.itemUUIDToItemHistoryMapping);\n            uuids.forEach(function (itemUUID) {\n              var itemHistory = _this27.content.itemUUIDToItemHistoryMapping[itemUUID];\n              _this27.content.itemUUIDToItemHistoryMapping[itemUUID] = new SFItemHistory(itemHistory);\n            });\n            return _this27;\n          }\n\n          _createClass(SFHistorySession, [{\n            key: \"addEntryForItem\",\n            value: function addEntryForItem(item) {\n              var itemHistory = this.historyForItem(item);\n              var entry = itemHistory.addHistoryEntryForItem(item);\n              return entry;\n            }\n          }, {\n            key: \"historyForItem\",\n            value: function historyForItem(item) {\n              var history = this.content.itemUUIDToItemHistoryMapping[item.uuid];\n\n              if (!history) {\n                history = this.content.itemUUIDToItemHistoryMapping[item.uuid] = new SFItemHistory();\n              }\n\n              return history;\n            }\n          }, {\n            key: \"clearItemHistory\",\n            value: function clearItemHistory(item) {\n              this.historyForItem(item).clear();\n            }\n          }, {\n            key: \"clearAllHistory\",\n            value: function clearAllHistory() {\n              this.content.itemUUIDToItemHistoryMapping = {};\n            }\n          }, {\n            key: \"optimizeHistoryForItem\",\n            value: function optimizeHistoryForItem(item) {\n              // Clean up if there are too many revisions. Note SFHistorySession.LargeItemEntryAmountThreshold is the amount of revisions which above, call\n              // for an optimization. An optimization may not remove entries above this threshold. It will determine what it should keep and what it shouldn't.\n              // So, it is possible to have a threshold of 60 but have 600 entries, if the item history deems those worth keeping.\n              var itemHistory = this.historyForItem(item);\n\n              if (itemHistory.entries.length > SFHistorySession.LargeItemEntryAmountThreshold) {\n                itemHistory.optimize();\n              }\n            }\n          }]);\n\n          return SFHistorySession;\n        }(SFItem); // See comment in `this.optimizeHistoryForItem`\n\n\n        SFHistorySession.LargeItemEntryAmountThreshold = 60;\n        ; // See default class values at bottom of this file, including `SFItemHistory.LargeEntryDeltaThreshold`.\n\n        var SFItemHistory = exports.SFItemHistory = function () {\n          function SFItemHistory() {\n            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            _classCallCheck(this, SFItemHistory);\n\n            if (!this.entries) {\n              this.entries = [];\n            } // Deserialize the entries into entry objects.\n\n\n            if (params.entries) {\n              var _iteratorNormalCompletion54 = true;\n              var _didIteratorError54 = false;\n              var _iteratorError54 = undefined;\n\n              try {\n                for (var _iterator54 = params.entries[Symbol.iterator](), _step54; !(_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done); _iteratorNormalCompletion54 = true) {\n                  var entryParams = _step54.value;\n                  var entry = this.createEntryForItem(entryParams.item);\n                  entry.setPreviousEntry(this.getLastEntry());\n                  this.entries.push(entry);\n                }\n              } catch (err) {\n                _didIteratorError54 = true;\n                _iteratorError54 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion54 && _iterator54.return) {\n                    _iterator54.return();\n                  }\n                } finally {\n                  if (_didIteratorError54) {\n                    throw _iteratorError54;\n                  }\n                }\n              }\n            }\n          }\n\n          _createClass(SFItemHistory, [{\n            key: \"createEntryForItem\",\n            value: function createEntryForItem(item) {\n              var historyItemClass = SFItemHistory.HistoryEntryClassMapping && SFItemHistory.HistoryEntryClassMapping[item.content_type];\n\n              if (!historyItemClass) {\n                historyItemClass = SFItemHistoryEntry;\n              }\n\n              var entry = new historyItemClass(item);\n              return entry;\n            }\n          }, {\n            key: \"getLastEntry\",\n            value: function getLastEntry() {\n              return this.entries[this.entries.length - 1];\n            }\n          }, {\n            key: \"addHistoryEntryForItem\",\n            value: function addHistoryEntryForItem(item) {\n              var prospectiveEntry = this.createEntryForItem(item);\n              var previousEntry = this.getLastEntry();\n              prospectiveEntry.setPreviousEntry(previousEntry); // Don't add first revision if text length is 0, as this means it's a new note.\n              // Actually, nevermind. If we do this, the first character added to a new note\n              // will be displayed as \"1 characters loaded\".\n              // if(!previousRevision && prospectiveRevision.textCharDiffLength == 0) {\n              //   return;\n              // }\n              // Don't add if text is the same\n\n              if (prospectiveEntry.isSameAsEntry(previousEntry)) {\n                return;\n              }\n\n              this.entries.push(prospectiveEntry);\n              return prospectiveEntry;\n            }\n          }, {\n            key: \"clear\",\n            value: function clear() {\n              this.entries.length = 0;\n            }\n          }, {\n            key: \"optimize\",\n            value: function optimize() {\n              var _this28 = this;\n\n              var keepEntries = [];\n\n              var isEntrySignificant = function isEntrySignificant(entry) {\n                return entry.deltaSize() > SFItemHistory.LargeEntryDeltaThreshold;\n              };\n\n              var processEntry = function processEntry(entry, index, keep) {\n                // Entries may be processed retrospectively, meaning it can be decided to be deleted, then an upcoming processing can change that.\n                if (keep) {\n                  keepEntries.push(entry);\n                } else {\n                  // Remove if in keep\n                  var index = keepEntries.indexOf(entry);\n\n                  if (index !== -1) {\n                    keepEntries.splice(index, 1);\n                  }\n                }\n\n                if (keep && isEntrySignificant(entry) && entry.operationVector() == -1) {\n                  // This is a large negative change. Hang on to the previous entry.\n                  var previousEntry = _this28.entries[index - 1];\n\n                  if (previousEntry) {\n                    keepEntries.push(previousEntry);\n                  }\n                }\n              };\n\n              this.entries.forEach(function (entry, index) {\n                if (index == 0 || index == _this28.entries.length - 1) {\n                  // Keep the first and last\n                  processEntry(entry, index, true);\n                } else {\n                  var significant = isEntrySignificant(entry);\n                  processEntry(entry, index, significant);\n                }\n              });\n              this.entries = this.entries.filter(function (entry, index) {\n                return keepEntries.indexOf(entry) !== -1;\n              });\n            }\n          }]);\n\n          return SFItemHistory;\n        }(); // The amount of characters added or removed that constitute a keepable entry after optimization.\n\n\n        SFItemHistory.LargeEntryDeltaThreshold = 15;\n        ;\n\n        var SFItemHistoryEntry = exports.SFItemHistoryEntry = function () {\n          function SFItemHistoryEntry(item) {\n            _classCallCheck(this, SFItemHistoryEntry); // Whatever values `item` has will be persisted, so be sure that the values are picked beforehand.\n\n\n            this.item = SFItem.deepMerge({}, item); // We'll assume a `text` content value to diff on. If it doesn't exist, no problem.\n\n            this.defaultContentKeyToDiffOn = \"text\"; // Default value\n\n            this.textCharDiffLength = 0;\n\n            if (typeof this.item.updated_at == 'string') {\n              this.item.updated_at = new Date(this.item.updated_at);\n            }\n          }\n\n          _createClass(SFItemHistoryEntry, [{\n            key: \"setPreviousEntry\",\n            value: function setPreviousEntry(previousEntry) {\n              this.hasPreviousEntry = previousEntry != null; // we'll try to compute the delta based on an assumed content property of `text`, if it exists.\n\n              if (this.item.content[this.defaultContentKeyToDiffOn]) {\n                if (previousEntry) {\n                  this.textCharDiffLength = this.item.content[this.defaultContentKeyToDiffOn].length - previousEntry.item.content[this.defaultContentKeyToDiffOn].length;\n                } else {\n                  this.textCharDiffLength = this.item.content[this.defaultContentKeyToDiffOn].length;\n                }\n              }\n            }\n          }, {\n            key: \"operationVector\",\n            value: function operationVector() {\n              // We'll try to use the value of `textCharDiffLength` to help determine this, if it's set\n              if (this.textCharDiffLength != undefined) {\n                if (!this.hasPreviousEntry || this.textCharDiffLength == 0) {\n                  return 0;\n                } else if (this.textCharDiffLength < 0) {\n                  return -1;\n                } else {\n                  return 1;\n                }\n              } // Otherwise use a default value of 1\n\n\n              return 1;\n            }\n          }, {\n            key: \"deltaSize\",\n            value: function deltaSize() {\n              // Up to the subclass to determine how large the delta was, i.e number of characters changed.\n              // But this general class won't be able to determine which property it should diff on, or even its format.\n              // We can return the `textCharDiffLength` if it's set, otherwise, just return 1;\n              if (this.textCharDiffLength != undefined) {\n                return Math.abs(this.textCharDiffLength);\n              } // Otherwise return 1 here to constitute a basic positive delta.\n              // The value returned should always be positive. override `operationVector` to return the direction of the delta.\n\n\n              return 1;\n            }\n          }, {\n            key: \"isSameAsEntry\",\n            value: function isSameAsEntry(entry) {\n              if (!entry) {\n                return false;\n              }\n\n              var lhs = new SFItem(this.item);\n              var rhs = new SFItem(entry.item);\n              return lhs.isItemContentEqualWith(rhs);\n            }\n          }]);\n\n          return SFItemHistoryEntry;\n        }();\n\n        ;\n        /* Abstract class. Instantiate an instance of either SFCryptoJS (uses cryptojs) or SFCryptoWeb (uses web crypto) */\n\n        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;\n\n        var SFAbstractCrypto = exports.SFAbstractCrypto = function () {\n          function SFAbstractCrypto() {\n            _classCallCheck(this, SFAbstractCrypto);\n\n            this.DefaultPBKDF2Length = 768;\n          }\n          /*\n          Our WebCrypto implementation only offers PBKDf2, so any other encryption\n          and key generation functions must use CryptoJS in this abstract implementation.\n          */\n\n\n          _createClass(SFAbstractCrypto, [{\n            key: \"generateUUIDSync\",\n            value: function generateUUIDSync() {\n              var crypto = globalScope.crypto || globalScope.msCrypto;\n\n              if (crypto) {\n                var buf = new Uint32Array(4);\n                crypto.getRandomValues(buf);\n                var idx = -1;\n                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                  idx++;\n                  var r = buf[idx >> 3] >> idx % 8 * 4 & 15;\n                  var v = c == 'x' ? r : r & 0x3 | 0x8;\n                  return v.toString(16);\n                });\n              } else {\n                var d = new Date().getTime();\n\n                if (globalScope.performance && typeof globalScope.performance.now === \"function\") {\n                  d += performance.now(); //use high-precision timer if available\n                }\n\n                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                  var r = (d + Math.random() * 16) % 16 | 0;\n                  d = Math.floor(d / 16);\n                  return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n                });\n                return uuid;\n              }\n            }\n          }, {\n            key: \"generateUUID\",\n            value: function () {\n              var _ref113 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee107() {\n                return regeneratorRuntime.wrap(function _callee107$(_context107) {\n                  while (1) {\n                    switch (_context107.prev = _context107.next) {\n                      case 0:\n                        return _context107.abrupt(\"return\", this.generateUUIDSync());\n\n                      case 1:\n                      case \"end\":\n                        return _context107.stop();\n                    }\n                  }\n                }, _callee107, this);\n              }));\n\n              function generateUUID() {\n                return _ref113.apply(this, arguments);\n              }\n\n              return generateUUID;\n            }()\n          }, {\n            key: \"decryptText\",\n            value: function () {\n              var _ref114 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee108() {\n                var _ref115 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                    ciphertextToAuth = _ref115.ciphertextToAuth,\n                    contentCiphertext = _ref115.contentCiphertext,\n                    encryptionKey = _ref115.encryptionKey,\n                    iv = _ref115.iv,\n                    authHash = _ref115.authHash,\n                    authKey = _ref115.authKey;\n\n                var requiresAuth = arguments[1];\n                var localAuthHash, keyData, ivData, decrypted;\n                return regeneratorRuntime.wrap(function _callee108$(_context108) {\n                  while (1) {\n                    switch (_context108.prev = _context108.next) {\n                      case 0:\n                        if (!(requiresAuth && !authHash)) {\n                          _context108.next = 3;\n                          break;\n                        }\n\n                        console.error(\"Auth hash is required.\");\n                        return _context108.abrupt(\"return\");\n\n                      case 3:\n                        if (!authHash) {\n                          _context108.next = 10;\n                          break;\n                        }\n\n                        _context108.next = 6;\n                        return this.hmac256(ciphertextToAuth, authKey);\n\n                      case 6:\n                        localAuthHash = _context108.sent;\n\n                        if (!(authHash !== localAuthHash)) {\n                          _context108.next = 10;\n                          break;\n                        }\n\n                        console.error(\"Auth hash does not match, returning null.\");\n                        return _context108.abrupt(\"return\", null);\n\n                      case 10:\n                        keyData = CryptoJS.enc.Hex.parse(encryptionKey);\n                        ivData = CryptoJS.enc.Hex.parse(iv || \"\");\n                        decrypted = CryptoJS.AES.decrypt(contentCiphertext, keyData, {\n                          iv: ivData,\n                          mode: CryptoJS.mode.CBC,\n                          padding: CryptoJS.pad.Pkcs7\n                        });\n                        return _context108.abrupt(\"return\", decrypted.toString(CryptoJS.enc.Utf8));\n\n                      case 14:\n                      case \"end\":\n                        return _context108.stop();\n                    }\n                  }\n                }, _callee108, this);\n              }));\n\n              function decryptText() {\n                return _ref114.apply(this, arguments);\n              }\n\n              return decryptText;\n            }()\n          }, {\n            key: \"encryptText\",\n            value: function () {\n              var _ref116 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee109(text, key, iv) {\n                var keyData, ivData, encrypted;\n                return regeneratorRuntime.wrap(function _callee109$(_context109) {\n                  while (1) {\n                    switch (_context109.prev = _context109.next) {\n                      case 0:\n                        keyData = CryptoJS.enc.Hex.parse(key);\n                        ivData = CryptoJS.enc.Hex.parse(iv || \"\");\n                        encrypted = CryptoJS.AES.encrypt(text, keyData, {\n                          iv: ivData,\n                          mode: CryptoJS.mode.CBC,\n                          padding: CryptoJS.pad.Pkcs7\n                        });\n                        return _context109.abrupt(\"return\", encrypted.toString());\n\n                      case 4:\n                      case \"end\":\n                        return _context109.stop();\n                    }\n                  }\n                }, _callee109, this);\n              }));\n\n              function encryptText(_x131, _x132, _x133) {\n                return _ref116.apply(this, arguments);\n              }\n\n              return encryptText;\n            }()\n          }, {\n            key: \"generateRandomKey\",\n            value: function () {\n              var _ref117 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee110(bits) {\n                return regeneratorRuntime.wrap(function _callee110$(_context110) {\n                  while (1) {\n                    switch (_context110.prev = _context110.next) {\n                      case 0:\n                        return _context110.abrupt(\"return\", CryptoJS.lib.WordArray.random(bits / 8).toString());\n\n                      case 1:\n                      case \"end\":\n                        return _context110.stop();\n                    }\n                  }\n                }, _callee110, this);\n              }));\n\n              function generateRandomKey(_x134) {\n                return _ref117.apply(this, arguments);\n              }\n\n              return generateRandomKey;\n            }()\n          }, {\n            key: \"generateItemEncryptionKey\",\n            value: function () {\n              var _ref118 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee111() {\n                var length, cost, salt, passphrase;\n                return regeneratorRuntime.wrap(function _callee111$(_context111) {\n                  while (1) {\n                    switch (_context111.prev = _context111.next) {\n                      case 0:\n                        // Generates a key that will be split in half, each being 256 bits. So total length will need to be 512.\n                        length = 512;\n                        cost = 1;\n                        _context111.next = 4;\n                        return this.generateRandomKey(length);\n\n                      case 4:\n                        salt = _context111.sent;\n                        _context111.next = 7;\n                        return this.generateRandomKey(length);\n\n                      case 7:\n                        passphrase = _context111.sent;\n                        return _context111.abrupt(\"return\", this.pbkdf2(passphrase, salt, cost, length));\n\n                      case 9:\n                      case \"end\":\n                        return _context111.stop();\n                    }\n                  }\n                }, _callee111, this);\n              }));\n\n              function generateItemEncryptionKey() {\n                return _ref118.apply(this, arguments);\n              }\n\n              return generateItemEncryptionKey;\n            }()\n          }, {\n            key: \"firstHalfOfKey\",\n            value: function () {\n              var _ref119 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee112(key) {\n                return regeneratorRuntime.wrap(function _callee112$(_context112) {\n                  while (1) {\n                    switch (_context112.prev = _context112.next) {\n                      case 0:\n                        return _context112.abrupt(\"return\", key.substring(0, key.length / 2));\n\n                      case 1:\n                      case \"end\":\n                        return _context112.stop();\n                    }\n                  }\n                }, _callee112, this);\n              }));\n\n              function firstHalfOfKey(_x135) {\n                return _ref119.apply(this, arguments);\n              }\n\n              return firstHalfOfKey;\n            }()\n          }, {\n            key: \"secondHalfOfKey\",\n            value: function () {\n              var _ref120 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee113(key) {\n                return regeneratorRuntime.wrap(function _callee113$(_context113) {\n                  while (1) {\n                    switch (_context113.prev = _context113.next) {\n                      case 0:\n                        return _context113.abrupt(\"return\", key.substring(key.length / 2, key.length));\n\n                      case 1:\n                      case \"end\":\n                        return _context113.stop();\n                    }\n                  }\n                }, _callee113, this);\n              }));\n\n              function secondHalfOfKey(_x136) {\n                return _ref120.apply(this, arguments);\n              }\n\n              return secondHalfOfKey;\n            }()\n          }, {\n            key: \"base64\",\n            value: function () {\n              var _ref121 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee114(text) {\n                return regeneratorRuntime.wrap(function _callee114$(_context114) {\n                  while (1) {\n                    switch (_context114.prev = _context114.next) {\n                      case 0:\n                        return _context114.abrupt(\"return\", globalScope.btoa(encodeURIComponent(text).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {\n                          return String.fromCharCode('0x' + p1);\n                        })));\n\n                      case 1:\n                      case \"end\":\n                        return _context114.stop();\n                    }\n                  }\n                }, _callee114, this);\n              }));\n\n              function base64(_x137) {\n                return _ref121.apply(this, arguments);\n              }\n\n              return base64;\n            }()\n          }, {\n            key: \"base64Decode\",\n            value: function () {\n              var _ref122 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee115(base64String) {\n                return regeneratorRuntime.wrap(function _callee115$(_context115) {\n                  while (1) {\n                    switch (_context115.prev = _context115.next) {\n                      case 0:\n                        return _context115.abrupt(\"return\", globalScope.atob(base64String));\n\n                      case 1:\n                      case \"end\":\n                        return _context115.stop();\n                    }\n                  }\n                }, _callee115, this);\n              }));\n\n              function base64Decode(_x138) {\n                return _ref122.apply(this, arguments);\n              }\n\n              return base64Decode;\n            }()\n          }, {\n            key: \"sha256\",\n            value: function () {\n              var _ref123 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee116(text) {\n                return regeneratorRuntime.wrap(function _callee116$(_context116) {\n                  while (1) {\n                    switch (_context116.prev = _context116.next) {\n                      case 0:\n                        return _context116.abrupt(\"return\", CryptoJS.SHA256(text).toString());\n\n                      case 1:\n                      case \"end\":\n                        return _context116.stop();\n                    }\n                  }\n                }, _callee116, this);\n              }));\n\n              function sha256(_x139) {\n                return _ref123.apply(this, arguments);\n              }\n\n              return sha256;\n            }()\n          }, {\n            key: \"hmac256\",\n            value: function () {\n              var _ref124 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee117(message, key) {\n                var keyData, messageData, result;\n                return regeneratorRuntime.wrap(function _callee117$(_context117) {\n                  while (1) {\n                    switch (_context117.prev = _context117.next) {\n                      case 0:\n                        keyData = CryptoJS.enc.Hex.parse(key);\n                        messageData = CryptoJS.enc.Utf8.parse(message);\n                        result = CryptoJS.HmacSHA256(messageData, keyData).toString();\n                        return _context117.abrupt(\"return\", result);\n\n                      case 4:\n                      case \"end\":\n                        return _context117.stop();\n                    }\n                  }\n                }, _callee117, this);\n              }));\n\n              function hmac256(_x140, _x141) {\n                return _ref124.apply(this, arguments);\n              }\n\n              return hmac256;\n            }()\n          }, {\n            key: \"generateSalt\",\n            value: function () {\n              var _ref125 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee118(identifier, version, cost, nonce) {\n                var result;\n                return regeneratorRuntime.wrap(function _callee118$(_context118) {\n                  while (1) {\n                    switch (_context118.prev = _context118.next) {\n                      case 0:\n                        _context118.next = 2;\n                        return this.sha256([identifier, \"SF\", version, cost, nonce].join(\":\"));\n\n                      case 2:\n                        result = _context118.sent;\n                        return _context118.abrupt(\"return\", result);\n\n                      case 4:\n                      case \"end\":\n                        return _context118.stop();\n                    }\n                  }\n                }, _callee118, this);\n              }));\n\n              function generateSalt(_x142, _x143, _x144, _x145) {\n                return _ref125.apply(this, arguments);\n              }\n\n              return generateSalt;\n            }()\n            /** Generates two deterministic keys based on one input */\n\n          }, {\n            key: \"generateSymmetricKeyPair\",\n            value: function () {\n              var _ref126 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee119() {\n                var _ref127 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                    password = _ref127.password,\n                    pw_salt = _ref127.pw_salt,\n                    pw_cost = _ref127.pw_cost;\n\n                var output, outputLength, splitLength, firstThird, secondThird, thirdThird;\n                return regeneratorRuntime.wrap(function _callee119$(_context119) {\n                  while (1) {\n                    switch (_context119.prev = _context119.next) {\n                      case 0:\n                        _context119.next = 2;\n                        return this.pbkdf2(password, pw_salt, pw_cost, this.DefaultPBKDF2Length);\n\n                      case 2:\n                        output = _context119.sent;\n                        outputLength = output.length;\n                        splitLength = outputLength / 3;\n                        firstThird = output.slice(0, splitLength);\n                        secondThird = output.slice(splitLength, splitLength * 2);\n                        thirdThird = output.slice(splitLength * 2, splitLength * 3);\n                        return _context119.abrupt(\"return\", [firstThird, secondThird, thirdThird]);\n\n                      case 9:\n                      case \"end\":\n                        return _context119.stop();\n                    }\n                  }\n                }, _callee119, this);\n              }));\n\n              function generateSymmetricKeyPair() {\n                return _ref126.apply(this, arguments);\n              }\n\n              return generateSymmetricKeyPair;\n            }()\n          }, {\n            key: \"computeEncryptionKeysForUser\",\n            value: function () {\n              var _ref128 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee120(password, authParams) {\n                var pw_salt;\n                return regeneratorRuntime.wrap(function _callee120$(_context120) {\n                  while (1) {\n                    switch (_context120.prev = _context120.next) {\n                      case 0:\n                        if (!(authParams.version == \"003\")) {\n                          _context120.next = 9;\n                          break;\n                        }\n\n                        if (authParams.identifier) {\n                          _context120.next = 4;\n                          break;\n                        }\n\n                        console.error(\"authParams is missing identifier.\");\n                        return _context120.abrupt(\"return\");\n\n                      case 4:\n                        _context120.next = 6;\n                        return this.generateSalt(authParams.identifier, authParams.version, authParams.pw_cost, authParams.pw_nonce);\n\n                      case 6:\n                        pw_salt = _context120.sent;\n                        _context120.next = 10;\n                        break;\n\n                      case 9:\n                        // Salt is returned from server\n                        pw_salt = authParams.pw_salt;\n\n                      case 10:\n                        return _context120.abrupt(\"return\", this.generateSymmetricKeyPair({\n                          password: password,\n                          pw_salt: pw_salt,\n                          pw_cost: authParams.pw_cost\n                        }).then(function (keys) {\n                          var userKeys = {\n                            pw: keys[0],\n                            mk: keys[1],\n                            ak: keys[2]\n                          };\n                          return userKeys;\n                        }));\n\n                      case 11:\n                      case \"end\":\n                        return _context120.stop();\n                    }\n                  }\n                }, _callee120, this);\n              }));\n\n              function computeEncryptionKeysForUser(_x147, _x148) {\n                return _ref128.apply(this, arguments);\n              }\n\n              return computeEncryptionKeysForUser;\n            }() // Unlike computeEncryptionKeysForUser, this method always uses the latest SF Version\n\n          }, {\n            key: \"generateInitialKeysAndAuthParamsForUser\",\n            value: function () {\n              var _ref129 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee121(identifier, password) {\n                var version, pw_cost, pw_nonce, pw_salt;\n                return regeneratorRuntime.wrap(function _callee121$(_context121) {\n                  while (1) {\n                    switch (_context121.prev = _context121.next) {\n                      case 0:\n                        version = this.SFJS.version;\n                        pw_cost = this.SFJS.defaultPasswordGenerationCost;\n                        _context121.next = 4;\n                        return this.generateRandomKey(256);\n\n                      case 4:\n                        pw_nonce = _context121.sent;\n                        _context121.next = 7;\n                        return this.generateSalt(identifier, version, pw_cost, pw_nonce);\n\n                      case 7:\n                        pw_salt = _context121.sent;\n                        return _context121.abrupt(\"return\", this.generateSymmetricKeyPair({\n                          password: password,\n                          pw_salt: pw_salt,\n                          pw_cost: pw_cost\n                        }).then(function (keys) {\n                          var authParams = {\n                            pw_nonce: pw_nonce,\n                            pw_cost: pw_cost,\n                            identifier: identifier,\n                            version: version\n                          };\n                          var userKeys = {\n                            pw: keys[0],\n                            mk: keys[1],\n                            ak: keys[2]\n                          };\n                          return {\n                            keys: userKeys,\n                            authParams: authParams\n                          };\n                        }));\n\n                      case 9:\n                      case \"end\":\n                        return _context121.stop();\n                    }\n                  }\n                }, _callee121, this);\n              }));\n\n              function generateInitialKeysAndAuthParamsForUser(_x149, _x150) {\n                return _ref129.apply(this, arguments);\n              }\n\n              return generateInitialKeysAndAuthParamsForUser;\n            }()\n          }]);\n\n          return SFAbstractCrypto;\n        }();\n\n        ;\n\n        var SFCryptoJS = exports.SFCryptoJS = function (_SFAbstractCrypto) {\n          _inherits(SFCryptoJS, _SFAbstractCrypto);\n\n          function SFCryptoJS() {\n            _classCallCheck(this, SFCryptoJS);\n\n            return _possibleConstructorReturn(this, (SFCryptoJS.__proto__ || Object.getPrototypeOf(SFCryptoJS)).apply(this, arguments));\n          }\n\n          _createClass(SFCryptoJS, [{\n            key: \"pbkdf2\",\n            value: function () {\n              var _ref130 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee122(password, pw_salt, pw_cost, length) {\n                var params;\n                return regeneratorRuntime.wrap(function _callee122$(_context122) {\n                  while (1) {\n                    switch (_context122.prev = _context122.next) {\n                      case 0:\n                        params = {\n                          keySize: length / 32,\n                          hasher: CryptoJS.algo.SHA512,\n                          iterations: pw_cost\n                        };\n                        return _context122.abrupt(\"return\", CryptoJS.PBKDF2(password, pw_salt, params).toString());\n\n                      case 2:\n                      case \"end\":\n                        return _context122.stop();\n                    }\n                  }\n                }, _callee122, this);\n              }));\n\n              function pbkdf2(_x151, _x152, _x153, _x154) {\n                return _ref130.apply(this, arguments);\n              }\n\n              return pbkdf2;\n            }()\n          }]);\n\n          return SFCryptoJS;\n        }(SFAbstractCrypto);\n\n        ;\n        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;\n        var subtleCrypto = globalScope.crypto ? globalScope.crypto.subtle : null;\n\n        var SFCryptoWeb = exports.SFCryptoWeb = function (_SFAbstractCrypto2) {\n          _inherits(SFCryptoWeb, _SFAbstractCrypto2);\n\n          function SFCryptoWeb() {\n            _classCallCheck(this, SFCryptoWeb);\n\n            return _possibleConstructorReturn(this, (SFCryptoWeb.__proto__ || Object.getPrototypeOf(SFCryptoWeb)).apply(this, arguments));\n          }\n\n          _createClass(SFCryptoWeb, [{\n            key: \"pbkdf2\",\n\n            /**\n            Public\n            */\n            value: function () {\n              var _ref131 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee123(password, pw_salt, pw_cost, length) {\n                var key;\n                return regeneratorRuntime.wrap(function _callee123$(_context123) {\n                  while (1) {\n                    switch (_context123.prev = _context123.next) {\n                      case 0:\n                        _context123.next = 2;\n                        return this.webCryptoImportKey(password, \"PBKDF2\", [\"deriveBits\"]);\n\n                      case 2:\n                        key = _context123.sent;\n\n                        if (key) {\n                          _context123.next = 6;\n                          break;\n                        }\n\n                        console.log(\"Key is null, unable to continue\");\n                        return _context123.abrupt(\"return\", null);\n\n                      case 6:\n                        return _context123.abrupt(\"return\", this.webCryptoDeriveBits(key, pw_salt, pw_cost, length));\n\n                      case 7:\n                      case \"end\":\n                        return _context123.stop();\n                    }\n                  }\n                }, _callee123, this);\n              }));\n\n              function pbkdf2(_x155, _x156, _x157, _x158) {\n                return _ref131.apply(this, arguments);\n              }\n\n              return pbkdf2;\n            }()\n          }, {\n            key: \"generateRandomKey\",\n            value: function () {\n              var _ref132 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee125(bits) {\n                var _this31 = this;\n\n                var extractable;\n                return regeneratorRuntime.wrap(function _callee125$(_context125) {\n                  while (1) {\n                    switch (_context125.prev = _context125.next) {\n                      case 0:\n                        extractable = true;\n                        return _context125.abrupt(\"return\", subtleCrypto.generateKey({\n                          name: \"AES-CBC\",\n                          length: bits\n                        }, extractable, [\"encrypt\", \"decrypt\"]).then(function (keyObject) {\n                          return subtleCrypto.exportKey(\"raw\", keyObject).then(function () {\n                            var _ref133 = _asyncToGenerator(\n                            /*#__PURE__*/\n                            regeneratorRuntime.mark(function _callee124(keyData) {\n                              var key;\n                              return regeneratorRuntime.wrap(function _callee124$(_context124) {\n                                while (1) {\n                                  switch (_context124.prev = _context124.next) {\n                                    case 0:\n                                      _context124.next = 2;\n                                      return _this31.arrayBufferToHexString(new Uint8Array(keyData));\n\n                                    case 2:\n                                      key = _context124.sent;\n                                      return _context124.abrupt(\"return\", key);\n\n                                    case 4:\n                                    case \"end\":\n                                      return _context124.stop();\n                                  }\n                                }\n                              }, _callee124, _this31);\n                            }));\n\n                            return function (_x160) {\n                              return _ref133.apply(this, arguments);\n                            };\n                          }()).catch(function (err) {\n                            console.error(\"Error exporting key\", err);\n                          });\n                        }).catch(function (err) {\n                          console.error(\"Error generating key\", err);\n                        }));\n\n                      case 2:\n                      case \"end\":\n                        return _context125.stop();\n                    }\n                  }\n                }, _callee125, this);\n              }));\n\n              function generateRandomKey(_x159) {\n                return _ref132.apply(this, arguments);\n              }\n\n              return generateRandomKey;\n            }()\n          }, {\n            key: \"generateItemEncryptionKey\",\n            value: function () {\n              var _ref134 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee126() {\n                var length;\n                return regeneratorRuntime.wrap(function _callee126$(_context126) {\n                  while (1) {\n                    switch (_context126.prev = _context126.next) {\n                      case 0:\n                        // Generates a key that will be split in half, each being 256 bits. So total length will need to be 512.\n                        length = 256;\n                        return _context126.abrupt(\"return\", Promise.all([this.generateRandomKey(length), this.generateRandomKey(length)]).then(function (values) {\n                          return values.join(\"\");\n                        }));\n\n                      case 2:\n                      case \"end\":\n                        return _context126.stop();\n                    }\n                  }\n                }, _callee126, this);\n              }));\n\n              function generateItemEncryptionKey() {\n                return _ref134.apply(this, arguments);\n              }\n\n              return generateItemEncryptionKey;\n            }()\n            /* This is a functioning implementation of WebCrypto's encrypt, however, in basic testing, CrpytoJS performs about 30-40% faster, surprisingly. */\n\n          }, {\n            key: \"encryptText\",\n            value: function () {\n              var _ref135 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee128(text, key, iv) {\n                var _this32 = this;\n\n                var ivData, alg, keyBuffer, keyData, textData;\n                return regeneratorRuntime.wrap(function _callee128$(_context128) {\n                  while (1) {\n                    switch (_context128.prev = _context128.next) {\n                      case 0:\n                        if (!iv) {\n                          _context128.next = 6;\n                          break;\n                        }\n\n                        _context128.next = 3;\n                        return this.hexStringToArrayBuffer(iv);\n\n                      case 3:\n                        _context128.t0 = _context128.sent;\n                        _context128.next = 7;\n                        break;\n\n                      case 6:\n                        _context128.t0 = new ArrayBuffer(16);\n\n                      case 7:\n                        ivData = _context128.t0;\n                        alg = {\n                          name: 'AES-CBC',\n                          iv: ivData\n                        };\n                        _context128.next = 11;\n                        return this.hexStringToArrayBuffer(key);\n\n                      case 11:\n                        keyBuffer = _context128.sent;\n                        _context128.next = 14;\n                        return this.webCryptoImportKey(keyBuffer, alg.name, [\"encrypt\"]);\n\n                      case 14:\n                        keyData = _context128.sent;\n                        _context128.next = 17;\n                        return this.stringToArrayBuffer(text);\n\n                      case 17:\n                        textData = _context128.sent;\n                        return _context128.abrupt(\"return\", crypto.subtle.encrypt(alg, keyData, textData).then(function () {\n                          var _ref136 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee127(result) {\n                            var cipher;\n                            return regeneratorRuntime.wrap(function _callee127$(_context127) {\n                              while (1) {\n                                switch (_context127.prev = _context127.next) {\n                                  case 0:\n                                    _context127.next = 2;\n                                    return _this32.arrayBufferToBase64(result);\n\n                                  case 2:\n                                    cipher = _context127.sent;\n                                    return _context127.abrupt(\"return\", cipher);\n\n                                  case 4:\n                                  case \"end\":\n                                    return _context127.stop();\n                                }\n                              }\n                            }, _callee127, _this32);\n                          }));\n\n                          return function (_x164) {\n                            return _ref136.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 19:\n                      case \"end\":\n                        return _context128.stop();\n                    }\n                  }\n                }, _callee128, this);\n              }));\n\n              function encryptText(_x161, _x162, _x163) {\n                return _ref135.apply(this, arguments);\n              }\n\n              return encryptText;\n            }()\n          }, {\n            key: \"decryptText\",\n            value: function () {\n              var _ref137 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee130() {\n                var _this33 = this;\n\n                var _ref138 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                    ciphertextToAuth = _ref138.ciphertextToAuth,\n                    contentCiphertext = _ref138.contentCiphertext,\n                    encryptionKey = _ref138.encryptionKey,\n                    iv = _ref138.iv,\n                    authHash = _ref138.authHash,\n                    authKey = _ref138.authKey;\n\n                var requiresAuth = arguments[1];\n                var localAuthHash, ivData, alg, keyBuffer, keyData, textData;\n                return regeneratorRuntime.wrap(function _callee130$(_context130) {\n                  while (1) {\n                    switch (_context130.prev = _context130.next) {\n                      case 0:\n                        if (!(requiresAuth && !authHash)) {\n                          _context130.next = 3;\n                          break;\n                        }\n\n                        console.error(\"Auth hash is required.\");\n                        return _context130.abrupt(\"return\");\n\n                      case 3:\n                        if (!authHash) {\n                          _context130.next = 10;\n                          break;\n                        }\n\n                        _context130.next = 6;\n                        return this.hmac256(ciphertextToAuth, authKey);\n\n                      case 6:\n                        localAuthHash = _context130.sent;\n\n                        if (!(authHash !== localAuthHash)) {\n                          _context130.next = 10;\n                          break;\n                        }\n\n                        console.error(\"Auth hash does not match, returning null. \" + authHash + \" != \" + localAuthHash);\n                        return _context130.abrupt(\"return\", null);\n\n                      case 10:\n                        if (!iv) {\n                          _context130.next = 16;\n                          break;\n                        }\n\n                        _context130.next = 13;\n                        return this.hexStringToArrayBuffer(iv);\n\n                      case 13:\n                        _context130.t0 = _context130.sent;\n                        _context130.next = 17;\n                        break;\n\n                      case 16:\n                        _context130.t0 = new ArrayBuffer(16);\n\n                      case 17:\n                        ivData = _context130.t0;\n                        alg = {\n                          name: 'AES-CBC',\n                          iv: ivData\n                        };\n                        _context130.next = 21;\n                        return this.hexStringToArrayBuffer(encryptionKey);\n\n                      case 21:\n                        keyBuffer = _context130.sent;\n                        _context130.next = 24;\n                        return this.webCryptoImportKey(keyBuffer, alg.name, [\"decrypt\"]);\n\n                      case 24:\n                        keyData = _context130.sent;\n                        _context130.next = 27;\n                        return this.base64ToArrayBuffer(contentCiphertext);\n\n                      case 27:\n                        textData = _context130.sent;\n                        return _context130.abrupt(\"return\", crypto.subtle.decrypt(alg, keyData, textData).then(function () {\n                          var _ref139 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee129(result) {\n                            var decoded;\n                            return regeneratorRuntime.wrap(function _callee129$(_context129) {\n                              while (1) {\n                                switch (_context129.prev = _context129.next) {\n                                  case 0:\n                                    _context129.next = 2;\n                                    return _this33.arrayBufferToString(result);\n\n                                  case 2:\n                                    decoded = _context129.sent;\n                                    return _context129.abrupt(\"return\", decoded);\n\n                                  case 4:\n                                  case \"end\":\n                                    return _context129.stop();\n                                }\n                              }\n                            }, _callee129, _this33);\n                          }));\n\n                          return function (_x166) {\n                            return _ref139.apply(this, arguments);\n                          };\n                        }()).catch(function (error) {\n                          console.error(\"Error decrypting:\", error);\n                        }));\n\n                      case 29:\n                      case \"end\":\n                        return _context130.stop();\n                    }\n                  }\n                }, _callee130, this);\n              }));\n\n              function decryptText() {\n                return _ref137.apply(this, arguments);\n              }\n\n              return decryptText;\n            }()\n            /**\n            Internal\n            */\n\n          }, {\n            key: \"webCryptoImportKey\",\n            value: function () {\n              var _ref140 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee131(input, alg, actions, hash) {\n                var text;\n                return regeneratorRuntime.wrap(function _callee131$(_context131) {\n                  while (1) {\n                    switch (_context131.prev = _context131.next) {\n                      case 0:\n                        if (!(typeof input === \"string\")) {\n                          _context131.next = 6;\n                          break;\n                        }\n\n                        _context131.next = 3;\n                        return this.stringToArrayBuffer(input);\n\n                      case 3:\n                        _context131.t0 = _context131.sent;\n                        _context131.next = 7;\n                        break;\n\n                      case 6:\n                        _context131.t0 = input;\n\n                      case 7:\n                        text = _context131.t0;\n                        return _context131.abrupt(\"return\", subtleCrypto.importKey(\"raw\", text, {\n                          name: alg,\n                          hash: hash\n                        }, false, actions).then(function (key) {\n                          return key;\n                        }).catch(function (err) {\n                          console.error(err);\n                          return null;\n                        }));\n\n                      case 9:\n                      case \"end\":\n                        return _context131.stop();\n                    }\n                  }\n                }, _callee131, this);\n              }));\n\n              function webCryptoImportKey(_x167, _x168, _x169, _x170) {\n                return _ref140.apply(this, arguments);\n              }\n\n              return webCryptoImportKey;\n            }() //\n\n          }, {\n            key: \"webCryptoDeriveBits\",\n            value: function () {\n              var _ref141 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee133(key, pw_salt, pw_cost, length) {\n                var _this34 = this;\n\n                var params;\n                return regeneratorRuntime.wrap(function _callee133$(_context133) {\n                  while (1) {\n                    switch (_context133.prev = _context133.next) {\n                      case 0:\n                        _context133.next = 2;\n                        return this.stringToArrayBuffer(pw_salt);\n\n                      case 2:\n                        _context133.t0 = _context133.sent;\n                        _context133.t1 = pw_cost;\n                        _context133.t2 = {\n                          name: \"SHA-512\"\n                        };\n                        params = {\n                          \"name\": \"PBKDF2\",\n                          salt: _context133.t0,\n                          iterations: _context133.t1,\n                          hash: _context133.t2\n                        };\n                        return _context133.abrupt(\"return\", subtleCrypto.deriveBits(params, key, length).then(function () {\n                          var _ref142 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee132(bits) {\n                            var key;\n                            return regeneratorRuntime.wrap(function _callee132$(_context132) {\n                              while (1) {\n                                switch (_context132.prev = _context132.next) {\n                                  case 0:\n                                    _context132.next = 2;\n                                    return _this34.arrayBufferToHexString(new Uint8Array(bits));\n\n                                  case 2:\n                                    key = _context132.sent;\n                                    return _context132.abrupt(\"return\", key);\n\n                                  case 4:\n                                  case \"end\":\n                                    return _context132.stop();\n                                }\n                              }\n                            }, _callee132, _this34);\n                          }));\n\n                          return function (_x175) {\n                            return _ref142.apply(this, arguments);\n                          };\n                        }()).catch(function (err) {\n                          console.error(err);\n                          return null;\n                        }));\n\n                      case 7:\n                      case \"end\":\n                        return _context133.stop();\n                    }\n                  }\n                }, _callee133, this);\n              }));\n\n              function webCryptoDeriveBits(_x171, _x172, _x173, _x174) {\n                return _ref141.apply(this, arguments);\n              }\n\n              return webCryptoDeriveBits;\n            }()\n          }, {\n            key: \"stringToArrayBuffer\",\n            value: function () {\n              var _ref143 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee134(string) {\n                return regeneratorRuntime.wrap(function _callee134$(_context134) {\n                  while (1) {\n                    switch (_context134.prev = _context134.next) {\n                      case 0:\n                        return _context134.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          var blob = new Blob([string]);\n                          var f = new FileReader();\n\n                          f.onload = function (e) {\n                            resolve(e.target.result);\n                          };\n\n                          f.readAsArrayBuffer(blob);\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context134.stop();\n                    }\n                  }\n                }, _callee134, this);\n              }));\n\n              function stringToArrayBuffer(_x176) {\n                return _ref143.apply(this, arguments);\n              }\n\n              return stringToArrayBuffer;\n            }()\n          }, {\n            key: \"arrayBufferToString\",\n            value: function () {\n              var _ref144 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee135(arrayBuffer) {\n                return regeneratorRuntime.wrap(function _callee135$(_context135) {\n                  while (1) {\n                    switch (_context135.prev = _context135.next) {\n                      case 0:\n                        return _context135.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          var blob = new Blob([arrayBuffer]);\n                          var f = new FileReader();\n\n                          f.onload = function (e) {\n                            resolve(e.target.result);\n                          };\n\n                          f.readAsText(blob);\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context135.stop();\n                    }\n                  }\n                }, _callee135, this);\n              }));\n\n              function arrayBufferToString(_x177) {\n                return _ref144.apply(this, arguments);\n              }\n\n              return arrayBufferToString;\n            }()\n          }, {\n            key: \"arrayBufferToHexString\",\n            value: function () {\n              var _ref145 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee136(arrayBuffer) {\n                var byteArray, hexString, nextHexByte, i;\n                return regeneratorRuntime.wrap(function _callee136$(_context136) {\n                  while (1) {\n                    switch (_context136.prev = _context136.next) {\n                      case 0:\n                        byteArray = new Uint8Array(arrayBuffer);\n                        hexString = \"\";\n\n                        for (i = 0; i < byteArray.byteLength; i++) {\n                          nextHexByte = byteArray[i].toString(16);\n\n                          if (nextHexByte.length < 2) {\n                            nextHexByte = \"0\" + nextHexByte;\n                          }\n\n                          hexString += nextHexByte;\n                        }\n\n                        return _context136.abrupt(\"return\", hexString);\n\n                      case 4:\n                      case \"end\":\n                        return _context136.stop();\n                    }\n                  }\n                }, _callee136, this);\n              }));\n\n              function arrayBufferToHexString(_x178) {\n                return _ref145.apply(this, arguments);\n              }\n\n              return arrayBufferToHexString;\n            }()\n          }, {\n            key: \"hexStringToArrayBuffer\",\n            value: function () {\n              var _ref146 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee137(hex) {\n                var bytes, c;\n                return regeneratorRuntime.wrap(function _callee137$(_context137) {\n                  while (1) {\n                    switch (_context137.prev = _context137.next) {\n                      case 0:\n                        for (bytes = [], c = 0; c < hex.length; c += 2) {\n                          bytes.push(parseInt(hex.substr(c, 2), 16));\n                        }\n\n                        return _context137.abrupt(\"return\", new Uint8Array(bytes));\n\n                      case 2:\n                      case \"end\":\n                        return _context137.stop();\n                    }\n                  }\n                }, _callee137, this);\n              }));\n\n              function hexStringToArrayBuffer(_x179) {\n                return _ref146.apply(this, arguments);\n              }\n\n              return hexStringToArrayBuffer;\n            }()\n          }, {\n            key: \"base64ToArrayBuffer\",\n            value: function () {\n              var _ref147 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee138(base64) {\n                var binary_string, len, bytes, i;\n                return regeneratorRuntime.wrap(function _callee138$(_context138) {\n                  while (1) {\n                    switch (_context138.prev = _context138.next) {\n                      case 0:\n                        _context138.next = 2;\n                        return this.base64Decode(base64);\n\n                      case 2:\n                        binary_string = _context138.sent;\n                        len = binary_string.length;\n                        bytes = new Uint8Array(len);\n\n                        for (i = 0; i < len; i++) {\n                          bytes[i] = binary_string.charCodeAt(i);\n                        }\n\n                        return _context138.abrupt(\"return\", bytes.buffer);\n\n                      case 7:\n                      case \"end\":\n                        return _context138.stop();\n                    }\n                  }\n                }, _callee138, this);\n              }));\n\n              function base64ToArrayBuffer(_x180) {\n                return _ref147.apply(this, arguments);\n              }\n\n              return base64ToArrayBuffer;\n            }()\n          }, {\n            key: \"arrayBufferToBase64\",\n            value: function () {\n              var _ref148 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee139(buffer) {\n                return regeneratorRuntime.wrap(function _callee139$(_context139) {\n                  while (1) {\n                    switch (_context139.prev = _context139.next) {\n                      case 0:\n                        return _context139.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          var blob = new Blob([buffer], {\n                            type: 'application/octet-binary'\n                          });\n                          var reader = new FileReader();\n\n                          reader.onload = function (evt) {\n                            var dataurl = evt.target.result;\n                            resolve(dataurl.substr(dataurl.indexOf(',') + 1));\n                          };\n\n                          reader.readAsDataURL(blob);\n                        }));\n\n                      case 1:\n                      case \"end\":\n                        return _context139.stop();\n                    }\n                  }\n                }, _callee139, this);\n              }));\n\n              function arrayBufferToBase64(_x181) {\n                return _ref148.apply(this, arguments);\n              }\n\n              return arrayBufferToBase64;\n            }()\n          }, {\n            key: \"hmac256\",\n            value: function () {\n              var _ref149 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee141(message, key) {\n                var _this35 = this;\n\n                var keyHexData, keyData, messageData;\n                return regeneratorRuntime.wrap(function _callee141$(_context141) {\n                  while (1) {\n                    switch (_context141.prev = _context141.next) {\n                      case 0:\n                        _context141.next = 2;\n                        return this.hexStringToArrayBuffer(key);\n\n                      case 2:\n                        keyHexData = _context141.sent;\n                        _context141.next = 5;\n                        return this.webCryptoImportKey(keyHexData, \"HMAC\", [\"sign\"], {\n                          name: \"SHA-256\"\n                        });\n\n                      case 5:\n                        keyData = _context141.sent;\n                        _context141.next = 8;\n                        return this.stringToArrayBuffer(message);\n\n                      case 8:\n                        messageData = _context141.sent;\n                        return _context141.abrupt(\"return\", crypto.subtle.sign({\n                          name: \"HMAC\"\n                        }, keyData, messageData).then(function () {\n                          var _ref150 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee140(signature) {\n                            var hash;\n                            return regeneratorRuntime.wrap(function _callee140$(_context140) {\n                              while (1) {\n                                switch (_context140.prev = _context140.next) {\n                                  case 0:\n                                    _context140.next = 2;\n                                    return _this35.arrayBufferToHexString(signature);\n\n                                  case 2:\n                                    hash = _context140.sent;\n                                    return _context140.abrupt(\"return\", hash);\n\n                                  case 4:\n                                  case \"end\":\n                                    return _context140.stop();\n                                }\n                              }\n                            }, _callee140, _this35);\n                          }));\n\n                          return function (_x184) {\n                            return _ref150.apply(this, arguments);\n                          };\n                        }()).catch(function (err) {\n                          console.error(\"Error computing hmac\");\n                        }));\n\n                      case 10:\n                      case \"end\":\n                        return _context141.stop();\n                    }\n                  }\n                }, _callee141, this);\n              }));\n\n              function hmac256(_x182, _x183) {\n                return _ref149.apply(this, arguments);\n              }\n\n              return hmac256;\n            }()\n          }]);\n\n          return SFCryptoWeb;\n        }(SFAbstractCrypto);\n\n        ;\n\n        var SFItemTransformer = exports.SFItemTransformer = function () {\n          function SFItemTransformer(crypto) {\n            _classCallCheck(this, SFItemTransformer);\n\n            this.crypto = crypto;\n          }\n\n          _createClass(SFItemTransformer, [{\n            key: \"_private_encryptString\",\n            value: function () {\n              var _ref151 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee142(string, encryptionKey, authKey, uuid, auth_params) {\n                var fullCiphertext, contentCiphertext, iv, ciphertextToAuth, authHash, authParamsString;\n                return regeneratorRuntime.wrap(function _callee142$(_context142) {\n                  while (1) {\n                    switch (_context142.prev = _context142.next) {\n                      case 0:\n                        if (!(auth_params.version === \"001\")) {\n                          _context142.next = 7;\n                          break;\n                        }\n\n                        _context142.next = 3;\n                        return this.crypto.encryptText(string, encryptionKey, null);\n\n                      case 3:\n                        contentCiphertext = _context142.sent;\n                        fullCiphertext = auth_params.version + contentCiphertext;\n                        _context142.next = 21;\n                        break;\n\n                      case 7:\n                        _context142.next = 9;\n                        return this.crypto.generateRandomKey(128);\n\n                      case 9:\n                        iv = _context142.sent;\n                        _context142.next = 12;\n                        return this.crypto.encryptText(string, encryptionKey, iv);\n\n                      case 12:\n                        contentCiphertext = _context142.sent;\n                        ciphertextToAuth = [auth_params.version, uuid, iv, contentCiphertext].join(\":\");\n                        _context142.next = 16;\n                        return this.crypto.hmac256(ciphertextToAuth, authKey);\n\n                      case 16:\n                        authHash = _context142.sent;\n                        _context142.next = 19;\n                        return this.crypto.base64(JSON.stringify(auth_params));\n\n                      case 19:\n                        authParamsString = _context142.sent;\n                        fullCiphertext = [auth_params.version, authHash, uuid, iv, contentCiphertext, authParamsString].join(\":\");\n\n                      case 21:\n                        return _context142.abrupt(\"return\", fullCiphertext);\n\n                      case 22:\n                      case \"end\":\n                        return _context142.stop();\n                    }\n                  }\n                }, _callee142, this);\n              }));\n\n              function _private_encryptString(_x185, _x186, _x187, _x188, _x189) {\n                return _ref151.apply(this, arguments);\n              }\n\n              return _private_encryptString;\n            }()\n          }, {\n            key: \"encryptItem\",\n            value: function () {\n              var _ref152 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee143(item, keys, auth_params) {\n                var params, item_key, ek, ak, ciphertext, authHash;\n                return regeneratorRuntime.wrap(function _callee143$(_context143) {\n                  while (1) {\n                    switch (_context143.prev = _context143.next) {\n                      case 0:\n                        params = {}; // encrypt item key\n\n                        _context143.next = 3;\n                        return this.crypto.generateItemEncryptionKey();\n\n                      case 3:\n                        item_key = _context143.sent;\n\n                        if (!(auth_params.version === \"001\")) {\n                          _context143.next = 10;\n                          break;\n                        }\n\n                        _context143.next = 7;\n                        return this.crypto.encryptText(item_key, keys.mk, null);\n\n                      case 7:\n                        params.enc_item_key = _context143.sent;\n                        _context143.next = 13;\n                        break;\n\n                      case 10:\n                        _context143.next = 12;\n                        return this._private_encryptString(item_key, keys.mk, keys.ak, item.uuid, auth_params);\n\n                      case 12:\n                        params.enc_item_key = _context143.sent;\n\n                      case 13:\n                        _context143.next = 15;\n                        return this.crypto.firstHalfOfKey(item_key);\n\n                      case 15:\n                        ek = _context143.sent;\n                        _context143.next = 18;\n                        return this.crypto.secondHalfOfKey(item_key);\n\n                      case 18:\n                        ak = _context143.sent;\n                        _context143.next = 21;\n                        return this._private_encryptString(JSON.stringify(item.createContentJSONFromProperties()), ek, ak, item.uuid, auth_params);\n\n                      case 21:\n                        ciphertext = _context143.sent;\n\n                        if (!(auth_params.version === \"001\")) {\n                          _context143.next = 27;\n                          break;\n                        }\n\n                        _context143.next = 25;\n                        return this.crypto.hmac256(ciphertext, ak);\n\n                      case 25:\n                        authHash = _context143.sent;\n                        params.auth_hash = authHash;\n\n                      case 27:\n                        params.content = ciphertext;\n                        return _context143.abrupt(\"return\", params);\n\n                      case 29:\n                      case \"end\":\n                        return _context143.stop();\n                    }\n                  }\n                }, _callee143, this);\n              }));\n\n              function encryptItem(_x190, _x191, _x192) {\n                return _ref152.apply(this, arguments);\n              }\n\n              return encryptItem;\n            }()\n          }, {\n            key: \"encryptionComponentsFromString\",\n            value: function encryptionComponentsFromString(string, encryptionKey, authKey) {\n              var encryptionVersion = string.substring(0, 3);\n\n              if (encryptionVersion === \"001\") {\n                return {\n                  contentCiphertext: string.substring(3, string.length),\n                  encryptionVersion: encryptionVersion,\n                  ciphertextToAuth: string,\n                  iv: null,\n                  authHash: null,\n                  encryptionKey: encryptionKey,\n                  authKey: authKey\n                };\n              } else {\n                var components = string.split(\":\");\n                return {\n                  encryptionVersion: components[0],\n                  authHash: components[1],\n                  uuid: components[2],\n                  iv: components[3],\n                  contentCiphertext: components[4],\n                  authParams: components[5],\n                  ciphertextToAuth: [components[0], components[2], components[3], components[4]].join(\":\"),\n                  encryptionKey: encryptionKey,\n                  authKey: authKey\n                };\n              }\n            }\n          }, {\n            key: \"decryptItem\",\n            value: function () {\n              var _ref153 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee144(item, keys) {\n                var encryptedItemKey, requiresAuth, keyParams, item_key, ek, ak, itemParams, content;\n                return regeneratorRuntime.wrap(function _callee144$(_context144) {\n                  while (1) {\n                    switch (_context144.prev = _context144.next) {\n                      case 0:\n                        if (!(typeof item.content != \"string\")) {\n                          _context144.next = 2;\n                          break;\n                        }\n\n                        return _context144.abrupt(\"return\");\n\n                      case 2:\n                        if (!item.content.startsWith(\"000\")) {\n                          _context144.next = 14;\n                          break;\n                        }\n\n                        _context144.prev = 3;\n                        _context144.t0 = JSON;\n                        _context144.next = 7;\n                        return this.crypto.base64Decode(item.content.substring(3, item.content.length));\n\n                      case 7:\n                        _context144.t1 = _context144.sent;\n                        item.content = _context144.t0.parse.call(_context144.t0, _context144.t1);\n                        _context144.next = 13;\n                        break;\n\n                      case 11:\n                        _context144.prev = 11;\n                        _context144.t2 = _context144[\"catch\"](3);\n\n                      case 13:\n                        return _context144.abrupt(\"return\");\n\n                      case 14:\n                        if (item.enc_item_key) {\n                          _context144.next = 17;\n                          break;\n                        } // This needs to be here to continue, return otherwise\n\n\n                        console.log(\"Missing item encryption key, skipping decryption.\");\n                        return _context144.abrupt(\"return\");\n\n                      case 17:\n                        // decrypt encrypted key\n                        encryptedItemKey = item.enc_item_key;\n                        requiresAuth = true;\n\n                        if (!encryptedItemKey.startsWith(\"002\") && !encryptedItemKey.startsWith(\"003\")) {\n                          // legacy encryption type, has no prefix\n                          encryptedItemKey = \"001\" + encryptedItemKey;\n                          requiresAuth = false;\n                        }\n\n                        keyParams = this.encryptionComponentsFromString(encryptedItemKey, keys.mk, keys.ak); // return if uuid in auth hash does not match item uuid. Signs of tampering.\n\n                        if (!(keyParams.uuid && keyParams.uuid !== item.uuid)) {\n                          _context144.next = 26;\n                          break;\n                        }\n\n                        console.error(\"Item key params UUID does not match item UUID\");\n\n                        if (!item.errorDecrypting) {\n                          item.errorDecryptingValueChanged = true;\n                        }\n\n                        item.errorDecrypting = true;\n                        return _context144.abrupt(\"return\");\n\n                      case 26:\n                        _context144.next = 28;\n                        return this.crypto.decryptText(keyParams, requiresAuth);\n\n                      case 28:\n                        item_key = _context144.sent;\n\n                        if (item_key) {\n                          _context144.next = 34;\n                          break;\n                        }\n\n                        console.log(\"Error decrypting item\", item);\n\n                        if (!item.errorDecrypting) {\n                          item.errorDecryptingValueChanged = true;\n                        }\n\n                        item.errorDecrypting = true;\n                        return _context144.abrupt(\"return\");\n\n                      case 34:\n                        _context144.next = 36;\n                        return this.crypto.firstHalfOfKey(item_key);\n\n                      case 36:\n                        ek = _context144.sent;\n                        _context144.next = 39;\n                        return this.crypto.secondHalfOfKey(item_key);\n\n                      case 39:\n                        ak = _context144.sent;\n                        itemParams = this.encryptionComponentsFromString(item.content, ek, ak);\n                        _context144.prev = 41;\n                        _context144.t3 = JSON;\n                        _context144.next = 45;\n                        return this.crypto.base64Decode(itemParams.authParams);\n\n                      case 45:\n                        _context144.t4 = _context144.sent;\n                        item.auth_params = _context144.t3.parse.call(_context144.t3, _context144.t4);\n                        _context144.next = 51;\n                        break;\n\n                      case 49:\n                        _context144.prev = 49;\n                        _context144.t5 = _context144[\"catch\"](41);\n\n                      case 51:\n                        if (!(itemParams.uuid && itemParams.uuid !== item.uuid)) {\n                          _context144.next = 55;\n                          break;\n                        }\n\n                        if (!item.errorDecrypting) {\n                          item.errorDecryptingValueChanged = true;\n                        }\n\n                        item.errorDecrypting = true;\n                        return _context144.abrupt(\"return\");\n\n                      case 55:\n                        if (!itemParams.authHash) {\n                          // legacy 001\n                          itemParams.authHash = item.auth_hash;\n                        }\n\n                        _context144.next = 58;\n                        return this.crypto.decryptText(itemParams, true);\n\n                      case 58:\n                        content = _context144.sent;\n\n                        if (!content) {\n                          if (!item.errorDecrypting) {\n                            item.errorDecryptingValueChanged = true;\n                          }\n\n                          item.errorDecrypting = true;\n                        } else {\n                          if (item.errorDecrypting == true) {\n                            item.errorDecryptingValueChanged = true;\n                          } // Content should only be set if it was successfully decrypted, and should otherwise remain unchanged.\n\n\n                          item.errorDecrypting = false;\n                          item.content = content;\n                        }\n\n                      case 60:\n                      case \"end\":\n                        return _context144.stop();\n                    }\n                  }\n                }, _callee144, this, [[3, 11], [41, 49]]);\n              }));\n\n              function decryptItem(_x193, _x194) {\n                return _ref153.apply(this, arguments);\n              }\n\n              return decryptItem;\n            }()\n          }, {\n            key: \"decryptMultipleItems\",\n            value: function () {\n              var _ref154 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee146(items, keys, throws) {\n                var _this36 = this;\n\n                var decrypt;\n                return regeneratorRuntime.wrap(function _callee146$(_context146) {\n                  while (1) {\n                    switch (_context146.prev = _context146.next) {\n                      case 0:\n                        decrypt = function () {\n                          var _ref155 = _asyncToGenerator(\n                          /*#__PURE__*/\n                          regeneratorRuntime.mark(function _callee145(item) {\n                            var isString;\n                            return regeneratorRuntime.wrap(function _callee145$(_context145) {\n                              while (1) {\n                                switch (_context145.prev = _context145.next) {\n                                  case 0:\n                                    if (item) {\n                                      _context145.next = 2;\n                                      break;\n                                    }\n\n                                    return _context145.abrupt(\"return\");\n\n                                  case 2:\n                                    if (!(item.deleted == true && item.content == null)) {\n                                      _context145.next = 4;\n                                      break;\n                                    }\n\n                                    return _context145.abrupt(\"return\");\n\n                                  case 4:\n                                    isString = typeof item.content === 'string' || item.content instanceof String;\n\n                                    if (!isString) {\n                                      _context145.next = 19;\n                                      break;\n                                    }\n\n                                    _context145.prev = 6;\n                                    _context145.next = 9;\n                                    return _this36.decryptItem(item, keys);\n\n                                  case 9:\n                                    _context145.next = 19;\n                                    break;\n\n                                  case 11:\n                                    _context145.prev = 11;\n                                    _context145.t0 = _context145[\"catch\"](6);\n\n                                    if (!item.errorDecrypting) {\n                                      item.errorDecryptingValueChanged = true;\n                                    }\n\n                                    item.errorDecrypting = true;\n\n                                    if (!throws) {\n                                      _context145.next = 17;\n                                      break;\n                                    }\n\n                                    throw _context145.t0;\n\n                                  case 17:\n                                    console.error(\"Error decrypting item\", item, _context145.t0);\n                                    return _context145.abrupt(\"return\");\n\n                                  case 19:\n                                  case \"end\":\n                                    return _context145.stop();\n                                }\n                              }\n                            }, _callee145, _this36, [[6, 11]]);\n                          }));\n\n                          return function decrypt(_x198) {\n                            return _ref155.apply(this, arguments);\n                          };\n                        }();\n\n                        return _context146.abrupt(\"return\", Promise.all(items.map(function (item) {\n                          return decrypt(item);\n                        })));\n\n                      case 2:\n                      case \"end\":\n                        return _context146.stop();\n                    }\n                  }\n                }, _callee146, this);\n              }));\n\n              function decryptMultipleItems(_x195, _x196, _x197) {\n                return _ref154.apply(this, arguments);\n              }\n\n              return decryptMultipleItems;\n            }()\n          }]);\n\n          return SFItemTransformer;\n        }();\n\n        ;\n        var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;\n\n        var StandardFile = exports.StandardFile = function () {\n          function StandardFile(cryptoInstance) {\n            _classCallCheck(this, StandardFile); // This library runs in native environments as well (react native)\n\n\n            if (globalScope) {\n              // detect IE8 and above, and edge.\n              // IE and Edge do not support pbkdf2 in WebCrypto, therefore we need to use CryptoJS\n              var IEOrEdge = typeof document !== 'undefined' && document.documentMode || /Edge/.test(navigator.userAgent);\n\n              if (!IEOrEdge && globalScope.crypto && globalScope.crypto.subtle) {\n                this.crypto = new SFCryptoWeb();\n              } else {\n                this.crypto = new SFCryptoJS();\n              }\n            } // This must be placed outside window check, as it's used in native.\n\n\n            if (cryptoInstance) {\n              this.crypto = cryptoInstance;\n            }\n\n            this.itemTransformer = new SFItemTransformer(this.crypto);\n            this.crypto.SFJS = {\n              version: this.version(),\n              defaultPasswordGenerationCost: this.defaultPasswordGenerationCost()\n            };\n          }\n\n          _createClass(StandardFile, [{\n            key: \"version\",\n            value: function version() {\n              return \"003\";\n            }\n          }, {\n            key: \"supportsPasswordDerivationCost\",\n            value: function supportsPasswordDerivationCost(cost) {\n              // some passwords are created on platforms with stronger pbkdf2 capabilities, like iOS,\n              // which CryptoJS can't handle here (WebCrypto can however).\n              // if user has high password cost and is using browser that doesn't support WebCrypto,\n              // we want to tell them that they can't login with this browser.\n              if (cost > 5000) {\n                return this.crypto instanceof SFCryptoWeb;\n              } else {\n                return true;\n              }\n            } // Returns the versions that this library supports technically.\n\n          }, {\n            key: \"supportedVersions\",\n            value: function supportedVersions() {\n              return [\"001\", \"002\", \"003\"];\n            }\n          }, {\n            key: \"isVersionNewerThanLibraryVersion\",\n            value: function isVersionNewerThanLibraryVersion(version) {\n              var libraryVersion = this.version();\n              return parseInt(version) > parseInt(libraryVersion);\n            }\n          }, {\n            key: \"isProtocolVersionOutdated\",\n            value: function isProtocolVersionOutdated(version) {\n              // YYYY-MM-DD\n              var expirationDates = {\n                \"001\": Date.parse(\"2018-01-01\"),\n                \"002\": Date.parse(\"2020-01-01\")\n              };\n              var date = expirationDates[version];\n\n              if (!date) {\n                // No expiration date, is active version\n                return false;\n              }\n\n              var expired = new Date() > date;\n              return expired;\n            }\n          }, {\n            key: \"costMinimumForVersion\",\n            value: function costMinimumForVersion(version) {\n              return {\n                \"001\": 3000,\n                \"002\": 3000,\n                \"003\": 110000\n              }[version];\n            }\n          }, {\n            key: \"defaultPasswordGenerationCost\",\n            value: function defaultPasswordGenerationCost() {\n              return this.costMinimumForVersion(this.version());\n            }\n          }]);\n\n          return StandardFile;\n        }();\n\n        if (globalScope) {\n          // window is for some reason defined in React Native, but throws an exception when you try to set to it\n          try {\n            globalScope.StandardFile = StandardFile;\n            globalScope.SFJS = new StandardFile();\n            globalScope.SFCryptoWeb = SFCryptoWeb;\n            globalScope.SFCryptoJS = SFCryptoJS;\n            globalScope.SFItemTransformer = SFItemTransformer;\n            globalScope.SFModelManager = SFModelManager;\n            globalScope.SFItem = SFItem;\n            globalScope.SFItemParams = SFItemParams;\n            globalScope.SFHttpManager = SFHttpManager;\n            globalScope.SFStorageManager = SFStorageManager;\n            globalScope.SFSyncManager = SFSyncManager;\n            globalScope.SFAuthManager = SFAuthManager;\n            globalScope.SFMigrationManager = SFMigrationManager;\n            globalScope.SFAlertManager = SFAlertManager;\n            globalScope.SFPredicate = SFPredicate;\n            globalScope.SFHistorySession = SFHistorySession;\n            globalScope.SFSessionHistoryManager = SFSessionHistoryManager;\n            globalScope.SFItemHistory = SFItemHistory;\n            globalScope.SFItemHistoryEntry = SFItemHistoryEntry;\n            globalScope.SFPrivilegesManager = SFPrivilegesManager;\n            globalScope.SFPrivileges = SFPrivileges;\n            globalScope.SFSingletonManager = SFSingletonManager;\n          } catch (e) {\n            console.log(\"Exception while exporting window variables\", e);\n          }\n        }\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}]\n  }, {}, [1])(1);\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js_dist_lodash_min_js__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js_dist_lodash_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_standard_file_js_dist_lodash_min_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_standard_file_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_standard_file_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_standard_file_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__RelayManager__ = __webpack_require__(6);\n\n\n\n\n\nself.addEventListener('message', async function(e) {\n  var data = e.data;\n\n  if(data.operation == \"encrypt\") {\n    var fileItem = new __WEBPACK_IMPORTED_MODULE_2_standard_file_js__[\"SFItem\"]({\n      content_type: data.contentType,\n      content: {\n        rawData: data.fileData,\n        fileName: data.fileName,\n        fileType: data.fileType\n      }\n    });\n\n    var itemParamsObject = new __WEBPACK_IMPORTED_MODULE_2_standard_file_js__[\"SFItemParams\"](fileItem, data.keys, data.authParams);\n    itemParamsObject.paramsForSync().then((itemParams) => {\n      // Encryption complete\n      self.postMessage({\n        itemParams: itemParams\n      });\n    })\n  } else if(data.operation == \"decrypt\") {\n    SFJS.itemTransformer.decryptItem(data.item, data.keys).then(() => {\n      var decryptedItem = new __WEBPACK_IMPORTED_MODULE_2_standard_file_js__[\"SFItem\"](data.item);\n      var decryptedData = decryptedItem.content.rawData;\n      if(decryptedItem.errorDecrypting) {\n        self.postMessage({error: {message: \"Error decrypting.\"}});\n      } else {\n        self.postMessage({\n          decryptedData: decryptedData,\n          decryptedItem: decryptedItem\n        });\n      }\n    }).catch((error) => {\n      console.log(\"Decryption error:\", error);\n      self.postMessage({error: error});\n    })\n  } else if(data.operation == \"upload\") {\n    __WEBPACK_IMPORTED_MODULE_3__RelayManager__[\"a\" /* default */].get().setCredentials(data.credentials);\n    __WEBPACK_IMPORTED_MODULE_3__RelayManager__[\"a\" /* default */].get().uploadFile(data.outputFileName, data.itemParams, data.integration).then((metadata) => {\n      self.postMessage({metadata});\n    }).catch((error) => {\n      self.postMessage({error: error});\n      console.log(\"Upload exception\", error);\n    });\n  }\n\n}, false);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE\n * Build: `lodash include=\"includes,merge,filter,map,remove,find,omit,pull,cloneDeep,pick,uniq,sortedIndexBy,mergeWith\"`\n */\n;\n(function () {\n  function t(t, e) {\n    return t.set(e[0], e[1]), t;\n  }\n\n  function e(t, e) {\n    return t.add(e), t;\n  }\n\n  function n(t, e, n) {\n    switch (n.length) {\n      case 0:\n        return t.call(e);\n\n      case 1:\n        return t.call(e, n[0]);\n\n      case 2:\n        return t.call(e, n[0], n[1]);\n\n      case 3:\n        return t.call(e, n[0], n[1], n[2]);\n    }\n\n    return t.apply(e, n);\n  }\n\n  function r(t, e) {\n    for (var n = -1, r = null == t ? 0 : t.length; ++n < r && false !== e(t[n], n, t););\n  }\n\n  function o(t, e) {\n    for (var n = -1, r = null == t ? 0 : t.length, o = 0, u = []; ++n < r;) {\n      var c = t[n];\n      e(c, n, t) && (u[o++] = c);\n    }\n\n    return u;\n  }\n\n  function u(t, e) {\n    return !(null == t || !t.length) && -1 < s(t, e, 0);\n  }\n\n  function c(t, e) {\n    for (var n = -1, r = null == t ? 0 : t.length, o = Array(r); ++n < r;) o[n] = e(t[n], n, t);\n\n    return o;\n  }\n\n  function i(t, e) {\n    for (var n = -1, r = e.length, o = t.length; ++n < r;) t[o + n] = e[n];\n\n    return t;\n  }\n\n  function a(t, e, n) {\n    for (var r = -1, o = null == t ? 0 : t.length; ++r < o;) n = e(n, t[r], r, t);\n\n    return n;\n  }\n\n  function f(t, e) {\n    for (var n = -1, r = null == t ? 0 : t.length; ++n < r;) if (e(t[n], n, t)) return true;\n\n    return false;\n  }\n\n  function l(t, e, n) {\n    var r = t.length;\n\n    for (n += -1; ++n < r;) if (e(t[n], n, t)) return n;\n\n    return -1;\n  }\n\n  function s(t, e, n) {\n    if (e === e) t: {\n      --n;\n\n      for (var r = t.length; ++n < r;) if (t[n] === e) {\n        t = n;\n        break t;\n      }\n\n      t = -1;\n    } else t = l(t, b, n);\n    return t;\n  }\n\n  function b(t) {\n    return t !== t;\n  }\n\n  function h(t) {\n    return function (e) {\n      return null == e ? ae : e[t];\n    };\n  }\n\n  function p(t) {\n    return function (e) {\n      return t(e);\n    };\n  }\n\n  function y(t, e) {\n    return c(e, function (e) {\n      return t[e];\n    });\n  }\n\n  function j(t, e) {\n    return t.has(e);\n  }\n\n  function v(t) {\n    var e = -1,\n        n = Array(t.size);\n    return t.forEach(function (t, r) {\n      n[++e] = [r, t];\n    }), n;\n  }\n\n  function g(t) {\n    var e = Object;\n    return function (n) {\n      return t(e(n));\n    };\n  }\n\n  function _(t) {\n    var e = -1,\n        n = Array(t.size);\n    return t.forEach(function (t) {\n      n[++e] = t;\n    }), n;\n  }\n\n  function d() {}\n\n  function A(t) {\n    var e = -1,\n        n = null == t ? 0 : t.length;\n\n    for (this.clear(); ++e < n;) {\n      var r = t[e];\n      this.set(r[0], r[1]);\n    }\n  }\n\n  function w(t) {\n    var e = -1,\n        n = null == t ? 0 : t.length;\n\n    for (this.clear(); ++e < n;) {\n      var r = t[e];\n      this.set(r[0], r[1]);\n    }\n  }\n\n  function m(t) {\n    var e = -1,\n        n = null == t ? 0 : t.length;\n\n    for (this.clear(); ++e < n;) {\n      var r = t[e];\n      this.set(r[0], r[1]);\n    }\n  }\n\n  function O(t) {\n    var e = -1,\n        n = null == t ? 0 : t.length;\n\n    for (this.__data__ = new m(); ++e < n;) this.add(t[e]);\n  }\n\n  function S(t) {\n    this.size = (this.__data__ = new w(t)).size;\n  }\n\n  function k(t, e) {\n    var n = Dn(t),\n        r = !n && Bn(t),\n        o = !n && !r && Pn(t),\n        u = !n && !r && !o && Ln(t);\n\n    if (n = n || r || o || u) {\n      for (var r = t.length, c = String, i = -1, a = Array(r); ++i < r;) a[i] = c(i);\n\n      r = a;\n    } else r = [];\n\n    var f,\n        c = r.length;\n\n    for (f in t) !e && !Ne.call(t, f) || n && (\"length\" == f || o && (\"offset\" == f || \"parent\" == f) || u && (\"buffer\" == f || \"byteLength\" == f || \"byteOffset\" == f) || mt(f, c)) || r.push(f);\n\n    return r;\n  }\n\n  function z(t, e, n) {\n    (n === ae || Bt(t[e], n)) && (n !== ae || e in t) || M(t, e, n);\n  }\n\n  function x(t, e, n) {\n    var r = t[e];\n    Ne.call(t, e) && Bt(r, n) && (n !== ae || e in t) || M(t, e, n);\n  }\n\n  function I(t, e) {\n    for (var n = t.length; n--;) if (Bt(t[n][0], e)) return n;\n\n    return -1;\n  }\n\n  function F(t, e) {\n    return t && ut(e, Yt(e), t);\n  }\n\n  function E(t, e) {\n    return t && ut(e, Zt(e), t);\n  }\n\n  function M(t, e, n) {\n    \"__proto__\" == e && tn ? tn(t, e, {\n      configurable: true,\n      enumerable: true,\n      value: n,\n      writable: true\n    }) : t[e] = n;\n  }\n\n  function $(t, e, n, o, u, c) {\n    var i,\n        a = 1 & e,\n        f = 2 & e,\n        l = 4 & e;\n    if (n && (i = u ? n(t, o, u, c) : n(t)), i !== ae) return i;\n    if (!Vt(t)) return t;\n\n    if (o = Dn(t)) {\n      if (i = _t(t), !a) return ot(t, i);\n    } else {\n      var s = Fn(t),\n          b = \"[object Function]\" == s || \"[object GeneratorFunction]\" == s;\n      if (Pn(t)) return et(t, a);\n\n      if (\"[object Object]\" == s || \"[object Arguments]\" == s || b && !u) {\n        if (i = f || b ? {} : dt(t), !a) return f ? it(t, E(i, t)) : ct(t, F(i, t));\n      } else {\n        if (!Oe[s]) return u ? t : {};\n        i = At(t, s, $, a);\n      }\n    }\n\n    if (c || (c = new S()), u = c.get(t)) return u;\n    c.set(t, i);\n    var f = l ? f ? pt : ht : f ? Zt : Yt,\n        h = o ? ae : f(t);\n    return r(h || t, function (r, o) {\n      h && (o = r, r = t[o]), x(i, o, $(r, e, n, o, t, c));\n    }), i;\n  }\n\n  function U(t, e) {\n    var n = [];\n    return On(t, function (t, r, o) {\n      e(t, r, o) && n.push(t);\n    }), n;\n  }\n\n  function B(t, e, n, r, o) {\n    var u = -1,\n        c = t.length;\n\n    for (n || (n = wt), o || (o = []); ++u < c;) {\n      var a = t[u];\n      0 < e && n(a) ? 1 < e ? B(a, e - 1, n, r, o) : i(o, a) : r || (o[o.length] = a);\n    }\n\n    return o;\n  }\n\n  function D(t, e) {\n    e = tt(e, t);\n\n    for (var n = 0, r = e.length; null != t && n < r;) t = t[xt(e[n++])];\n\n    return n && n == r ? t : ae;\n  }\n\n  function P(t, e, n) {\n    return e = e(t), Dn(t) ? e : i(e, n(t));\n  }\n\n  function L(t) {\n    if (null == t) t = t === ae ? \"[object Undefined]\" : \"[object Null]\";else if (Ze && Ze in Object(t)) {\n      var e = Ne.call(t, Ze),\n          n = t[Ze];\n\n      try {\n        t[Ze] = ae;\n        var r = true;\n      } catch (t) {}\n\n      var o = Ce.call(t);\n      r && (e ? t[Ze] = n : delete t[Ze]), t = o;\n    } else t = Ce.call(t);\n    return t;\n  }\n\n  function N(t) {\n    return Ct(t) && \"[object Arguments]\" == L(t);\n  }\n\n  function V(t, e, n, r, o) {\n    if (t === e) e = true;else if (null == t || null == e || !Ct(t) && !Ct(e)) e = t !== t && e !== e;else t: {\n      var u = Dn(t),\n          c = Dn(e),\n          i = u ? \"[object Array]\" : Fn(t),\n          a = c ? \"[object Array]\" : Fn(e),\n          i = \"[object Arguments]\" == i ? \"[object Object]\" : i,\n          a = \"[object Arguments]\" == a ? \"[object Object]\" : a,\n          f = \"[object Object]\" == i,\n          c = \"[object Object]\" == a;\n\n      if ((a = i == a) && Pn(t)) {\n        if (!Pn(e)) {\n          e = false;\n          break t;\n        }\n\n        u = true, f = false;\n      }\n\n      if (a && !f) o || (o = new S()), e = u || Ln(t) ? lt(t, e, n, r, V, o) : st(t, e, i, n, r, V, o);else {\n        if (!(1 & n) && (u = f && Ne.call(t, \"__wrapped__\"), i = c && Ne.call(e, \"__wrapped__\"), u || i)) {\n          t = u ? t.value() : t, e = i ? e.value() : e, o || (o = new S()), e = V(t, e, n, r, o);\n          break t;\n        }\n\n        if (a) {\n          e: if (o || (o = new S()), u = 1 & n, i = ht(t), c = i.length, a = ht(e).length, c == a || u) {\n            for (f = c; f--;) {\n              var l = i[f];\n\n              if (!(u ? l in e : Ne.call(e, l))) {\n                e = false;\n                break e;\n              }\n            }\n\n            if ((a = o.get(t)) && o.get(e)) e = a == e;else {\n              a = true, o.set(t, e), o.set(e, t);\n\n              for (var s = u; ++f < c;) {\n                var l = i[f],\n                    b = t[l],\n                    h = e[l];\n                if (r) var p = u ? r(h, b, l, e, t, o) : r(b, h, l, t, e, o);\n\n                if (p === ae ? b !== h && !V(b, h, n, r, o) : !p) {\n                  a = false;\n                  break;\n                }\n\n                s || (s = \"constructor\" == l);\n              }\n\n              a && !s && (n = t.constructor, r = e.constructor, n != r && \"constructor\" in t && \"constructor\" in e && !(typeof n == \"function\" && n instanceof n && typeof r == \"function\" && r instanceof r) && (a = false)), o.delete(t), o.delete(e), e = a;\n            }\n          } else e = false;\n        } else e = false;\n      }\n    }\n    return e;\n  }\n\n  function C(t, e) {\n    var n = e.length,\n        r = n;\n    if (null == t) return !r;\n\n    for (t = Object(t); n--;) {\n      var o = e[n];\n      if (o[2] ? o[1] !== t[o[0]] : !(o[0] in t)) return false;\n    }\n\n    for (; ++n < r;) {\n      var o = e[n],\n          u = o[0],\n          c = t[u],\n          i = o[1];\n\n      if (o[2]) {\n        if (c === ae && !(u in t)) return false;\n      } else if (o = new S(), void 0 === ae ? !V(i, c, 3, void 0, o) : 1) return false;\n    }\n\n    return true;\n  }\n\n  function R(t) {\n    return Ct(t) && Nt(t.length) && !!me[L(t)];\n  }\n\n  function T(t) {\n    return typeof t == \"function\" ? t : null == t ? ne : typeof t == \"object\" ? Dn(t) ? G(t[0], t[1]) : q(t) : ue(t);\n  }\n\n  function W(t, e) {\n    var n = -1,\n        r = Dt(t) ? Array(t.length) : [];\n    return On(t, function (t, o, u) {\n      r[++n] = e(t, o, u);\n    }), r;\n  }\n\n  function q(t) {\n    var e = vt(t);\n    return 1 == e.length && e[0][2] ? kt(e[0][0], e[0][1]) : function (n) {\n      return n === t || C(n, e);\n    };\n  }\n\n  function G(t, e) {\n    return Ot(t) && e === e && !Vt(e) ? kt(xt(t), e) : function (n) {\n      var r = Qt(n, t);\n      return r === ae && r === e ? Xt(n, t) : V(e, r, 3);\n    };\n  }\n\n  function H(t, e, n, r, o) {\n    t !== e && Sn(e, function (u, c) {\n      if (Vt(u)) {\n        o || (o = new S());\n        var i = o,\n            a = t[c],\n            f = e[c],\n            l = i.get(f);\n        if (l) z(t, c, l);else {\n          var l = r ? r(a, f, c + \"\", t, e, i) : ae,\n              s = l === ae;\n\n          if (s) {\n            var b = Dn(f),\n                h = !b && Pn(f),\n                p = !b && !h && Ln(f),\n                l = f;\n            b || h || p ? Dn(a) ? l = a : Pt(a) ? l = ot(a) : h ? (s = false, l = et(f, true)) : p ? (s = false, l = rt(f, true)) : l = [] : Rt(f) || Bn(f) ? (l = a, Bn(a) ? l = Jt(a) : (!Vt(a) || n && Lt(a)) && (l = dt(f))) : s = false;\n          }\n\n          s && (i.set(f, l), H(l, f, n, r, i), i.delete(f)), z(t, c, l);\n        }\n      } else i = r ? r(t[c], u, c + \"\", t, e, o) : ae, i === ae && (i = u), z(t, c, i);\n    }, Zt);\n  }\n\n  function J(t, e) {\n    return K(t, e, function (e, n) {\n      return Xt(t, n);\n    });\n  }\n\n  function K(t, e, n) {\n    for (var r = -1, o = e.length, u = {}; ++r < o;) {\n      var c = e[r],\n          i = D(t, c);\n\n      if (n(i, c)) {\n        var a = u,\n            c = tt(c, t);\n        if (Vt(a)) for (var c = tt(c, a), f = -1, l = c.length, s = l - 1; null != a && ++f < l;) {\n          var b = xt(c[f]),\n              h = i;\n\n          if (f != s) {\n            var p = a[b],\n                h = ae;\n            h === ae && (h = Vt(p) ? p : mt(c[f + 1]) ? [] : {});\n          }\n\n          x(a, b, h), a = a[b];\n        }\n      }\n    }\n\n    return u;\n  }\n\n  function Q(t) {\n    return function (e) {\n      return D(e, t);\n    };\n  }\n\n  function X(t) {\n    return En(zt(t, void 0, ne), t + \"\");\n  }\n\n  function Y(t) {\n    if (typeof t == \"string\") return t;\n    if (Dn(t)) return c(t, Y) + \"\";\n    if (Wt(t)) return wn ? wn.call(t) : \"\";\n    var e = t + \"\";\n    return \"0\" == e && 1 / t == -fe ? \"-0\" : e;\n  }\n\n  function Z(t, e) {\n    e = tt(e, t);\n    var n;\n    if (2 > e.length) n = t;else {\n      n = e;\n      var r = 0,\n          o = -1,\n          u = -1,\n          c = n.length;\n\n      for (0 > r && (r = -r > c ? 0 : c + r), o = o > c ? c : o, 0 > o && (o += c), c = r > o ? 0 : o - r >>> 0, r >>>= 0, o = Array(c); ++u < c;) o[u] = n[u + r];\n\n      n = D(t, o);\n    }\n    t = n, null == t || delete t[xt(Mt(e))];\n  }\n\n  function tt(t, e) {\n    return Dn(t) ? t : Ot(t, e) ? [t] : Mn(Kt(t));\n  }\n\n  function et(t, e) {\n    if (e) return t.slice();\n    var n = t.length,\n        n = He ? He(n) : new t.constructor(n);\n    return t.copy(n), n;\n  }\n\n  function nt(t) {\n    var e = new t.constructor(t.byteLength);\n    return new Ge(e).set(new Ge(t)), e;\n  }\n\n  function rt(t, e) {\n    return new t.constructor(e ? nt(t.buffer) : t.buffer, t.byteOffset, t.length);\n  }\n\n  function ot(t, e) {\n    var n = -1,\n        r = t.length;\n\n    for (e || (e = Array(r)); ++n < r;) e[n] = t[n];\n\n    return e;\n  }\n\n  function ut(t, e, n) {\n    var r = !n;\n    n || (n = {});\n\n    for (var o = -1, u = e.length; ++o < u;) {\n      var c = e[o],\n          i = ae;\n      i === ae && (i = t[c]), r ? M(n, c, i) : x(n, c, i);\n    }\n\n    return n;\n  }\n\n  function ct(t, e) {\n    return ut(t, xn(t), e);\n  }\n\n  function it(t, e) {\n    return ut(t, In(t), e);\n  }\n\n  function at(t) {\n    return X(function (e, n) {\n      var r,\n          o = -1,\n          u = n.length,\n          c = 1 < u ? n[u - 1] : ae,\n          i = 2 < u ? n[2] : ae,\n          c = 3 < t.length && typeof c == \"function\" ? (u--, c) : ae;\n\n      if (r = i) {\n        r = n[0];\n        var a = n[1];\n\n        if (Vt(i)) {\n          var f = typeof a;\n          r = !!(\"number\" == f ? Dt(i) && mt(a, i.length) : \"string\" == f && a in i) && Bt(i[a], r);\n        } else r = false;\n      }\n\n      for (r && (c = 3 > u ? ae : c, u = 1), e = Object(e); ++o < u;) (i = n[o]) && t(e, i, o, c);\n\n      return e;\n    });\n  }\n\n  function ft(t) {\n    return Rt(t) ? ae : t;\n  }\n\n  function lt(t, e, n, r, o, u) {\n    var c = 1 & n,\n        i = t.length,\n        a = e.length;\n    if (i != a && !(c && a > i)) return false;\n    if ((a = u.get(t)) && u.get(e)) return a == e;\n    var a = -1,\n        l = true,\n        s = 2 & n ? new O() : ae;\n\n    for (u.set(t, e), u.set(e, t); ++a < i;) {\n      var b = t[a],\n          h = e[a];\n      if (r) var p = c ? r(h, b, a, e, t, u) : r(b, h, a, t, e, u);\n\n      if (p !== ae) {\n        if (p) continue;\n        l = false;\n        break;\n      }\n\n      if (s) {\n        if (!f(e, function (t, e) {\n          if (!j(s, e) && (b === t || o(b, t, n, r, u))) return s.push(e);\n        })) {\n          l = false;\n          break;\n        }\n      } else if (b !== h && !o(b, h, n, r, u)) {\n        l = false;\n        break;\n      }\n    }\n\n    return u.delete(t), u.delete(e), l;\n  }\n\n  function st(t, e, n, r, o, u, c) {\n    switch (n) {\n      case \"[object DataView]\":\n        if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) break;\n        t = t.buffer, e = e.buffer;\n\n      case \"[object ArrayBuffer]\":\n        if (t.byteLength != e.byteLength || !u(new Ge(t), new Ge(e))) break;\n        return true;\n\n      case \"[object Boolean]\":\n      case \"[object Date]\":\n      case \"[object Number]\":\n        return Bt(+t, +e);\n\n      case \"[object Error]\":\n        return t.name == e.name && t.message == e.message;\n\n      case \"[object RegExp]\":\n      case \"[object String]\":\n        return t == e + \"\";\n\n      case \"[object Map]\":\n        var i = v;\n\n      case \"[object Set]\":\n        if (i || (i = _), t.size != e.size && !(1 & r)) break;\n        return (n = c.get(t)) ? n == e : (r |= 2, c.set(t, e), e = lt(i(t), i(e), r, o, u, c), c.delete(t), e);\n\n      case \"[object Symbol]\":\n        if (An) return An.call(t) == An.call(e);\n    }\n\n    return false;\n  }\n\n  function bt(t) {\n    return En(zt(t, ae, Et), t + \"\");\n  }\n\n  function ht(t) {\n    return P(t, Yt, xn);\n  }\n\n  function pt(t) {\n    return P(t, Zt, In);\n  }\n\n  function yt() {\n    var t = d.iteratee || re,\n        t = t === re ? T : t;\n    return arguments.length ? t(arguments[0], arguments[1]) : t;\n  }\n\n  function jt(t, e) {\n    var n = t.__data__,\n        r = typeof e;\n    return (\"string\" == r || \"number\" == r || \"symbol\" == r || \"boolean\" == r ? \"__proto__\" !== e : null === e) ? n[typeof e == \"string\" ? \"string\" : \"hash\"] : n.map;\n  }\n\n  function vt(t) {\n    for (var e = Yt(t), n = e.length; n--;) {\n      var r = e[n],\n          o = t[r];\n      e[n] = [r, o, o === o && !Vt(o)];\n    }\n\n    return e;\n  }\n\n  function gt(t, e) {\n    var n = null == t ? ae : t[e];\n    return (!Vt(n) || Ve && Ve in n ? 0 : (Lt(n) ? Te : de).test(It(n))) ? n : ae;\n  }\n\n  function _t(t) {\n    var e = t.length,\n        n = t.constructor(e);\n    return e && \"string\" == typeof t[0] && Ne.call(t, \"index\") && (n.index = t.index, n.input = t.input), n;\n  }\n\n  function dt(t) {\n    return typeof t.constructor != \"function\" || St(t) ? {} : mn(Je(t));\n  }\n\n  function At(n, r, o, u) {\n    var c = n.constructor;\n\n    switch (r) {\n      case \"[object ArrayBuffer]\":\n        return nt(n);\n\n      case \"[object Boolean]\":\n      case \"[object Date]\":\n        return new c(+n);\n\n      case \"[object DataView]\":\n        return r = u ? nt(n.buffer) : n.buffer, new n.constructor(r, n.byteOffset, n.byteLength);\n\n      case \"[object Float32Array]\":\n      case \"[object Float64Array]\":\n      case \"[object Int8Array]\":\n      case \"[object Int16Array]\":\n      case \"[object Int32Array]\":\n      case \"[object Uint8Array]\":\n      case \"[object Uint8ClampedArray]\":\n      case \"[object Uint16Array]\":\n      case \"[object Uint32Array]\":\n        return rt(n, u);\n\n      case \"[object Map]\":\n        return r = u ? o(v(n), 1) : v(n), a(r, t, new n.constructor());\n\n      case \"[object Number]\":\n      case \"[object String]\":\n        return new c(n);\n\n      case \"[object RegExp]\":\n        return r = new n.constructor(n.source, ve.exec(n)), r.lastIndex = n.lastIndex, r;\n\n      case \"[object Set]\":\n        return r = u ? o(_(n), 1) : _(n), a(r, e, new n.constructor());\n\n      case \"[object Symbol]\":\n        return An ? Object(An.call(n)) : {};\n    }\n  }\n\n  function wt(t) {\n    return Dn(t) || Bn(t) || !!(Ye && t && t[Ye]);\n  }\n\n  function mt(t, e) {\n    return e = null == e ? 9007199254740991 : e, !!e && (typeof t == \"number\" || we.test(t)) && -1 < t && 0 == t % 1 && t < e;\n  }\n\n  function Ot(t, e) {\n    if (Dn(t)) return false;\n    var n = typeof t;\n    return !(\"number\" != n && \"symbol\" != n && \"boolean\" != n && null != t && !Wt(t)) || be.test(t) || !se.test(t) || null != e && t in Object(e);\n  }\n\n  function St(t) {\n    var e = t && t.constructor;\n    return t === (typeof e == \"function\" && e.prototype || De);\n  }\n\n  function kt(t, e) {\n    return function (n) {\n      return null != n && n[t] === e && (e !== ae || t in Object(n));\n    };\n  }\n\n  function zt(t, e, r) {\n    return e = un(e === ae ? t.length - 1 : e, 0), function () {\n      for (var o = arguments, u = -1, c = un(o.length - e, 0), i = Array(c); ++u < c;) i[u] = o[e + u];\n\n      for (u = -1, c = Array(e + 1); ++u < e;) c[u] = o[u];\n\n      return c[e] = r(i), n(t, this, c);\n    };\n  }\n\n  function xt(t) {\n    if (typeof t == \"string\" || Wt(t)) return t;\n    var e = t + \"\";\n    return \"0\" == e && 1 / t == -fe ? \"-0\" : e;\n  }\n\n  function It(t) {\n    if (null != t) {\n      try {\n        return Le.call(t);\n      } catch (t) {}\n\n      return t + \"\";\n    }\n\n    return \"\";\n  }\n\n  function Ft(t, e, n) {\n    var r = null == t ? 0 : t.length;\n    return r ? (n = null == n ? 0 : Gt(n), 0 > n && (n = un(r + n, 0)), l(t, yt(e, 3), n)) : -1;\n  }\n\n  function Et(t) {\n    return (null == t ? 0 : t.length) ? B(t, 1) : [];\n  }\n\n  function Mt(t) {\n    var e = null == t ? 0 : t.length;\n    return e ? t[e - 1] : ae;\n  }\n\n  function $t(t, e) {\n    var n;\n\n    if (t && t.length && e && e.length) {\n      n = e;\n      var r = s,\n          o = -1,\n          u = n.length;\n\n      for (t === n && (n = ot(n)); ++o < u;) for (var c = 0, i = n[o]; -1 < (c = r(t, i, c, void 0));) t !== t && Xe.call(t, c, 1), Xe.call(t, c, 1);\n\n      n = t;\n    } else n = t;\n\n    return n;\n  }\n\n  function Ut(t, e) {\n    function n() {\n      var r = arguments,\n          o = e ? e.apply(this, r) : r[0],\n          u = n.cache;\n      return u.has(o) ? u.get(o) : (r = t.apply(this, r), n.cache = u.set(o, r) || u, r);\n    }\n\n    if (typeof t != \"function\" || null != e && typeof e != \"function\") throw new TypeError(\"Expected a function\");\n    return n.cache = new (Ut.Cache || m)(), n;\n  }\n\n  function Bt(t, e) {\n    return t === e || t !== t && e !== e;\n  }\n\n  function Dt(t) {\n    return null != t && Nt(t.length) && !Lt(t);\n  }\n\n  function Pt(t) {\n    return Ct(t) && Dt(t);\n  }\n\n  function Lt(t) {\n    return !!Vt(t) && (t = L(t), \"[object Function]\" == t || \"[object GeneratorFunction]\" == t || \"[object AsyncFunction]\" == t || \"[object Proxy]\" == t);\n  }\n\n  function Nt(t) {\n    return typeof t == \"number\" && -1 < t && 0 == t % 1 && 9007199254740991 >= t;\n  }\n\n  function Vt(t) {\n    var e = typeof t;\n    return null != t && (\"object\" == e || \"function\" == e);\n  }\n\n  function Ct(t) {\n    return null != t && typeof t == \"object\";\n  }\n\n  function Rt(t) {\n    return !(!Ct(t) || \"[object Object]\" != L(t)) && (t = Je(t), null === t || (t = Ne.call(t, \"constructor\") && t.constructor, typeof t == \"function\" && t instanceof t && Le.call(t) == Re));\n  }\n\n  function Tt(t) {\n    return typeof t == \"string\" || !Dn(t) && Ct(t) && \"[object String]\" == L(t);\n  }\n\n  function Wt(t) {\n    return typeof t == \"symbol\" || Ct(t) && \"[object Symbol]\" == L(t);\n  }\n\n  function qt(t) {\n    return t ? (t = Ht(t), t === fe || t === -fe ? 1.7976931348623157e308 * (0 > t ? -1 : 1) : t === t ? t : 0) : 0 === t ? t : 0;\n  }\n\n  function Gt(t) {\n    t = qt(t);\n    var e = t % 1;\n    return t === t ? e ? t - e : t : 0;\n  }\n\n  function Ht(t) {\n    if (typeof t == \"number\") return t;\n    if (Wt(t)) return le;\n    if (Vt(t) && (t = typeof t.valueOf == \"function\" ? t.valueOf() : t, t = Vt(t) ? t + \"\" : t), typeof t != \"string\") return 0 === t ? t : +t;\n    t = t.replace(ye, \"\");\n\n    var e = _e.test(t);\n\n    return e || Ae.test(t) ? ke(t.slice(2), e ? 2 : 8) : ge.test(t) ? le : +t;\n  }\n\n  function Jt(t) {\n    return ut(t, Zt(t));\n  }\n\n  function Kt(t) {\n    return null == t ? \"\" : Y(t);\n  }\n\n  function Qt(t, e, n) {\n    return t = null == t ? ae : D(t, e), t === ae ? n : t;\n  }\n\n  function Xt(t, e) {\n    var n;\n\n    if (n = null != t) {\n      n = t;\n      var r;\n      r = tt(e, n);\n\n      for (var o = -1, u = r.length, c = false; ++o < u;) {\n        var i = xt(r[o]);\n        if (!(c = null != n && null != n && i in Object(n))) break;\n        n = n[i];\n      }\n\n      c || ++o != u ? n = c : (u = null == n ? 0 : n.length, n = !!u && Nt(u) && mt(i, u) && (Dn(n) || Bn(n)));\n    }\n\n    return n;\n  }\n\n  function Yt(t) {\n    if (Dt(t)) t = k(t);else if (St(t)) {\n      var e,\n          n = [];\n\n      for (e in Object(t)) Ne.call(t, e) && \"constructor\" != e && n.push(e);\n\n      t = n;\n    } else t = on(t);\n    return t;\n  }\n\n  function Zt(t) {\n    if (Dt(t)) t = k(t, true);else if (Vt(t)) {\n      var e,\n          n = St(t),\n          r = [];\n\n      for (e in t) (\"constructor\" != e || !n && Ne.call(t, e)) && r.push(e);\n\n      t = r;\n    } else {\n      if (e = [], null != t) for (n in Object(t)) e.push(n);\n      t = e;\n    }\n    return t;\n  }\n\n  function te(t) {\n    return null == t ? [] : y(t, Yt(t));\n  }\n\n  function ee(t) {\n    return function () {\n      return t;\n    };\n  }\n\n  function ne(t) {\n    return t;\n  }\n\n  function re(t) {\n    return T(typeof t == \"function\" ? t : $(t, 1));\n  }\n\n  function oe() {}\n\n  function ue(t) {\n    return Ot(t) ? h(xt(t)) : Q(t);\n  }\n\n  function ce() {\n    return [];\n  }\n\n  function ie() {\n    return false;\n  }\n\n  var ae,\n      fe = 1 / 0,\n      le = NaN,\n      se = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      be = /^\\w*$/,\n      he = /^\\./,\n      pe = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n      ye = /^\\s+|\\s+$/g,\n      je = /\\\\(\\\\)?/g,\n      ve = /\\w*$/,\n      ge = /^[-+]0x[0-9a-f]+$/i,\n      _e = /^0b[01]+$/i,\n      de = /^\\[object .+?Constructor\\]$/,\n      Ae = /^0o[0-7]+$/i,\n      we = /^(?:0|[1-9]\\d*)$/,\n      me = {};\n  me[\"[object Float32Array]\"] = me[\"[object Float64Array]\"] = me[\"[object Int8Array]\"] = me[\"[object Int16Array]\"] = me[\"[object Int32Array]\"] = me[\"[object Uint8Array]\"] = me[\"[object Uint8ClampedArray]\"] = me[\"[object Uint16Array]\"] = me[\"[object Uint32Array]\"] = true, me[\"[object Arguments]\"] = me[\"[object Array]\"] = me[\"[object ArrayBuffer]\"] = me[\"[object Boolean]\"] = me[\"[object DataView]\"] = me[\"[object Date]\"] = me[\"[object Error]\"] = me[\"[object Function]\"] = me[\"[object Map]\"] = me[\"[object Number]\"] = me[\"[object Object]\"] = me[\"[object RegExp]\"] = me[\"[object Set]\"] = me[\"[object String]\"] = me[\"[object WeakMap]\"] = false;\n  var Oe = {};\n  Oe[\"[object Arguments]\"] = Oe[\"[object Array]\"] = Oe[\"[object ArrayBuffer]\"] = Oe[\"[object DataView]\"] = Oe[\"[object Boolean]\"] = Oe[\"[object Date]\"] = Oe[\"[object Float32Array]\"] = Oe[\"[object Float64Array]\"] = Oe[\"[object Int8Array]\"] = Oe[\"[object Int16Array]\"] = Oe[\"[object Int32Array]\"] = Oe[\"[object Map]\"] = Oe[\"[object Number]\"] = Oe[\"[object Object]\"] = Oe[\"[object RegExp]\"] = Oe[\"[object Set]\"] = Oe[\"[object String]\"] = Oe[\"[object Symbol]\"] = Oe[\"[object Uint8Array]\"] = Oe[\"[object Uint8ClampedArray]\"] = Oe[\"[object Uint16Array]\"] = Oe[\"[object Uint32Array]\"] = true, Oe[\"[object Error]\"] = Oe[\"[object Function]\"] = Oe[\"[object WeakMap]\"] = false;\n  var Se,\n      ke = parseInt,\n      ze = typeof global == \"object\" && global && global.Object === Object && global,\n      xe = typeof self == \"object\" && self && self.Object === Object && self,\n      Ie = ze || xe || Function(\"return this\")(),\n      Fe = typeof exports == \"object\" && exports && !exports.nodeType && exports,\n      Ee = Fe && typeof module == \"object\" && module && !module.nodeType && module,\n      Me = Ee && Ee.exports === Fe,\n      $e = Me && ze.process;\n\n  t: {\n    try {\n      Se = $e && $e.binding && $e.binding(\"util\");\n      break t;\n    } catch (t) {}\n\n    Se = void 0;\n  }\n\n  var Ue = Se && Se.isTypedArray,\n      Be = Array.prototype,\n      De = Object.prototype,\n      Pe = Ie[\"__core-js_shared__\"],\n      Le = Function.prototype.toString,\n      Ne = De.hasOwnProperty,\n      Ve = function () {\n    var t = /[^.]+$/.exec(Pe && Pe.keys && Pe.keys.IE_PROTO || \"\");\n    return t ? \"Symbol(src)_1.\" + t : \"\";\n  }(),\n      Ce = De.toString,\n      Re = Le.call(Object),\n      Te = RegExp(\"^\" + Le.call(Ne).replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"),\n      We = Me ? Ie.Buffer : ae,\n      qe = Ie.Symbol,\n      Ge = Ie.Uint8Array,\n      He = We ? We.a : ae,\n      Je = g(Object.getPrototypeOf),\n      Ke = Object.create,\n      Qe = De.propertyIsEnumerable,\n      Xe = Be.splice,\n      Ye = qe ? qe.isConcatSpreadable : ae,\n      Ze = qe ? qe.toStringTag : ae,\n      tn = function () {\n    try {\n      var t = gt(Object, \"defineProperty\");\n      return t({}, \"\", {}), t;\n    } catch (t) {}\n  }(),\n      en = Math.floor,\n      nn = Object.getOwnPropertySymbols,\n      rn = We ? We.isBuffer : ae,\n      on = g(Object.keys),\n      un = Math.max,\n      cn = Math.min,\n      an = Date.now,\n      fn = gt(Ie, \"DataView\"),\n      ln = gt(Ie, \"Map\"),\n      sn = gt(Ie, \"Promise\"),\n      bn = gt(Ie, \"Set\"),\n      hn = gt(Ie, \"WeakMap\"),\n      pn = gt(Object, \"create\"),\n      yn = It(fn),\n      jn = It(ln),\n      vn = It(sn),\n      gn = It(bn),\n      _n = It(hn),\n      dn = qe ? qe.prototype : ae,\n      An = dn ? dn.valueOf : ae,\n      wn = dn ? dn.toString : ae,\n      mn = function () {\n    function t() {}\n\n    return function (e) {\n      return Vt(e) ? Ke ? Ke(e) : (t.prototype = e, e = new t(), t.prototype = ae, e) : {};\n    };\n  }();\n\n  A.prototype.clear = function () {\n    this.__data__ = pn ? pn(null) : {}, this.size = 0;\n  }, A.prototype.delete = function (t) {\n    return t = this.has(t) && delete this.__data__[t], this.size -= t ? 1 : 0, t;\n  }, A.prototype.get = function (t) {\n    var e = this.__data__;\n    return pn ? (t = e[t], \"__lodash_hash_undefined__\" === t ? ae : t) : Ne.call(e, t) ? e[t] : ae;\n  }, A.prototype.has = function (t) {\n    var e = this.__data__;\n    return pn ? e[t] !== ae : Ne.call(e, t);\n  }, A.prototype.set = function (t, e) {\n    var n = this.__data__;\n    return this.size += this.has(t) ? 0 : 1, n[t] = pn && e === ae ? \"__lodash_hash_undefined__\" : e, this;\n  }, w.prototype.clear = function () {\n    this.__data__ = [], this.size = 0;\n  }, w.prototype.delete = function (t) {\n    var e = this.__data__;\n    return t = I(e, t), !(0 > t) && (t == e.length - 1 ? e.pop() : Xe.call(e, t, 1), --this.size, true);\n  }, w.prototype.get = function (t) {\n    var e = this.__data__;\n    return t = I(e, t), 0 > t ? ae : e[t][1];\n  }, w.prototype.has = function (t) {\n    return -1 < I(this.__data__, t);\n  }, w.prototype.set = function (t, e) {\n    var n = this.__data__,\n        r = I(n, t);\n    return 0 > r ? (++this.size, n.push([t, e])) : n[r][1] = e, this;\n  }, m.prototype.clear = function () {\n    this.size = 0, this.__data__ = {\n      hash: new A(),\n      map: new (ln || w)(),\n      string: new A()\n    };\n  }, m.prototype.delete = function (t) {\n    return t = jt(this, t).delete(t), this.size -= t ? 1 : 0, t;\n  }, m.prototype.get = function (t) {\n    return jt(this, t).get(t);\n  }, m.prototype.has = function (t) {\n    return jt(this, t).has(t);\n  }, m.prototype.set = function (t, e) {\n    var n = jt(this, t),\n        r = n.size;\n    return n.set(t, e), this.size += n.size == r ? 0 : 1, this;\n  }, O.prototype.add = O.prototype.push = function (t) {\n    return this.__data__.set(t, \"__lodash_hash_undefined__\"), this;\n  }, O.prototype.has = function (t) {\n    return this.__data__.has(t);\n  }, S.prototype.clear = function () {\n    this.__data__ = new w(), this.size = 0;\n  }, S.prototype.delete = function (t) {\n    var e = this.__data__;\n    return t = e.delete(t), this.size = e.size, t;\n  }, S.prototype.get = function (t) {\n    return this.__data__.get(t);\n  }, S.prototype.has = function (t) {\n    return this.__data__.has(t);\n  }, S.prototype.set = function (t, e) {\n    var n = this.__data__;\n\n    if (n instanceof w) {\n      var r = n.__data__;\n      if (!ln || 199 > r.length) return r.push([t, e]), this.size = ++n.size, this;\n      n = this.__data__ = new m(r);\n    }\n\n    return n.set(t, e), this.size = n.size, this;\n  };\n\n  var On = function (t, e) {\n    return function (n, r) {\n      if (null == n) return n;\n      if (!Dt(n)) return t(n, r);\n\n      for (var o = n.length, u = e ? o : -1, c = Object(n); (e ? u-- : ++u < o) && false !== r(c[u], u, c););\n\n      return n;\n    };\n  }(function (t, e) {\n    return t && Sn(t, e, Yt);\n  }),\n      Sn = function (t) {\n    return function (e, n, r) {\n      var o = -1,\n          u = Object(e);\n      r = r(e);\n\n      for (var c = r.length; c--;) {\n        var i = r[t ? c : ++o];\n        if (false === n(u[i], i, u)) break;\n      }\n\n      return e;\n    };\n  }(),\n      kn = tn ? function (t, e) {\n    return tn(t, \"toString\", {\n      configurable: true,\n      enumerable: false,\n      value: ee(e),\n      writable: true\n    });\n  } : ne,\n      zn = bn && 1 / _(new bn([, -0]))[1] == fe ? function (t) {\n    return new bn(t);\n  } : oe,\n      xn = nn ? function (t) {\n    return null == t ? [] : (t = Object(t), o(nn(t), function (e) {\n      return Qe.call(t, e);\n    }));\n  } : ce,\n      In = nn ? function (t) {\n    for (var e = []; t;) i(e, xn(t)), t = Je(t);\n\n    return e;\n  } : ce,\n      Fn = L;\n\n  (fn && \"[object DataView]\" != Fn(new fn(new ArrayBuffer(1))) || ln && \"[object Map]\" != Fn(new ln()) || sn && \"[object Promise]\" != Fn(sn.resolve()) || bn && \"[object Set]\" != Fn(new bn()) || hn && \"[object WeakMap]\" != Fn(new hn())) && (Fn = function (t) {\n    var e = L(t);\n    if (t = (t = \"[object Object]\" == e ? t.constructor : ae) ? It(t) : \"\") switch (t) {\n      case yn:\n        return \"[object DataView]\";\n\n      case jn:\n        return \"[object Map]\";\n\n      case vn:\n        return \"[object Promise]\";\n\n      case gn:\n        return \"[object Set]\";\n\n      case _n:\n        return \"[object WeakMap]\";\n    }\n    return e;\n  });\n\n  var En = function (t) {\n    var e = 0,\n        n = 0;\n    return function () {\n      var r = an(),\n          o = 16 - (r - n);\n\n      if (n = r, 0 < o) {\n        if (800 <= ++e) return arguments[0];\n      } else e = 0;\n\n      return t.apply(ae, arguments);\n    };\n  }(kn),\n      Mn = function (t) {\n    t = Ut(t, function (t) {\n      return 500 === e.size && e.clear(), t;\n    });\n    var e = t.cache;\n    return t;\n  }(function (t) {\n    var e = [];\n    return he.test(t) && e.push(\"\"), t.replace(pe, function (t, n, r, o) {\n      e.push(r ? o.replace(je, \"$1\") : n || t);\n    }), e;\n  }),\n      $n = X($t),\n      Un = function (t) {\n    return function (e, n, r) {\n      var o = Object(e);\n\n      if (!Dt(e)) {\n        var u = yt(n, 3);\n        e = Yt(e), n = function (t) {\n          return u(o[t], t, o);\n        };\n      }\n\n      return n = t(e, n, r), -1 < n ? o[u ? e[n] : n] : ae;\n    };\n  }(Ft);\n\n  Ut.Cache = m;\n  var Bn = N(function () {\n    return arguments;\n  }()) ? N : function (t) {\n    return Ct(t) && Ne.call(t, \"callee\") && !Qe.call(t, \"callee\");\n  },\n      Dn = Array.isArray,\n      Pn = rn || ie,\n      Ln = Ue ? p(Ue) : R,\n      Nn = at(function (t, e, n) {\n    H(t, e, n);\n  }),\n      Vn = at(function (t, e, n, r) {\n    H(t, e, n, r);\n  }),\n      Cn = bt(function (t, e) {\n    var n = {};\n    if (null == t) return n;\n    var r = false;\n    e = c(e, function (e) {\n      return e = tt(e, t), r || (r = 1 < e.length), e;\n    }), ut(t, pt(t), n), r && (n = $(n, 7, ft));\n\n    for (var o = e.length; o--;) Z(n, e[o]);\n\n    return n;\n  }),\n      Rn = bt(function (t, e) {\n    return null == t ? {} : J(t, e);\n  });\n  d.constant = ee, d.filter = function (t, e) {\n    return (Dn(t) ? o : U)(t, yt(e, 3));\n  }, d.flatten = Et, d.iteratee = re, d.keys = Yt, d.keysIn = Zt, d.map = function (t, e) {\n    return (Dn(t) ? c : W)(t, yt(e, 3));\n  }, d.memoize = Ut, d.merge = Nn, d.mergeWith = Vn, d.omit = Cn, d.pick = Rn, d.property = ue, d.pull = $n, d.pullAll = $t, d.remove = function (t, e) {\n    var n = [];\n    if (!t || !t.length) return n;\n    var r = -1,\n        o = [],\n        u = t.length;\n\n    for (e = yt(e, 3); ++r < u;) {\n      var c = t[r];\n      e(c, r, t) && (n.push(c), o.push(r));\n    }\n\n    for (r = t ? o.length : 0, u = r - 1; r--;) if (c = o[r], r == u || c !== i) {\n      var i = c;\n      mt(c) ? Xe.call(t, c, 1) : Z(t, c);\n    }\n\n    return n;\n  }, d.toPlainObject = Jt, d.uniq = function (t) {\n    if (t && t.length) t: {\n      var e = -1,\n          n = u,\n          r = t.length,\n          o = true,\n          c = [],\n          i = c;\n\n      if (200 <= r) {\n        if (n = zn(t)) {\n          t = _(n);\n          break t;\n        }\n\n        o = false, n = j, i = new O();\n      } else i = c;\n\n      e: for (; ++e < r;) {\n        var a = t[e],\n            f = a,\n            a = 0 !== a ? a : 0;\n\n        if (o && f === f) {\n          for (var l = i.length; l--;) if (i[l] === f) continue e;\n\n          c.push(a);\n        } else n(i, f, void 0) || (i !== c && i.push(f), c.push(a));\n      }\n\n      t = c;\n    } else t = [];\n    return t;\n  }, d.values = te, d.cloneDeep = function (t) {\n    return $(t, 5);\n  }, d.eq = Bt, d.find = Un, d.findIndex = Ft, d.get = Qt, d.hasIn = Xt, d.identity = ne, d.includes = function (t, e, n, r) {\n    return t = Dt(t) ? t : te(t), n = n && !r ? Gt(n) : 0, r = t.length, 0 > n && (n = un(r + n, 0)), Tt(t) ? n <= r && -1 < t.indexOf(e, n) : !!r && -1 < s(t, e, n);\n  }, d.isArguments = Bn, d.isArray = Dn, d.isArrayLike = Dt, d.isArrayLikeObject = Pt, d.isBuffer = Pn, d.isFunction = Lt, d.isLength = Nt, d.isObject = Vt, d.isObjectLike = Ct, d.isPlainObject = Rt, d.isString = Tt, d.isSymbol = Wt, d.isTypedArray = Ln, d.last = Mt, d.stubArray = ce, d.stubFalse = ie, d.noop = oe, d.sortedIndexBy = function (t, e, n) {\n    n = yt(n, 2), e = n(e);\n\n    for (var r = 0, o = null == t ? 0 : t.length, u = e !== e, c = null === e, i = Wt(e), a = e === ae; r < o;) {\n      var f = en((r + o) / 2),\n          l = n(t[f]),\n          s = l !== ae,\n          b = null === l,\n          h = l === l,\n          p = Wt(l);\n      (u ? h : a ? h && s : c ? h && s && !b : i ? h && s && !b && !p : b || p ? 0 : l < e) ? r = f + 1 : o = f;\n    }\n\n    return cn(o, 4294967294);\n  }, d.toFinite = qt, d.toInteger = Gt, d.toNumber = Ht, d.toString = Kt, d.VERSION = \"4.17.4\",  true ? (Ie._ = d, !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return d;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : Ee ? ((Ee.exports = d)._ = d, Fe._ = d) : Ie._ = d;\n}).call(this);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(5)(module)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function () {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function () {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return RelayManager; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_standard_file_js_dist_regenerator_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_standard_file_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_standard_file_js__);\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar RelayManager =\n/*#__PURE__*/\nfunction () {\n  function RelayManager() {\n    _classCallCheck(this, RelayManager);\n\n    this.httpManger = new __WEBPACK_IMPORTED_MODULE_1_standard_file_js__[\"SFHttpManager\"]();\n    this.httpManger.setJWTRequestHandler(function () {});\n  }\n\n  _createClass(RelayManager, [{\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      this.credentials = credentials;\n    }\n  }, {\n    key: \"uploadFile\",\n    value: function () {\n      var _uploadFile = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(name, item, integration) {\n        var _this = this;\n\n        var url, params;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                url = \"\".concat(integration.content.relayUrl, \"/integrations/save-item\");\n                params = {\n                  file: {\n                    name: name,\n                    item: item // base64 string of file\n\n                  },\n                  source: integration.content.source,\n                  authorization: integration.content.authorization\n                };\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this.httpManger.postAbsolute(url, params, function (response) {\n                    resolve(response.metadata);\n                  }, function (errorResponse) {\n                    var error = errorResponse.error;\n\n                    if (!error) {\n                      error = {\n                        message: \"File upload failed.\"\n                      };\n                    }\n\n                    console.log(\"Upload error response\", error);\n                    reject(error);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function uploadFile(_x, _x2, _x3) {\n        return _uploadFile.apply(this, arguments);\n      }\n\n      return uploadFile;\n    }()\n  }, {\n    key: \"downloadFile\",\n    value: function () {\n      var _downloadFile = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(fileDescriptor, integration) {\n        var _this2 = this;\n\n        var url, params;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                url = \"\".concat(integration.content.relayUrl, \"/integrations/download-item\");\n                params = {\n                  metadata: fileDescriptor.content.serverMetadata,\n                  authorization: integration.content.authorization\n                };\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this2.httpManger.postAbsolute(url, params, function (response) {\n                    resolve(response);\n                  }, function (errorResponse) {\n                    var error = errorResponse.error;\n                    console.log(\"Download error response\", errorResponse);\n                    reject(error);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function downloadFile(_x4, _x5) {\n        return _downloadFile.apply(this, arguments);\n      }\n\n      return downloadFile;\n    }()\n  }, {\n    key: \"deleteFile\",\n    value: function () {\n      var _deleteFile = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3(fileDescriptor, integration) {\n        var _this3 = this;\n\n        var url, params;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                url = \"\".concat(integration.content.relayUrl, \"/integrations/delete-item\");\n                params = {\n                  metadata: fileDescriptor.content.serverMetadata,\n                  authorization: integration.content.authorization\n                };\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this3.httpManger.postAbsolute(url, params, function (response) {\n                    resolve(response);\n                  }, function (errorResponse) {\n                    var error = errorResponse.error;\n                    console.log(\"Download error response\", errorResponse);\n                    reject(error);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function deleteFile(_x6, _x7) {\n        return _deleteFile.apply(this, arguments);\n      }\n\n      return deleteFile;\n    }()\n  }]);\n\n  return RelayManager;\n}();\n\n\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=ba63b9826f49ef1cd5b6.worker.js.map",null);};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Utils; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Utils =
/*#__PURE__*/
function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, null, [{
    key: "base64toBinary",
    value: function base64toBinary(dataURI) {
      var binary = atob(dataURI);
      var array = [];

      for (var i = 0; i < binary.length; i++) {
        array.push(binary.charCodeAt(i));
      }

      return new Uint8Array(array);
    }
  }, {
    key: "downloadData",
    value: function downloadData(data, fileName, fileType) {
      var link = document.createElement('a');
      link.setAttribute('download', fileName);
      link.href = this.tempUrlForData(data, fileType);
      document.body.appendChild(link);
      link.click();
      link.remove();
    }
  }, {
    key: "tempUrlForData",
    value: function tempUrlForData(data, fileType) {
      return window.URL.createObjectURL(new Blob([data], {
        type: fileType ? fileType : 'text/json'
      }));
    }
  }]);

  return Utils;
}();



/***/ })
/******/ ]);
//# sourceMappingURL=filesafe.js.map